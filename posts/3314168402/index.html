<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="个人站，学习记录、实践教程、资料收集等，哈哈哈。"><title>自动驾驶仿真 - AirSim (5) - 图片 APIs - C++ | Sun of Beach</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><div class="darkmode-toggle">🌓</div><script>var prefersDarkMode = window.matchMedia('(prefers-color-scheme: dark)');
var toggle = document.querySelector('.darkmode-toggle');
var html = document.querySelector('html');

html.dataset.dark = localStorage.dark || prefersDarkMode.matches;

toggle.addEventListener('click', () => {
localStorage.dark = !(html.dataset.dark == 'true');
html.dataset.dark = localStorage.dark;
});</script><meta name="generator" content="Hexo 6.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">自动驾驶仿真 - AirSim (5) - 图片 APIs - C++</h1><a id="logo" href="/.">Sun of Beach</a><p class="description">Stay Angry, Stay Foolish</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">自动驾驶仿真 - AirSim (5) - 图片 APIs - C++</h1><div class="post-meta">2020-06-22<span> | </span><span class="category"><a href="/categories/%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6/">自动驾驶</a></span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 4.2k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i><span class="post-count"> 19</span><span class="post-meta-item-text"> 分钟</span></span></span></div><div class="post-content"><p>接下去主要介绍一下 <code>AirSim</code> 的 <code>APIs</code> 的使用, 参考 <a target="_blank" rel="noopener" href="https://microsoft.github.io/AirSim/image_apis/">官方</a> 文档, 并结合结合 OpenCV 来用 C++ 实现部分 官方 Python 的例程.</p>
<span id="more"></span>

<hr>
<p>[TOC]</p>
<hr>
<h2 id="读取相机图片"><a href="#读取相机图片" class="headerlink" title="读取相机图片"></a>读取相机图片</h2><p>官方<a target="_blank" rel="noopener" href="https://microsoft.github.io/AirSim/image_apis/">例程</a> 提供了两种读取相机图片的方式 (需要修改, 代码参考如下). 这个例程获取 “0” 号相机的单幅图片. 返回值为 png 格式图片的字节. 如果要获取其他格式图片或者其他可用相机的图片参考下一小节.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;vehicles/multirotor/api/MultirotorRpcLibClient. hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getOneImage</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> msr::airlib;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//for car use CarRpcLibClient</span></span><br><span class="line">    msr::airlib::MultirotorRpcLibClient client;</span><br><span class="line"></span><br><span class="line">    msr::airlib::vector&lt;<span class="type">uint8_t</span>&gt; png_image = client. <span class="built_in">simGetImage</span>(<span class="string">&quot;0&quot;</span>, VehicleCameraBase::ImageType::Scene);</span><br><span class="line">    <span class="comment">//do something with images</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="更加灵活的获取图片"><a href="#更加灵活的获取图片" class="headerlink" title="更加灵活的获取图片"></a>更加灵活的获取图片</h2><p><code>simGetImages</code> API 相比于 <code>simGetImage</code> API 更加复杂, 举个例子, 你可以通过单个 API 调用获取左侧、右侧、左侧的相机深度视图. <code>simGetImages</code>API 允许你获取未压缩的图片或者浮点单通道的图片数据 (而不是 8 位 3 通道 (RGB)).</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ImageRequest</span>(<span class="type">const</span> std::string&amp; camera_name_val, ImageCaptureBase::ImageType image_type_val, <span class="type">bool</span> pixels_as_float_val = <span class="literal">false</span>, <span class="type">bool</span> compress_val = <span class="literal">true</span>)</span><br></pre></td></tr></table></figure>

<p><code>ImageRequest</code> 图片请求类的参数为</p>
<p><code>camera_name_val</code>: 相机编号, 可以输入 <code>&quot;0&quot;</code>, <code>&quot;1&quot;</code>, <code>&quot;2&quot;</code>, <code>&quot;3&quot;</code>, <code>&quot;4&quot;</code> 或者 <code>&quot;front_center&quot;</code>, <code>&quot;front_right&quot;</code>, <code>&quot;front_left&quot;</code>, <code>&quot;fpv&quot;</code>, <code>&quot;back_center&quot;</code>.</p>
<p><code>image_type_val</code>: 图片类型, 可支持的图片类型有:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Scene = <span class="number">0</span>,</span><br><span class="line">DepthPlanner = <span class="number">1</span>,</span><br><span class="line">DepthPerspective = <span class="number">2</span>,</span><br><span class="line">DepthVis = <span class="number">3</span>,</span><br><span class="line">DisparityNormalized = <span class="number">4</span>,</span><br><span class="line">Segmentation = <span class="number">5</span>,</span><br><span class="line">SurfaceNormals = <span class="number">6</span>,</span><br><span class="line">Infrared = <span class="number">7</span></span><br></pre></td></tr></table></figure>

<p><code>pixels_as_float_val</code>: 是否为浮点值, 默认为 <code>false</code>.</p>
<p><code>compress_val</code>: 是否是压缩数据, 默认为 <code>true</code></p>
<p><strong>PS:</strong> 后两个参数这里会影响到 opencv 的矩阵或者解码图片. 这里通过将一组图像请求信息 <code>ImageRequest</code> 放入容器中, 通过 <code>simGetImages</code> 一次性请求. 之后可通过迭代获取各个相机的图像数据.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getStereoAndDepthImages</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> msr::airlib;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> VehicleCameraBase::ImageRequest ImageRequest;</span><br><span class="line">    <span class="keyword">typedef</span> VehicleCameraBase::ImageResponse ImageResponse;</span><br><span class="line">    <span class="keyword">typedef</span> VehicleCameraBase::ImageType ImageType;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//for car use</span></span><br><span class="line">    <span class="comment">//msr::airlib::CarRpcLibClient client;</span></span><br><span class="line">    msr::airlib::MultirotorRpcLibClient client;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//get right, left and depth images. First two as png, second as float16.</span></span><br><span class="line">    msr::airlib::vector&lt;ImageRequest&gt; request = &#123;</span><br><span class="line">        <span class="comment">//png format</span></span><br><span class="line">        <span class="built_in">ImageRequest</span>(<span class="string">&quot;0&quot;</span>, ImageType::Scene),</span><br><span class="line">        <span class="comment">//uncompressed RGB array bytes</span></span><br><span class="line">        <span class="built_in">ImageRequest</span>(<span class="string">&quot;1&quot;</span>, ImageType::Scene, <span class="literal">false</span>, <span class="literal">false</span>),</span><br><span class="line">        <span class="comment">//floating point uncompressed image</span></span><br><span class="line">        <span class="built_in">ImageRequest</span>(<span class="string">&quot;1&quot;</span>, ImageType::DepthPlanner, <span class="literal">true</span>)</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> vector&lt;ImageResponse&gt;&amp; response = client. <span class="built_in">simGetImages</span>(request);</span><br><span class="line">    <span class="comment">//do something with response which contains image data, pose, timestamp etc</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="通过-OpenCV-显示图片"><a href="#通过-OpenCV-显示图片" class="headerlink" title="通过 OpenCV 显示图片"></a>通过 <code>OpenCV</code> 显示图片</h2><p>虽然获取到的图片是 <code>uint8_t</code> 类型的数据, 但是无法通过直接转换成 <code>cv::Mat</code> 来使用 <code>OpenCV</code> 进行操作处理. 主要是获取到的是压缩的图片数据. 这里要使用 <code>cv::imdecode</code> 来对图片进行解码. 对应的两个 API 略有不同.</p>
<p>如果是压缩的数据：需要用 <code>cv::imdecode</code> 来解码生成 <code>cv::Mat</code> 的数据格式； 如果是非压缩的数据, 可以直接进行构造. 具体可见代码. 深度图片需要对 Mat 调用 <code>normalize</code> 归一化, 否则图片可能全白.</p>
<p>参考资料:</p>
<p><a target="_blank" rel="noopener" href="https://github.com/microsoft/AirSim/issues/966">https://github.com/microsoft/AirSim/issues/966</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/Microsoft/AirSim/issues/491">https://github.com/Microsoft/AirSim/issues/491</a></p>
<p>完整源码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;opencv2/opencv. hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;vehicles/multirotor/api/MultirotorRpcLibClient. hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ImageAPIs::getStereoAndDepthImages4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">namespace</span> msr::airlib;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">typedef</span> ImageCaptureBase::ImageRequest ImageRequest;</span><br><span class="line">  <span class="keyword">typedef</span> ImageCaptureBase::ImageResponse ImageResponse;</span><br><span class="line">  <span class="keyword">typedef</span> ImageCaptureBase::ImageType ImageType;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// for car use</span></span><br><span class="line">  <span class="comment">// msr::airlib::CarRpcLibClient client;</span></span><br><span class="line">  msr::airlib::MultirotorRpcLibClient client;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// get right, left and depth images. First two as png, second as float16.</span></span><br><span class="line">  msr::airlib::vector&lt;ImageRequest&gt; request = &#123;<span class="comment">// png format</span></span><br><span class="line">                                               <span class="built_in">ImageRequest</span>(<span class="string">&quot;0&quot;</span>, ImageType::Scene),</span><br><span class="line">                                               <span class="comment">// uncompressed RGB array bytes</span></span><br><span class="line">                                               <span class="built_in">ImageRequest</span>(<span class="string">&quot;1&quot;</span>, ImageType::Scene, <span class="literal">false</span>, <span class="literal">false</span>),</span><br><span class="line">                                               <span class="comment">// floating point uncompressed image</span></span><br><span class="line">                                               <span class="built_in">ImageRequest</span>(<span class="string">&quot;1&quot;</span>, ImageType::DepthPlanner, <span class="literal">true</span>)&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="type">const</span> std::vector&lt;ImageResponse&gt;&amp; response = client. <span class="built_in">simGetImages</span>(request);</span><br><span class="line">      <span class="keyword">if</span> (response. <span class="built_in">size</span>() != request. <span class="built_in">size</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Images were not received!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 左侧相机 ImageRequest(&quot;0&quot;, ImageType::Scene)</span></span><br><span class="line">      <span class="comment">// 默认参数是压缩数据, 调用 imdecode</span></span><br><span class="line">      cv::Mat left_mat = cv::<span class="built_in">imdecode</span>(response. <span class="built_in">at</span>(<span class="number">0</span>). image_data_uint8, cv::IMREAD_UNCHANGED);</span><br><span class="line">      cv::<span class="built_in">imshow</span>(<span class="string">&quot;left&quot;</span>, left_mat);</span><br><span class="line">      cv::<span class="built_in">waitKey</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">      <span class="function">cv::Mat <span class="title">right_mat</span><span class="params">(response. at(<span class="number">1</span>). height, response. at(<span class="number">1</span>). width, CV_8UC3,</span></span></span><br><span class="line"><span class="params"><span class="function">                        (<span class="type">void</span>*)response. at(<span class="number">1</span>). image_data_uint8. data())</span></span>;</span><br><span class="line">      cv::<span class="built_in">imshow</span>(<span class="string">&quot;right&quot;</span>, right_mat);</span><br><span class="line">      cv::<span class="built_in">waitKey</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 深度图片 ImageRequest(&quot;1&quot;, ImageType::DepthPlanner, true)</span></span><br><span class="line">      <span class="comment">// 这里需要对 Mat 调用 normalize 归一化, 否则图片可能全白.</span></span><br><span class="line">      <span class="function">cv::Mat <span class="title">gt_depth_mat</span><span class="params">(response. at(<span class="number">2</span>). height, response. at(<span class="number">2</span>). width, CV_32FC1,</span></span></span><br><span class="line"><span class="params"><span class="function">                           (<span class="type">void</span>*)response. at(<span class="number">2</span>). image_data_float. data())</span></span>;</span><br><span class="line">      cv::<span class="built_in">normalize</span>(gt_depth_mat, gt_depth_mat, <span class="number">1</span>, <span class="number">0</span>, cv::NORM_MINMAX);</span><br><span class="line">      cv::<span class="built_in">imshow</span>(<span class="string">&quot;depth&quot;</span>, gt_depth_mat);</span><br><span class="line">      cv::<span class="built_in">waitKey</span>(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="built_in">catch</span> (rpc::timeout&amp; t) &#123;</span><br><span class="line">    <span class="comment">// will display a message like</span></span><br><span class="line">    <span class="comment">// rpc::timeout: Timeout of 50ms while calling RPC function &#x27;sleep&#x27;</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; t. <span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/image-20200613175100646.png" alt="image-20200613175100646"></p>
<h2 id="可用的相机"><a href="#可用的相机" class="headerlink" title="可用的相机"></a>可用的相机</h2><h3 id="车"><a href="#车" class="headerlink" title="车"></a>车</h3><p><code>API</code> 可以通过一下相机名称调用: <code>&quot;front_center&quot;</code>, <code>&quot;front_right&quot;</code>, <code>&quot;front_left&quot;</code>, <code>&quot;fpv&quot;</code>, <code>&quot;back_center&quot;</code>. FPV 相机处于驾驶员头部位置 (First Person Virsion, 第一人称视角).</p>
<h3 id="飞行器"><a href="#飞行器" class="headerlink" title="飞行器"></a>飞行器</h3><p><code>API</code> 可以通过一下相机名称调用: <code>front_center</code>, <code>front_right</code>, <code>front_left</code>, <code>bottom_center</code> 和<code>back_center</code>.</p>
<h3 id="计算机视觉模式"><a href="#计算机视觉模式" class="headerlink" title="计算机视觉模式"></a>计算机视觉模式</h3><p>和飞行器的一致.</p>
<h3 id="向后兼容的相机名称"><a href="#向后兼容的相机名称" class="headerlink" title="向后兼容的相机名称"></a>向后兼容的相机名称</h3><p>在 AirSim v1. 2 之前, 相机是通过 ID 来指定的. 考虑到向后兼容, 依然可以用下相机的 ID 序号来代替, 顺序与上述名称保持一直. 此外, 相机名称为空字符串 <code>&quot;&quot;</code> 也是可以的, 也就是默认相机, 通常为 <code>&quot;0&quot;</code> .</p>
<h2 id="“Computer-Vision”-模式"><a href="#“Computer-Vision”-模式" class="headerlink" title="“Computer Vision” 模式"></a>“Computer Vision” 模式</h2><p>可以在 AirSim 中使用 “Computer Virsion” 模式. 在这个模式下, 物理引擎被禁用, 没有载具, 只有相机. 可以通过键盘移动视角 (按 F1 可以看帮助). 可以按下 Record 按钮来持续生成图片. 或者可以调用 APIs 来移动相机和获取图片.</p>
<p>编辑 <a target="_blank" rel="noopener" href="https://microsoft.github.io/AirSim/settings/">settings. json</a> 文件可以激活这种模式. 在用户的 <code>Documents\AirSim</code> 文件夹内 (Linux 则在 <code>Documents\AirSim</code>) 然后更改下列变量的值.</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;SettingsVersion&quot;</span><span class="punctuation">:</span> <span class="number">1.</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;SimMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ComputerVision&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://github.com/Microsoft/AirSim/tree/master/PythonClient//computer_vision/cv_mode.py">Python 例程</a> 移动相机并获取图片.</p>
<p>这是模式是受 <a target="_blank" rel="noopener" href="http://unrealcv.org/">UnrealCV project</a> 启发的.</p>
<p><strong>PS</strong>:</p>
<ul>
<li>我这里提供了 C++ 的版本, 直接用 OpenCV 动态显示了, 没有保存成图片格式.</li>
<li><code>settings. json</code> 编辑完成后, 不需要重启 UE 编辑器, 只要重新运行当前项目即可.</li>
<li>方向键调整相机位置(前后左右), wasd 调整朝向.</li>
<li>欧拉角转四元数可以参考 Eigen 库, 这里没写.</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ImageAPIs::CVMode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">namespace</span> msr::airlib;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">typedef</span> ImageCaptureBase::ImageRequest ImageRequest;</span><br><span class="line">  <span class="keyword">typedef</span> ImageCaptureBase::ImageResponse ImageResponse;</span><br><span class="line">  <span class="keyword">typedef</span> ImageCaptureBase::ImageType ImageType;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// for car use</span></span><br><span class="line">  msr::airlib::MultirotorRpcLibClient client;</span><br><span class="line">  client. <span class="built_in">confirmConnection</span>();</span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Press any key to set camera-0 gimble to 15-degree pitch. \n&quot;</span>;</span><br><span class="line">  std::<span class="built_in">getchar</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// TODO client. simSetCameraOrientation();</span></span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Press any key to get camera parameters. \n&quot;</span>;</span><br><span class="line">  std::<span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> camera_name = <span class="number">0</span>; camera_name &lt; <span class="number">5</span>; ++camera_name) &#123;</span><br><span class="line">    CameraInfo camera_info = client. <span class="built_in">simGetCameraInfo</span>(std::<span class="built_in">to_string</span>(camera_name));</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;CameraInfo &quot;</span> &lt;&lt; camera_name &lt;&lt; <span class="string">&quot;: \n&quot;</span></span><br><span class="line">              &lt;&lt; <span class="string">&quot;Pose: &quot;</span> &lt;&lt; camera_info. pose. position. <span class="built_in">x</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; camera_info. pose. position. <span class="built_in">y</span>() &lt;&lt; <span class="string">&quot; &quot;</span></span><br><span class="line">              &lt;&lt; camera_info. pose. position. <span class="built_in">z</span>() &lt;&lt; std::endl</span><br><span class="line">              &lt;&lt; <span class="string">&quot;FOV: &quot;</span> &lt;&lt; camera_info. fov &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// get right, left and depth images. First two as png, second as float16.</span></span><br><span class="line">  msr::airlib::vector&lt;ImageRequest&gt; request = &#123;<span class="built_in">ImageRequest</span>(<span class="string">&quot;0&quot;</span>, ImageType::DepthVis),</span><br><span class="line">                                               <span class="built_in">ImageRequest</span>(<span class="string">&quot;1&quot;</span>, ImageType::DepthPerspective, <span class="literal">true</span>),</span><br><span class="line">                                               <span class="built_in">ImageRequest</span>(<span class="string">&quot;2&quot;</span>, ImageType::Segmentation),</span><br><span class="line">                                               <span class="built_in">ImageRequest</span>(<span class="string">&quot;3&quot;</span>, ImageType::Scene),</span><br><span class="line">                                               <span class="built_in">ImageRequest</span>(<span class="string">&quot;4&quot;</span>, ImageType::DisparityNormalized),</span><br><span class="line">                                               <span class="built_in">ImageRequest</span>(<span class="string">&quot;4&quot;</span>, ImageType::SurfaceNormals)&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">/* TODO</span></span><br><span class="line"><span class="comment">   client. simSetVehiclePose();</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> msr::airlib::vector&lt;ImageResponse&gt;&amp; responses = client. <span class="built_in">simGetImages</span>(request);</span><br><span class="line">    <span class="comment">// do something with response which contains image data, pose, timestamp etc</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; responses. <span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">      <span class="function">std::string <span class="title">strid</span><span class="params">(std::to_string(i))</span></span>;</span><br><span class="line">      <span class="type">const</span> <span class="keyword">auto</span>&amp; response = responses. <span class="built_in">at</span>(i);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (response. pixels_as_float) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Type &quot;</span> &lt;&lt; <span class="built_in">int</span>(response. image_type) &lt;&lt; <span class="string">&quot;, size &quot;</span> &lt;&lt; response. image_data_float. <span class="built_in">size</span>() &lt;&lt; <span class="string">&quot;, pos &quot;</span></span><br><span class="line">                  &lt;&lt; response. camera_position. <span class="built_in">x</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; response. camera_position. <span class="built_in">y</span>() &lt;&lt; <span class="string">&quot; &quot;</span></span><br><span class="line">                  &lt;&lt; response. camera_position. <span class="built_in">z</span>() &lt;&lt; std::endl;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Type &quot;</span> &lt;&lt; <span class="built_in">int</span>(response. image_type) &lt;&lt; <span class="string">&quot;, size &quot;</span> &lt;&lt; response. image_data_uint8. <span class="built_in">size</span>() &lt;&lt; <span class="string">&quot;, pos &quot;</span></span><br><span class="line">                  &lt;&lt; response. camera_position. <span class="built_in">x</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; response. camera_position. <span class="built_in">y</span>() &lt;&lt; <span class="string">&quot; &quot;</span></span><br><span class="line">                  &lt;&lt; response. camera_position. <span class="built_in">z</span>() &lt;&lt; std::endl;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">switch</span> (response. image_type) &#123;</span><br><span class="line">        <span class="keyword">case</span> ImageType::Scene:</span><br><span class="line">          <span class="keyword">if</span> (!response. pixels_as_float &amp;&amp; response.compress) &#123;</span><br><span class="line">            cv::Mat img_mat = cv::<span class="built_in">imdecode</span>(response. image_data_uint8, cv::IMREAD_UNCHANGED);</span><br><span class="line">            cv::<span class="built_in">imshow</span>(response. camera_name + <span class="string">&quot;:Scene-&quot;</span> + strid, img_mat);</span><br><span class="line">            cv::<span class="built_in">waitKey</span>(<span class="number">5</span>);</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!response. pixels_as_float &amp;&amp; !response.compress) &#123;</span><br><span class="line">            cv::Mat <span class="built_in">img_mat</span>(response. height, response. width, CV_8UC3, (<span class="type">void</span>*)response. image_data_uint8. <span class="built_in">data</span>());</span><br><span class="line">            cv::<span class="built_in">imshow</span>(response. camera_name + <span class="string">&quot;:Scene-&quot;</span> + strid, img_mat);</span><br><span class="line">            cv::<span class="built_in">waitKey</span>(<span class="number">5</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> ImageType::DepthPlanner:</span><br><span class="line">          <span class="keyword">if</span> (!response. pixels_as_float &amp;&amp; response.compress) &#123;</span><br><span class="line">            cv::Mat img_mat = cv::<span class="built_in">imdecode</span>(response. image_data_uint8, cv::IMREAD_GRAYSCALE);</span><br><span class="line">            cv::<span class="built_in">imshow</span>(response. camera_name + <span class="string">&quot;:DepthPlanner-&quot;</span> + strid, img_mat);</span><br><span class="line">            cv::<span class="built_in">waitKey</span>(<span class="number">5</span>);</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (response. pixels_as_float &amp;&amp; response.compress) &#123;</span><br><span class="line">            cv::Mat <span class="built_in">img_mat</span>(response. height, response. width, CV_32FC1, (<span class="type">void</span>*)response. image_data_float. <span class="built_in">data</span>());</span><br><span class="line">            cv::<span class="built_in">normalize</span>(img_mat, img_mat, <span class="number">1</span>, <span class="number">0</span>, cv::NORM_MINMAX);</span><br><span class="line">            cv::<span class="built_in">imshow</span>(response. camera_name + <span class="string">&quot;:DepthPlanner-&quot;</span> + strid, img_mat);</span><br><span class="line">            cv::<span class="built_in">waitKey</span>(<span class="number">5</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ImageType::DepthPerspective:</span><br><span class="line">          <span class="keyword">if</span> (!response. pixels_as_float &amp;&amp; response.compress) &#123;</span><br><span class="line">            cv::Mat img_mat = cv::<span class="built_in">imdecode</span>(response. image_data_uint8, cv::IMREAD_GRAYSCALE);</span><br><span class="line">            cv::<span class="built_in">imshow</span>(response. camera_name + <span class="string">&quot;:DepthPerspective-&quot;</span> + strid, img_mat);</span><br><span class="line">            cv::<span class="built_in">waitKey</span>(<span class="number">5</span>);</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (response. pixels_as_float &amp;&amp; response.compress) &#123;</span><br><span class="line">            <span class="comment">// cv::Mat img_mat = cv::imdecode(response. image_data_float, cv::IMREAD_GRAYSCALE);</span></span><br><span class="line">            cv::Mat <span class="built_in">img_mat</span>(response. height, response. width, CV_32FC1, (<span class="type">void</span>*)response. image_data_float. <span class="built_in">data</span>());</span><br><span class="line">            cv::<span class="built_in">normalize</span>(img_mat, img_mat, <span class="number">1</span>, <span class="number">0</span>, cv::NORM_MINMAX);</span><br><span class="line">            cv::<span class="built_in">imshow</span>(response. camera_name + <span class="string">&quot;:DepthPerspective-&quot;</span> + strid, img_mat);</span><br><span class="line">            cv::<span class="built_in">waitKey</span>(<span class="number">5</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ImageType::DepthVis:</span><br><span class="line">          <span class="keyword">if</span> (!response. pixels_as_float &amp;&amp; response.compress) &#123;</span><br><span class="line">            cv::Mat img_mat = cv::<span class="built_in">imdecode</span>(response. image_data_uint8, cv::IMREAD_GRAYSCALE);</span><br><span class="line">            cv::<span class="built_in">imshow</span>(response. camera_name + <span class="string">&quot;:DepthVis-&quot;</span> + strid, img_mat);</span><br><span class="line">            cv::<span class="built_in">waitKey</span>(<span class="number">5</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ImageType::DisparityNormalized:</span><br><span class="line">          <span class="keyword">if</span> (response. pixels_as_float) &#123;</span><br><span class="line">            <span class="function">cv::Mat <span class="title">img_mat</span><span class="params">(response. height, response. width, CV_32FC1, (<span class="type">void</span>*)response. image_data_float. data())</span></span>;</span><br><span class="line">            cv::<span class="built_in">normalize</span>(img_mat, img_mat, <span class="number">1</span>, <span class="number">0</span>, cv::NORM_MINMAX);</span><br><span class="line">            cv::<span class="built_in">imshow</span>(response. camera_name + <span class="string">&quot;:DisparityNormalized-&quot;</span> + strid, img_mat);</span><br><span class="line">            cv::<span class="built_in">waitKey</span>(<span class="number">5</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ImageType::Segmentation:</span><br><span class="line">          <span class="keyword">if</span> (!response. pixels_as_float &amp;&amp; response.compress) &#123;</span><br><span class="line">            cv::Mat img_mat = cv::<span class="built_in">imdecode</span>(response. image_data_uint8, cv::IMREAD_UNCHANGED);</span><br><span class="line">            cv::<span class="built_in">imshow</span>(response. camera_name + <span class="string">&quot;:Segmentation-&quot;</span> + strid, img_mat);</span><br><span class="line">            cv::<span class="built_in">waitKey</span>(<span class="number">5</span>);</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!response. pixels_as_float &amp;&amp; !response.compress) &#123;</span><br><span class="line">            cv::Mat <span class="built_in">img_mat</span>(response. height, response. width, CV_8UC3, (<span class="type">void</span>*)response. image_data_uint8. <span class="built_in">data</span>());</span><br><span class="line">            cv::<span class="built_in">imshow</span>(response. camera_name + <span class="string">&quot;:Segmentation-&quot;</span> + strid, img_mat);</span><br><span class="line">            cv::<span class="built_in">waitKey</span>(<span class="number">5</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ImageType::SurfaceNormals:</span><br><span class="line">          <span class="keyword">if</span> (!response. pixels_as_float &amp;&amp; response.compress) &#123;</span><br><span class="line">            cv::Mat img_mat = cv::<span class="built_in">imdecode</span>(response. image_data_uint8, cv::IMREAD_UNCHANGED);</span><br><span class="line">            cv::<span class="built_in">imshow</span>(response. camera_name + <span class="string">&quot;:SurfaceNormals-&quot;</span> + strid, img_mat);</span><br><span class="line">            cv::<span class="built_in">waitKey</span>(<span class="number">5</span>);</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!response. pixels_as_float &amp;&amp; !response.compress) &#123;</span><br><span class="line">            cv::Mat <span class="built_in">img_mat</span>(response. height, response. width, CV_8UC3, (<span class="type">void</span>*)response. image_data_uint8. <span class="built_in">data</span>());</span><br><span class="line">            cv::<span class="built_in">imshow</span>(response. camera_name + <span class="string">&quot;:SurfaceNormals-&quot;</span> + strid, img_mat);</span><br><span class="line">            cv::<span class="built_in">waitKey</span>(<span class="number">5</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">auto</span> pose = client. <span class="built_in">simGetVehiclePose</span>();</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;Vehicle Pose: &quot;</span> &lt;&lt; pose. position. <span class="built_in">x</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; pose. position. <span class="built_in">y</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; pose. position. <span class="built_in">y</span>()</span><br><span class="line">                &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/image-20200613184934655.png" alt="image-20200613184934655"></p>
<h3 id="在-Computer-Vision-模式下设置位姿"><a href="#在-Computer-Vision-模式下设置位姿" class="headerlink" title="在 Computer Vision 模式下设置位姿"></a>在 Computer Vision 模式下设置位姿</h3><p>为了在环境中通过 <code>APIs</code> 移动, 可以用过 <code>simSetVehiclePose</code> API. 这个 API 传入位置和姿态参数, 将不可见的载具设置在 <code>front-center</code> 相机所处的位置. 其他的相机保持相对的位置移动. 如果不想改变位置或者姿态, 只需要将位置和姿态设置为 nan 的浮点数. <code>simGetVehiclePose</code> 可以获取当前位姿, 你可以用 <code>simGetGroundTruthKinematics</code> 来获取 quantities kinematics quantities for the movement (不太明白这意思). 还有很多其他无载具特定的 APIs 也是可用, 比如 分割 APIs, 碰撞 APIs, 相机 APIs.</p>
<h2 id="相机-APIs"><a href="#相机-APIs" class="headerlink" title="相机 APIs"></a>相机 APIs</h2><p><code>simGetCameraInfo</code> 返回指定相机的位姿 (世界场景, NED 坐标系, 国际标准单位制) 和 FOV (角度) . 可参考例程 <a target="_blank" rel="noopener" href="https://github.com/Microsoft/AirSim/tree/master/PythonClient//computer_vision/cv_mode.py">example usage</a>.</p>
<p><code>simSetCameraOrientation</code> 设置指定相机在 NED 坐标系下的位姿(四元数). 函数 <code>airsim. to_quaternion()</code> 用来将俯仰, 翻转, 偏航角度转化为四元数, 举个例子, 设置相机 - 0 倾斜角度为 15 度, 可以用 (<strong>PS</strong>: 这个是 Python 版本, C++ 没找到, 可以自己用 Eigen 库实现) :</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client. simSetCameraOrientation(<span class="number">0</span>, airsim. to_quaternion(<span class="number">0.</span> <span class="number">261799</span>, <span class="number">0</span>, <span class="number">0</span>)); <span class="comment">#radians</span></span><br></pre></td></tr></table></figure>

<h3 id="Gimbal"><a href="#Gimbal" class="headerlink" title="Gimbal"></a>Gimbal</h3><p>可以 <a target="_blank" rel="noopener" href="https://microsoft.github.io/AirSim/settings/#gimbal">using settings</a> 将任意相机设置为俯仰, 翻转, 偏航角度.</p>
<p>请参考 <a target="_blank" rel="noopener" href="https://github.com/Microsoft/AirSim/tree/master/PythonClient//computer_vision/cv_mode.py">example usage</a>.</p>
<h2 id="修改分辨率和相机参数"><a href="#修改分辨率和相机参数" class="headerlink" title="修改分辨率和相机参数"></a>修改分辨率和相机参数</h2><p>通过 <a target="_blank" rel="noopener" href="https://microsoft.github.io/AirSim/settings/">settings. json</a> 可以修改分辨率和视场角. 举个例子, 下述 settings. json 的额外部分设置了捕捉场景的参数, 并用前述的 “Computer Version” 模式. 如果你省略了任何设置, 下述默认参数将会被使用. 更多设置参见 <a target="_blank" rel="noopener" href="https://microsoft.github.io/AirSim/settings/">settings doc</a>. 如果你正在使用立体相机, 左右两个相机的固定距离是 25 cm.</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;SettingsVersion&quot;</span><span class="punctuation">:</span> <span class="number">1.</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;CameraDefaults&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;CaptureSettings&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;ImageType&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Width&quot;</span><span class="punctuation">:</span> <span class="number">256</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Height&quot;</span><span class="punctuation">:</span> <span class="number">144</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;FOV_Degrees&quot;</span><span class="punctuation">:</span> <span class="number">90</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;AutoExposureSpeed&quot;</span><span class="punctuation">:</span> <span class="number">100</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;MotionBlurAmount&quot;</span><span class="punctuation">:</span> <span class="number">0</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;SimMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ComputerVision&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="在不同的图像类型像素值表示什么"><a href="#在不同的图像类型像素值表示什么" class="headerlink" title="在不同的图像类型像素值表示什么"></a>在不同的图像类型像素值表示什么</h2><h3 id="可用的图像类型"><a href="#可用的图像类型" class="headerlink" title="可用的图像类型"></a>可用的图像类型</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Scene = <span class="number">0</span>,</span><br><span class="line">DepthPlanner = <span class="number">1</span>,</span><br><span class="line">DepthPerspective = <span class="number">2</span>,</span><br><span class="line">DepthVis = <span class="number">3</span>,</span><br><span class="line">DisparityNormalized = <span class="number">4</span>,</span><br><span class="line">Segmentation = <span class="number">5</span>,</span><br><span class="line">SurfaceNormals = <span class="number">6</span>,</span><br><span class="line">Infrared = <span class="number">7</span></span><br></pre></td></tr></table></figure>

<h3 id="DepthPlanner-and-DepthPerspective"><a href="#DepthPlanner-and-DepthPerspective" class="headerlink" title="DepthPlanner and DepthPerspective"></a>DepthPlanner and DepthPerspective</h3><p>通常你希望在接收到 float 表示的深度图像 ( 即在<code>ImageRequest</code> 将设置 <code>pixels_as_float = true</code>) 然后指定 <code>ImageType = DepthPlanner</code> 或者 <code>ImageType = DepthPerspective</code> . 对于 <code>ImageType = DepthPlanner</code>, 将获得获得深度, 即所有与相机处于相同距离的点具有相同的深度. 对于 <code>ImageType = DepthPerspective</code>, 通过射向像素点的射线来获取深度. 取决与使用的案例, 平行深度或者透视深度可能是所需的真正图像. 举个例子, 你可能对 ROS 包发布透视深度, 例如 <code>depth_image_proc</code> 来生成点云. 或者平行深度可能通过立体视觉算法, 例如 SGM, 用来估计深度图像的生成.</p>
<h3 id="DepthVis"><a href="#DepthVis" class="headerlink" title="DepthVis"></a>DepthVis</h3><p>当在 <code>ImageRequest</code> 指定 <code>ImageType = DepthVis</code>, 将获得一副有助于可视化深度的图像. 在这种请跨下, 每个像素值是米值的根据相机平面从白到黑的插值. 纯白的像素意味着深度超过 100 m, 纯黑意味着深度为 0 m.</p>
<h3 id="DisparityNormalized"><a href="#DisparityNormalized" class="headerlink" title="DisparityNormalized"></a>DisparityNormalized</h3><p>通常你希望在接收到 float 表示的深度图像 ( 即在<code>ImageRequest</code> 设置 <code>pixels_as_float = true</code> <code>ImageType = DisparityNormalized</code> ) . 这种情况下, 每个像素值是 <code>(Xl - Xr)/Xmax</code>, 即被归一化为 0 到 1 之间的值.</p>
<h3 id="Segmentation"><a href="#Segmentation" class="headerlink" title="Segmentation"></a>Segmentation</h3><p>当在 <code>ImageRequest</code> 指定 <code>ImageType = Segmentation</code> , 将获取到真实场景的分割图. 在启动时, AirSim 给环境中每块网格分配 0 到 255 的值. 这些值将映射 <a target="_blank" rel="noopener" href="https://github.com/Microsoft/AirSim/tree/master/Unreal//Plugins/AirSim/Content/HUDAssets/seg_color_pallet.png">the pallet</a> 中指定的颜色. 每个对象的 ID 可以在 <a target="_blank" rel="noopener" href="https://microsoft.github.io/AirSim/seg_rgbs.txt">this file</a> 找到.</p>
<p>你可以通过 APIs 给指定的网格分配指定的值 (范围限制在 0-255) . 举个例子, 下述的 Python (PS: C++ 代码相同) 代码给一个对象 ID 为 ”Ground“ 在 Blocks 环境中的值为 20, 所以改变了该对象在分割视图中的颜色:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">success = client. simSetSegmentationObjectID(<span class="string">&quot;Ground&quot;</span>, <span class="number">20</span>);</span><br></pre></td></tr></table></figure>

<p>返回的布尔值表示是否找到该网格.</p>
<p>主要, 典型的 Unreal 环境中, 像 Blocks, 通常有很多其他有相同对象组成的网格, 举个例子, “Ground_2”, “Ground_3” 等等. 因为对所有网格设置对象 ID 是很冗杂的, AirSim 也支持正则表达式. 举个例子, 以下只用了一行代码设置了名称以 ”ground“ 开头的所有网格为 21 (忽略大小写) :</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">success = client. simSetSegmentationObjectID(<span class="string">&quot;ground[\w]*&quot;</span>, <span class="number">21</span>, <span class="literal">True</span>);</span><br></pre></td></tr></table></figure>

<p>如果至少有一个网格被正则表达式匹配, 则返回 true.</p>
<p>建议通过这个 API 来请求未压缩的分割图像, 确保获取到精确的 RGB 值:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">responses = client. simGetImages([ImageRequest(<span class="number">0</span>, AirSimImageType. Segmentation, <span class="literal">False</span>, <span class="literal">False</span>)])</span><br><span class="line">img1d = np. fromstring(response. image_data_uint8, dtype=np. uint8) <span class="comment">#get numpy array</span></span><br><span class="line">img_rgb = img1d. reshape(response. height, response. width, <span class="number">3</span>) <span class="comment">#reshape array to 3 channel image array H X W X 3</span></span><br><span class="line">img_rgb = np. flipud(img_rgb) <span class="comment">#original image is fliped vertically</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#find unique colors</span></span><br><span class="line"><span class="built_in">print</span>(np. unique(img_rgb[:, :, <span class="number">0</span>], return_counts=<span class="literal">True</span>)) <span class="comment">#red</span></span><br><span class="line"><span class="built_in">print</span>(np. unique(img_rgb[:, :, <span class="number">1</span>], return_counts=<span class="literal">True</span>)) <span class="comment">#green</span></span><br><span class="line"><span class="built_in">print</span>(np. unique(img_rgb[:, :, <span class="number">2</span>], return_counts=<span class="literal">True</span>)) <span class="comment">#blue</span></span><br></pre></td></tr></table></figure>

<p>完整可运行的程序见 <a target="_blank" rel="noopener" href="https://github.com/Microsoft/AirSim/tree/master/PythonClient//computer_vision/segmentation.py">segmentation. py</a>.</p>
<h4 id="Unsetting-object-ID"><a href="#Unsetting-object-ID" class="headerlink" title="Unsetting object ID"></a>Unsetting object ID</h4><p>如果不想在分割图像中显示对象, 可以设置对象 ID 为 -1.</p>
<h4 id="如何找到网格的名字"><a href="#如何找到网格的名字" class="headerlink" title="如何找到网格的名字"></a>如何找到网格的名字</h4><p>为了获取真实的分割图, 你需要知道在 Unreal 环境中的网格名称. 打开 UE 编辑器中的 Unreal 环境, 然后在世界大纲视图 (World Outliner) 中找到感兴趣的网格. 举个例子, 下述图片我们可以在右侧 Blocks 环境面板中看到 ground 的网格名称:</p>
<p><img src="https://microsoft.github.io/AirSim/images/unreal_editor_blocks.png" alt="record screenshot"></p>
<p>如果你不知道如何在 Unreal 编辑器中打开 Unreal 环境, 可以参考下列教程 <a target="_blank" rel="noopener" href="https://microsoft.github.io/AirSim/build_windows/">building from source</a>.</p>
<p>一旦你决定你感兴趣的网格, 几下它们的名称, 然后通过上述的 API 来设置它们的 object IDs. 这里有 <a target="_blank" rel="noopener" href="https://microsoft.github.io/AirSim/settings/#segmentation-settings">few settings</a> 来改变生成 object ID 的行为.</p>
<h4 id="修改-Object-IDs-的颜色"><a href="#修改-Object-IDs-的颜色" class="headerlink" title="修改 Object IDs 的颜色"></a>修改 Object IDs 的颜色</h4><p>目前每个对象 ID 都在 <a target="_blank" rel="noopener" href="https://github.com/Microsoft/AirSim/tree/master/Unreal//Plugins/AirSim/Content/HUDAssets/seg_color_pallet.png">this pallet</a> 被固定. 我们将很快增加改变 object IDs 颜色的功能. 同时, 你将可以在你喜欢的图像编辑器中打开分割图, 然后获取你感兴趣的 RGB 值.</p>
<h4 id="Startup-Object-IDs"><a href="#Startup-Object-IDs" class="headerlink" title="Startup Object IDs"></a>Startup Object IDs</h4><p>开始时, AirSim 给能在环境中的<code>UStaticMeshComponent</code> 或者 <code>ALandscapeProxy</code> 类型的每个对象分配了 object id. 然后使用网格名称或者本身的名称 (取决于设置), 转换为小写, 移除所有小于 ASCII 97 的字符以移除数字和一些标点, 对所有字符求和并除以 255 取模来生成 object id. 换句话说, 所具有相同字符的对象将有相同的 object ID. 这个启发对于很多 Unreal 环境很简单也有有效, 但是可能不是你想要的. 这种情况下, 请用上面的 APIs 来修改 object IDs 为你想要的值. 这里可以设置可能修改这些表现 r.</p>
<h4 id="为网格获取-Object-ID"><a href="#为网格获取-Object-ID" class="headerlink" title="为网格获取 Object ID"></a>为网格获取 Object ID</h4><p><code>simGetSegmentationObjectID</code> API 允许你获取一个指定网格名称的 object ID.</p>
<h3 id="Infrared"><a href="#Infrared" class="headerlink" title="Infrared"></a>Infrared</h3><p>目前, 这只是将 object ID 映射为 0-255 灰度域的映射. 所以很多 object ID 42 的网格均已 (42, 42, 42) 的颜色显示. 请参考 <a target="_blank" rel="noopener" href="https://microsoft.github.io/AirSim/image_apis/#segmentation">segmentation section</a> 获取如何设置 object IDs 更多的细节. 通常, 噪声设置可以被运用在这种图像类型, 以获取细微的更加真实效果. 我们依然在增加其他的 infrared artifacts 方面展开工作, 也欢迎任何的 contributions .</p>
<h2 id="例程代码"><a href="#例程代码" class="headerlink" title="例程代码"></a>例程代码</h2><p>设置载具到任意方位和获取图片的代码可以在 <a target="_blank" rel="noopener" href="https://github.com/Microsoft/AirSim/tree/master/Examples/DataCollection/StereoImageGenerator.hpp">GenerateImageGenerator. hpp</a> 找到. 这个例程生成指定数量的立体图像和地面实况视差图像, 并保存为 <a target="_blank" rel="noopener" href="https://microsoft.github.io/AirSim/pfm/">pfm format</a>.</p>
</div><div id="donate"><link rel="stylesheet" type="text/css" href="/css/donate.css?v=1.0.0"><script type="text/javascript" src="/js/donate.js?v=1.0.0" successtext="复制成功!"></script><a class="pos-f tr3" id="github" href="https://github.com/Kaiyuan/donate-page" target="_blank" title="Github"></a><div id="DonateText">Donate</div><ul class="list pos-f" id="donateBox"><li id="WeChat" qr="/img/wechatpay.jpg"></li></ul><div class="pos-f left-100" id="QRBox"><div id="MainBox"></div></div></div><div class="post-copyright"><script type="text/javascript" src="/js/copyright.js?v=1.0.0" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copyright.css?v=1.0.0"><p><span>本文标题：</span>自动驾驶仿真 - AirSim (5) - 图片 APIs - C++</p><p><span>文章作者：</span>xwnb</p><p><span>发布时间：</span>2020-06-22</p><p><span>最后更新：</span>2022-10-16</p><p><span>原始链接：</span><a href="/posts/3314168402/">https://xwnb.github.io/posts/3314168402/</a><span class="copy-path"><i class="fa fa-clipboard" data-clipboard-text="https://xwnb.github.io/posts/3314168402/"></i></span></p><p><span>版权声明：</span>本博客所有文章除特别声明外，均采用 BY-NC-SA 许可协议。转载请注明出处！并保留本声明。感谢您的阅读和支持！</p></div><br><script type="text/javascript" src="/js/share.js?v=1.0.0" async></script><a class="article-share-link" data-url="https://xwnb.github.io/posts/3314168402/" data-id="cl9bap3qt00d92ro75c0ufm5a" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAK4AAACuCAAAAACKZ2kyAAABwklEQVR42u3aQW7DMAwEQP//0+4D0thL0WKNYnQKDEOa5ECI3BxHvM6PlT+/3u3YsXBxcdvc83J9O+DzsOsn1zskBlxc3Hnut4pR3Topc9f739hwcXFfyb2+puQ4XFzc/8q9Pv51hQwXF7fITS4rSatTbXg29mq4uLgNbj6l3Pd5y3wXFxd3iXsWV972dEYqX0/HxcUd4eYFJb925K1U9VxcXNx5bl6engUlxa7wy+Hi4j7ErQ4xk1FI3rlUg1tcXNzd3H5JqgYq+cXol58AFxd3kNsPWTvNT37BwsXFneQWRhJxuFKNbKNmDBcXd4SbRCM5KL+4LBYyXFzcEW41Os2HnsnopBzT4uLijnDzIUhetqoD08W6i4uLO8LN4421yKQTuB55tcPFxd3AzUORakxSfbPQq+Hi4m7jro1N12LXaruFi4v7t9zOXyWe+to37+Di4m7mnsXVCUjWRi24uLjz3HytjU5a44+lCxYuLu5T3E7xSq5Ka5HqTfODi4s7ws0LTXXMUejDqr0aLi7uy7jVJ53gFhcX9/3ctRh1Ede/4uDi4ja4SYmp/iEj3zNppXBxcSe55VLSfrOKxsXFHeT+AAe6cbCFPBiAAAAAAElFTkSuQmCC">分享</a><div class="tags"><a href="/tags/自动驾驶"><i class="fa fa-tag">自动驾驶</i></a><a href="/tags/AirSim"><i class="fa fa-tag">AirSim</i></a></div><div class="post-nav"><a class="pre" href="/posts/1270863220/">自动驾驶仿真 - AirSim (6) - 设置</a><a class="next" href="/posts/1307933338/">自动驾驶仿真 - AirSim (4) - 核心 APIs - C++</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://xwnb.github.io"/></form></div><div class="widget"><div class="author-info"><a class="info-avatar" href="/about/" title="关于"><img src="/img/avatar.jpg"/></a><p>Stay Angry, Stay Foolish.</p><a class="info-icon" href="https://juejin.cn/user/435824491237181" title="掘金" target="_blank" style="margin-inline:5px"> <i class="fa fa-external-link-square" style="margin-inline:5px"></i></a><a class="info-icon" href="https://github.com/xwnb" title="GitHub" target="_blank" style="margin-inline:5px"> <i class="fa fa-github-square" style="margin-inline:5px"></i></a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/ROS%E5%AD%A6%E4%B9%A0/">ROS学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/SEI-CERT-C/">SEI CERT C++</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Tutorial/">Tutorial</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/">微信小程序开发</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6/">自动驾驶</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Tutorial/" style="font-size: 15px;">Tutorial</a> <a href="/tags/Markdown/" style="font-size: 15px;">Markdown</a> <a href="/tags/wechat-dev/" style="font-size: 15px;">wechat-dev</a> <a href="/tags/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/" style="font-size: 15px;">路径规划</a> <a href="/tags/motion-planning/" style="font-size: 15px;">motion planning</a> <a href="/tags/RRT/" style="font-size: 15px;">RRT</a> <a href="/tags/A/" style="font-size: 15px;">A*</a> <a href="/tags/LPA/" style="font-size: 15px;">LPA*</a> <a href="/tags/RRT-Connect/" style="font-size: 15px;">RRT_Connect</a> <a href="/tags/RRT/" style="font-size: 15px;">RRT*</a> <a href="/tags/%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6/" style="font-size: 15px;">自动驾驶</a> <a href="/tags/AirSim/" style="font-size: 15px;">AirSim</a> <a href="/tags/SEI-CERT-C/" style="font-size: 15px;">SEI CERT C++</a> <a href="/tags/%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/" style="font-size: 15px;">编码规范</a> <a href="/tags/%E7%BF%BB%E8%AF%91/" style="font-size: 15px;">翻译</a> <a href="/tags/CERT-Containers/" style="font-size: 15px;">CERT Containers</a> <a href="/tags/Input-Output/" style="font-size: 15px;">Input Output</a> <a href="/tags/Memory-Management/" style="font-size: 15px;">Memory Management</a> <a href="/tags/Characters-and-Strings/" style="font-size: 15px;">Characters and Strings</a> <a href="/tags/STR/" style="font-size: 15px;">STR</a> <a href="/tags/Integers/" style="font-size: 15px;">Integers</a> <a href="/tags/INT/" style="font-size: 15px;">INT</a> <a href="/tags/Object-Oriented-Programming/" style="font-size: 15px;">Object Oriented Programming</a> <a href="/tags/OOP/" style="font-size: 15px;">OOP</a> <a href="/tags/ROS/" style="font-size: 15px;">ROS</a> <a href="/tags/xacro/" style="font-size: 15px;">xacro</a> <a href="/tags/controller-manager/" style="font-size: 15px;">controller_manager</a> <a href="/tags/gazebo/" style="font-size: 15px;">gazebo</a> <a href="/tags/controller-manager/" style="font-size: 15px;">controller-manager</a> <a href="/tags/ur5/" style="font-size: 15px;">ur5</a> <a href="/tags/roslaunch/" style="font-size: 15px;">roslaunch</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/posts/2113816124/">FIO51-CPP. 关闭不再需要的文件</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/2518610003/">OPP-CPP58. 拷贝操作绝不能改变源对象</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/294055068/">OPP-CPP57. 优先使用特定的成员函数和重载的运算符而不是C标准库函数</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/3554254475/">OOP56-CPP. 尊重替换handler的要求</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/3554254475/">OOP55-CPP. 不要使用成员指针运算符来访问不存在的成员</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/144696281/">OOP54-CPP. 优雅地处理自我拷贝赋值</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/3904355907/">OOP53-CPP. 按照规范顺序编写构造函数的成员初始化</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/4027020077/">OOP52-CPP. 不要删除一个无虚析构的多态对象</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/1084595410/">OOP51-CPP-不要切分派生对象</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/2354633166/">OOP50-CPP 不要在构造函数和析构函数中调用虚函函函数</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2022 <a href="/." rel="nofollow">Sun of Beach.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0"></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><script type="text/javascript" color="0,0,0" opacity="0.5" zIndex="-2" count="200" src="//lib.baomitu.com/canvas-nest.js/latest/canvas-nest.js"></script><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>