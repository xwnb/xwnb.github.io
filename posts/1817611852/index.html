<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="个人站，学习记录、实践教程、资料收集等，哈哈哈。"><title>MEM54-CPP. 为 placement new 提供足够内存容量的正确对齐的指针 | Sun of Beach</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><div class="darkmode-toggle">🌓</div><script>var prefersDarkMode = window.matchMedia('(prefers-color-scheme: dark)');
var toggle = document.querySelector('.darkmode-toggle');
var html = document.querySelector('html');

html.dataset.dark = localStorage.dark || prefersDarkMode.matches;

toggle.addEventListener('click', () => {
localStorage.dark = !(html.dataset.dark == 'true');
html.dataset.dark = localStorage.dark;
});</script><meta name="generator" content="Hexo 6.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">MEM54-CPP. 为 placement new 提供足够内存容量的正确对齐的指针</h1><a id="logo" href="/.">Sun of Beach</a><p class="description">Stay Angry, Stay Foolish</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">MEM54-CPP. 为 placement new 提供足够内存容量的正确对齐的指针</h1><div class="post-meta">2021-11-14<span> | </span><span class="category"><a href="/categories/SEI-CERT-C/">SEI CERT C++</a></span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 1.9k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i><span class="post-count"> 8</span><span class="post-meta-item-text"> 分钟</span></span></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E5%90%88%E8%A7%84%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.</span> <span class="toc-text">不合规代码示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E5%90%88%E8%A7%84%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B-1"><span class="toc-number">2.</span> <span class="toc-text">不合规代码示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%88%E8%A7%84%E6%96%B9%E6%A1%88-alignas"><span class="toc-number">3.</span> <span class="toc-text">合规方案 (alignas)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%88%E8%A7%84%E6%96%B9%E6%A1%88-std-aligned-storage"><span class="toc-number">4.</span> <span class="toc-text">合规方案 (std::aligned_storage)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E5%90%88%E8%A7%84%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B-Failure-to-Account-for-Array-Overhead"><span class="toc-number">5.</span> <span class="toc-text">不合规代码示例 (Failure to Account for Array Overhead)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%88%E8%A7%84%E6%96%B9%E6%A1%88-Clang-x2F-GCC"><span class="toc-number">6.</span> <span class="toc-text">合规方案 (Clang&#x2F;GCC)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A3%8E%E9%99%A9%E9%A2%84%E4%BC%B0"><span class="toc-number">7.</span> <span class="toc-text">风险预估</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Automated-Detection"><span class="toc-number">7.1.</span> <span class="toc-text">Automated Detection</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Related-Vulnerabilities"><span class="toc-number">8.</span> <span class="toc-text">Related Vulnerabilities</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Related-Guidelines"><span class="toc-number">9.</span> <span class="toc-text">Related Guidelines</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Bibliography"><span class="toc-number">10.</span> <span class="toc-text">Bibliography</span></a></li></ol></div></div><div class="post-content"><p>原文链接：</p>
<p><a target="_blank" rel="noopener" href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/MEM54-CPP.+Provide+placement+new+with+properly+aligned+pointers+to+sufficient+storage+capacity">MEM54-CPP. Provide placement new with properly aligned pointers to sufficient storage capacity</a></p>
<span id="more"></span>

<hr>
<p> 当为给定类型调用 <code>new</code> 表达式, <code>operator new</code> 的默认全局 non-placement 形式试图给该类型对象分配足够的内存空间, 如果成功, 返回一个对齐指针–适用于任何有基本对齐要求的对象. 然而, 默认 placement <code>new</code> 操作符简单地将已知的指针返回给调用者–不保证有足够的内存空间去构造对象或者确保该指针满足正确的对齐要求. C++ 标准, [expr.new], 段落 16 [<a target="_blank" rel="noopener" href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-ISO/IEC14882-2014">ISO&#x2F;IEC 14882-2014</a>], 非规范陈述如下:</p>
<blockquote>
<p>[备注: 当分配函数返回了一个非空值, 这必须是一个指向已经被预留的存储区块的指针. 这个存储区块假设被正确对齐且具有所申请的尺寸大小. 如果对象是数组, 所创建的对象地址不必和该存储区块的地址相同. —备注结束]</p>
<p>[Note: when the allocation function returns a value other than null, it must be a pointer to a block of storage in which space for the object has been reserved. The block of storage is assumed to be appropriately aligned and of the requested size. The address of the created object will not necessarily be the same as that of the block if the object is an array. —end note]</p>
</blockquote>
<p>(这个备注是 C++ 标准所规定的常规要求的提醒, [basic.stc.dynamic.allocation], 段落 1, 借助 [basic.stc.dynamic], 段落 3, 作用于 placement <code>new</code> 操作符)</p>
<p>此外, 标准在这章节后面提供了一个例子:</p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span>(<span class="number">2</span>, f) T[<span class="number">5</span>] `results in a call` of <span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="built_in">sizeof</span>(T) * <span class="number">5</span> + y, <span class="number">2</span>, f).</span><br></pre></td></tr></table></figure>

<p>这里,  <code>...</code> 和  <code>y</code> 是未指明的非负值, 表示数组分配的开销; new 表达式的结果将会补偿  <code>operator new[]</code> 返回值的大小. 这个开销可能被作用于所有的 <em>new 表达式</em>, 包括那些引用于库函数  <code>operator new[](std::size_t, void*)</code> 和其他 placement 分配函数. 这个开销大小可能因每次 new 调用的不同而不同.</p>
<p>Here, <code>...</code> and <code>y</code> are non-negative unspecified values representing array allocation overhead; the result of the new-expression will be offset by this amount from the value returned by <code>operator new[]</code>. This overhead may be applied in all array <em>new-expressions</em>, including those referencing the library function <code>operator new[](std::size_t, void*)</code> and other placement allocation functions. The amount of overhead may vary from one invocation of new to another.</p>
</blockquote>
<p>不要向 placement <code>new</code> 传递一个用于构造对象的未正确对齐的指针. 这会导致对象被构造在一个错误对齐的位置, 导致 <a target="_blank" rel="noopener" href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-undefinedbehavior">未定义行为, undefined behavior</a>. 不要传递一个没有足够存储容量来构造对象的指针, 包括数组需补偿的大小. 这可能导致用于构造该对象的内存初始化时越界.</p>
<p>最后, 不要在任何没有指明所需开销限度的平台上使用 placement <code>new[]</code> .</p>
<h2 id="不合规代码示例"><a href="#不合规代码示例" class="headerlink" title="不合规代码示例"></a>不合规代码示例</h2><p>在这个不合规的代码示例中, 一个指向 <code>short</code> 的指针被传入到 placement <code>new</code>, 试图用来初始化一个 <code>long</code> . 在 <code>sizeof(short) &lt; sizeof(long)</code> 的架构上, 这导致 <a target="_blank" rel="noopener" href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-undefinedbehavior">未定义行为, undefined behavior</a>. 这个以及后面的例子, 都假设 placement <code>new</code> 返回的指针不会在其生命周期结束后被使用. 举个例子, 该指针不会被存储在一个 <code>静态</code> 全局变量中, 且在 <code>f()</code> 调用结束后不会被解引用. 这个假设符合 <a target="_blank" rel="noopener" href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/MEM50-CPP.+Do+not+access+freed+memory">MEM50-CPP. Do not access freed memory</a>.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;new&gt;</span></span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">short</span> s;</span><br><span class="line">  <span class="type">long</span> *lp = ::<span class="built_in">new</span> (&amp;s) <span class="type">long</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="不合规代码示例-1"><a href="#不合规代码示例-1" class="headerlink" title="不合规代码示例"></a>不合规代码示例</h2><p>这个不合规的代码示例确保 在足够大小的缓冲区中构造 <code>long</code> . 然而, 这不能保证传入到 placement <code>new</code> 的指针满足对齐要求. 为了使这个例子更加清晰, 声明了另一个局部变量 <code>c</code>.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;new&gt;</span></span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">char</span> c; <span class="comment">// Used elsewhere in the function</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> buffer[<span class="built_in">sizeof</span>(<span class="type">long</span>)];</span><br><span class="line">  <span class="type">long</span> *lp = ::<span class="built_in">new</span> (buffer) <span class="type">long</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="合规方案-alignas"><a href="#合规方案-alignas" class="headerlink" title="合规方案 (alignas)"></a>合规方案 (<code>alignas</code>)</h2><p>在这个合规方案中, 声明修饰符 <code>alignas</code> 被用来确保用于 <code>long</code> 的缓冲区是正确对齐的.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;new&gt;</span></span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">char</span> c; <span class="comment">// Used elsewhere in the function</span></span><br><span class="line">  <span class="built_in">alignas</span>(<span class="type">long</span>) <span class="type">unsigned</span> <span class="type">char</span> buffer[<span class="built_in">sizeof</span>(<span class="type">long</span>)];</span><br><span class="line">  <span class="type">long</span> *lp = ::<span class="built_in">new</span> (buffer) <span class="type">long</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="合规方案-std-aligned-storage"><a href="#合规方案-std-aligned-storage" class="headerlink" title="合规方案 (std::aligned_storage)"></a>合规方案 (<code>std::aligned_storage</code>)</h2><p>这个合规方案确保在足够大小且正确对齐的缓冲区中构造 <code>long</code> .</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;new&gt;</span></span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">char</span> c; <span class="comment">// Used elsewhere in the function</span></span><br><span class="line">  std::aligned_storage&lt;<span class="built_in">sizeof</span>(<span class="type">long</span>), <span class="built_in">alignof</span>(<span class="type">long</span>)&gt;::type buffer;</span><br><span class="line">  <span class="type">long</span> *lp = ::<span class="built_in">new</span> (&amp;buffer) <span class="type">long</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="不合规代码示例-Failure-to-Account-for-Array-Overhead"><a href="#不合规代码示例-Failure-to-Account-for-Array-Overhead" class="headerlink" title="不合规代码示例 (Failure to Account for Array Overhead)"></a>不合规代码示例 (Failure to Account for Array Overhead)</h2><p>这个不合规代码示例试图为对象 <code>S</code> 的数组分配正确对齐且充足的内存空间. 然而, 这错误计算了开销–实现可能会为数组对象增加存储大小. 这类开销 (一般称为 cookie ) 是必需的–存储数组中元素的数目, 以便于数组删除表达式或者异常解构机制 (注: exception unwinding mechanism) 可以调用数组中每个被成功构造元素的析构函数. 但是有些实现在某些情况下能够避免给 cookie 分配空间, 假设它们在所有情况下的操作是不安全的.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;new&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span> &#123;</span><br><span class="line">  <span class="built_in">S</span> ();</span><br><span class="line">  ~<span class="built_in">S</span> ();</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">unsigned</span> N = <span class="number">32</span>;</span><br><span class="line">  <span class="built_in">alignas</span>(S) <span class="type">unsigned</span> <span class="type">char</span> buffer[<span class="built_in">sizeof</span>(S) * N];</span><br><span class="line">  S *sp = ::<span class="built_in">new</span> (buffer) S[N];</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// Destroy elements of the array.</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i != n; ++i) &#123;</span><br><span class="line">    sp[i].~<span class="built_in">S</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="合规方案-Clang-x2F-GCC"><a href="#合规方案-Clang-x2F-GCC" class="headerlink" title="合规方案 (Clang&#x2F;GCC)"></a>合规方案 (Clang&#x2F;GCC)</h2><p>数组 <code>new</code> 表达式所需的开销大小是不明确的, 但是理想情况下, 这应该被良好的实现记录下来. 下述的合规方案是特地为  <a target="_blank" rel="noopener" href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-clang">Clang </a> 和 GNU <a target="_blank" rel="noopener" href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-gcc">GCC </a>编译器的, 这保证了动态数组分配的开销是单个类型 <code>size_t</code> 的值. (注意这个值一般会被当做数组的 “第-1个” 元素, 所以实际被使用的空间可能会更大.) 为了证实这个假设实际上是安全的, 该合规方案也重载了 placement <code>new[]</code> 操作符来接受缓冲区大小–作为第三个参数, 并且证实这不比所需的存储空间总大小小.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstddef&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;new&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__clang__) || defined(__GNUG__)</span></span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> overhead = <span class="built_in">sizeof</span>(<span class="type">size_t</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="built_in">static_assert</span>(<span class="literal">false</span>, <span class="string">&quot;you need to determine the size of your implementation&#x27;s array overhead&quot;</span>);</span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> overhead = <span class="number">0</span>; <span class="comment">// Declaration prevents additional diagnostics about overhead being undefined; the value used does not matter.</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span> &#123;</span><br><span class="line">  <span class="built_in">S</span>();</span><br><span class="line">  ~<span class="built_in">S</span>();</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> *<span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="type">size_t</span> n, <span class="type">void</span> *p, <span class="type">size_t</span> bufsize) &#123;</span><br><span class="line">  <span class="keyword">if</span> (n &gt; bufsize) &#123;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">bad_array_new_length</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> n = <span class="number">32</span>;</span><br><span class="line">  <span class="built_in">alignas</span>(S) <span class="type">unsigned</span> <span class="type">char</span> buffer[<span class="built_in">sizeof</span>(S) * n + std::<span class="built_in">max</span>(overhead, <span class="built_in">alignof</span>(S))];</span><br><span class="line">  S *sp = ::<span class="built_in">new</span> (buffer, <span class="built_in">sizeof</span>(buffer)) S[n];</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// Destroy elements of the array.</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i != n; ++i) &#123;</span><br><span class="line">    sp[i].~<span class="built_in">S</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将该合规方案移植到其他实现需要增加类似开销常数的条件定义–依赖于平台的约束.</p>
<h2 id="风险预估"><a href="#风险预估" class="headerlink" title="风险预估"></a>风险预估</h2><p>向 placement <code>new</code> 表达式传递不正确对齐的指针或者指向不充足存储空间的指针会导致 <a target="_blank" rel="noopener" href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-undefinedbehavior">未定义行为, undefined behavior</a>, 包括缓冲区溢出和 <a target="_blank" rel="noopener" href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-abnormaltermination">异常终止, abnormal termination</a>.</p>
<table>
<thead>
<tr>
<th align="left">Rule</th>
<th align="left">Severity</th>
<th align="left">Likelihood</th>
<th align="left">Remediation Cost</th>
<th align="left">Priority</th>
<th align="left">Level</th>
</tr>
</thead>
<tbody><tr>
<td align="left">MEM54-CPP</td>
<td align="left">High</td>
<td align="left">Likely</td>
<td align="left">Medium</td>
<td align="left"><strong>P18</strong></td>
<td align="left"><strong>L1</strong></td>
</tr>
</tbody></table>
<h3 id="Automated-Detection"><a href="#Automated-Detection" class="headerlink" title="Automated Detection"></a>Automated Detection</h3><table>
<thead>
<tr>
<th align="left">Tool</th>
<th align="left">Version</th>
<th align="left">Checker</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a target="_blank" rel="noopener" href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/Axivion+Bauhaus+Suite">Axivion Bauhaus Suite</a></td>
<td align="left"><img src="https://wiki.sei.cmu.edu/confluence/plugins/servlet/confluence/placeholder/macro?definition=e2luY2x1ZGU6QXhpdmlvbiBCYXVoYXVzIFN1aXRlX1Z9&locale=zh_CN&version=2" alt="img"></td>
<td align="left"><strong>CertC++-MEM54</strong></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/Helix+QAC">Helix QAC</a></td>
<td align="left"><img src="https://wiki.sei.cmu.edu/confluence/plugins/servlet/confluence/placeholder/macro?definition=e2luY2x1ZGU6SGVsaXggUUFDX1Z9&locale=zh_CN&version=2" alt="img"></td>
<td align="left"><strong>C++3119, C++3128</strong></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/LDRA">LDRA tool suite</a></td>
<td align="left"><img src="https://wiki.sei.cmu.edu/confluence/plugins/servlet/confluence/placeholder/macro?definition=e2luY2x1ZGU6TERSQV9WfQ&locale=zh_CN&version=2" alt="img"></td>
<td align="left"><strong>597 S</strong>** **</td>
<td align="left">Enhanced Enforcement</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/Parasoft">Parasoft C&#x2F;C++test</a></td>
<td align="left"><img src="https://wiki.sei.cmu.edu/confluence/plugins/servlet/confluence/placeholder/macro?definition=e2luY2x1ZGU6UGFyYXNvZnRfVn0&locale=zh_CN&version=2" alt="img"></td>
<td align="left"><strong>CERT_CPP-MEM54-a</strong> <strong>CERT_CPP-MEM54-b</strong></td>
<td align="left">Do not pass a pointer that has insufficient storage capacity or that is not suitably aligned for the object being constructed to placement ‘new’ An overhead should be used when an array of objects is passed to the placement ‘new’ allocation function</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/Polyspace+Bug+Finder">Polyspace Bug Finder</a></td>
<td align="left"><img src="https://wiki.sei.cmu.edu/confluence/plugins/servlet/confluence/placeholder/macro?definition=e2luY2x1ZGU6UG9seXNwYWNlIEJ1ZyBGaW5kZXJfVn0&locale=zh_CN&version=2" alt="img"></td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.mathworks.com/help/bugfinder/ref/certcmem54cpp.html">CERT C++: MEM54-CPP</a></td>
<td align="left">Checks for placement new used with insufficient storage or misaligned pointers (rule fully covered)</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/PVS-Studio">PVS-Studio</a></td>
<td align="left"><img src="https://wiki.sei.cmu.edu/confluence/plugins/servlet/confluence/placeholder/macro?definition=e2luY2x1ZGU6UFZTLVN0dWRpb19WfQ&locale=zh_CN&version=2" alt="img"></td>
<td align="left"><strong><a target="_blank" rel="noopener" href="https://pvs-studio.com/en/docs/warnings/v752/">V752</a></strong></td>
<td align="left"></td>
</tr>
</tbody></table>
<h2 id="Related-Vulnerabilities"><a href="#Related-Vulnerabilities" class="headerlink" title="Related Vulnerabilities"></a>Related Vulnerabilities</h2><p>Search for <a target="_blank" rel="noopener" href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-vulner">vulnerabilities</a> resulting from the violation of this rule on the <a target="_blank" rel="noopener" href="https://www.kb.cert.org/vulnotes/bymetric?searchview&query=FIELD+KEYWORDS+contains+MEM45-CPP">CERT website</a>.</p>
<h2 id="Related-Guidelines"><a href="#Related-Guidelines" class="headerlink" title="Related Guidelines"></a>Related Guidelines</h2><table>
<thead>
<tr>
<th><a target="_blank" rel="noopener" href="https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=88046682">SEI CERT C++ Coding Standard</a></th>
<th><a target="_blank" rel="noopener" href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/MEM50-CPP.+Do+not+access+freed+memory">MEM50-CPP. Do not access freed memory</a></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="Bibliography"><a href="#Bibliography" class="headerlink" title="Bibliography"></a>Bibliography</h2><table>
<thead>
<tr>
<th>[<a target="_blank" rel="noopener" href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-ISO/IEC14882-2014">ISO&#x2F;IEC 14882-2014</a>]</th>
<th>Subclause 3.7.4, “Dynamic Storage Duration” Subclause 5.3.4, “New”</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<hr>
<p><a target="_blank" rel="noopener" href="https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=88046356"><img src="https://wiki.sei.cmu.edu/confluence/download/attachments/88046682/button_arrow_left.png?version=1&modificationDate=1216910800000&api=v2" alt="SEI CERT C++ Coding Standard &gt; SEI CERT C++ Coding Standard &gt; button_arrow_left.png"> </a><a target="_blank" rel="noopener" href="https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=88046329"><img src="https://wiki.sei.cmu.edu/confluence/download/attachments/88046682/button_arrow_up.png?version=1&modificationDate=1216910618000&api=v2" alt="SEI CERT C++ Coding Standard &gt; SEI CERT C++ Coding Standard &gt; button_arrow_up.png"> </a><a target="_blank" rel="noopener" href="https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=88046441"><img src="https://wiki.sei.cmu.edu/confluence/download/attachments/88046682/button_arrow_right.png?version=1&modificationDate=1216910815000&api=v2" alt="SEI CERT C++ Coding Standard &gt; SEI CERT C++ Coding Standard &gt; button_arrow_right.png"></a></p>
</div><div id="donate"><link rel="stylesheet" type="text/css" href="/css/donate.css?v=1.0.0"><script type="text/javascript" src="/js/donate.js?v=1.0.0" successtext="复制成功!"></script><a class="pos-f tr3" id="github" href="https://github.com/Kaiyuan/donate-page" target="_blank" title="Github"></a><div id="DonateText">Donate</div><ul class="list pos-f" id="donateBox"><li id="WeChat" qr="/img/wechatpay.jpg"></li></ul><div class="pos-f left-100" id="QRBox"><div id="MainBox"></div></div></div><div class="post-copyright"><script type="text/javascript" src="/js/copyright.js?v=1.0.0" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copyright.css?v=1.0.0"><p><span>本文标题：</span>MEM54-CPP. 为 placement new 提供足够内存容量的正确对齐的指针</p><p><span>文章作者：</span>xwnb</p><p><span>发布时间：</span>2021-11-14</p><p><span>最后更新：</span>2022-10-16</p><p><span>原始链接：</span><a href="/posts/1817611852/">https://xwnb.github.io/posts/1817611852/</a><span class="copy-path"><i class="fa fa-clipboard" data-clipboard-text="https://xwnb.github.io/posts/1817611852/"></i></span></p><p><span>版权声明：</span>本博客所有文章除特别声明外，均采用 BY-NC-SA 许可协议。转载请注明出处！并保留本声明。感谢您的阅读和支持！</p></div><br><script type="text/javascript" src="/js/share.js?v=1.0.0" async></script><a class="article-share-link" data-url="https://xwnb.github.io/posts/1817611852/" data-id="cl9bcf9p1002u1ip9bxbt84er" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAK4AAACuCAAAAACKZ2kyAAABwklEQVR42u3aQY4CMQwEQP7/afbKgZlt20kAqXJCLMrU7MGK23k84vV8Wa/f5L/P/7pg4eLijrnP23X/mwkx2f/Nbri4uAe5Vw+4/3z1sPvvkz0vv8fFxf1ibv4y1R1wcXF/kdsrYR8rZLi4uANu0vzcl6HJUWlLr4aLizvg5inlvs9b8l1cXNwW91lcybEmCUl7CxcX9ww3LyjVl6nGIoVhLS4u7hFuHnBUj0H5ISYfwODi4u7mTsao1Ri0d73jzYkMFxd3M3dVozIvheVBCy4u7mZuvl2CqDY/SVnExcX9LLc6Xq0GKEkQ05wJ4+LiLuJGhSN+wKo56aUHFxf3CDcPTHsxR+94FBU+XFzcbdy8fFSvVkxuVf1Td3FxcTdz1w5Kq5FH9XooLi7uSW51HNJ7/LJYFhcX9zi3ehzptT15C3Q5ZMXFxT3CnR9BqkWqGb/i4uJu5q4tVZPII/pn4eLiHuFOwo7qgaaX1jRfBhcXd8ytFq9eG1MdqUbNDy4u7mZutcnpxanLejVcXNwv5lavTVTLJS4u7q9w1w5QqxEtLi7uSW5SYuYXL/I9F/RquLi4A265lCyadFSjE1xc3CPcPxxCSOejnV2dAAAAAElFTkSuQmCC">分享</a><div class="tags"><a href="/tags/SEI CERT C++"><i class="fa fa-tag">SEI CERT C++</i></a><a href="/tags/编码规范"><i class="fa fa-tag">编码规范</i></a><a href="/tags/翻译"><i class="fa fa-tag">翻译</i></a><a href="/tags/Memory Management"><i class="fa fa-tag">Memory Management</i></a></div><div class="post-nav"><a class="pre" href="/posts/3526747646/">MEM55-CPP. 遵守替换动态内存管理的要求</a><a class="next" href="/posts/4036605331/">MEM53-CPP. 当手动管理对象生命周期时, 显式构造和析构对象</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://xwnb.github.io"/></form></div><div class="widget"><div class="author-info"><a class="info-avatar" href="/about/" title="关于"><img src="/img/avatar.jpg"/></a><p>Stay Angry, Stay Foolish.</p><a class="info-icon" href="https://juejin.cn/user/435824491237181" title="掘金" target="_blank" style="margin-inline:5px"> <i class="fa fa-external-link-square" style="margin-inline:5px"></i></a><a class="info-icon" href="https://github.com/xwnb" title="GitHub" target="_blank" style="margin-inline:5px"> <i class="fa fa-github-square" style="margin-inline:5px"></i></a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/ROS%E5%AD%A6%E4%B9%A0/">ROS学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/SEI-CERT-C/">SEI CERT C++</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Tutorial/">Tutorial</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/">微信小程序开发</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6/">自动驾驶</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6/" style="font-size: 15px;">自动驾驶</a> <a href="/tags/AirSim/" style="font-size: 15px;">AirSim</a> <a href="/tags/Tutorial/" style="font-size: 15px;">Tutorial</a> <a href="/tags/Markdown/" style="font-size: 15px;">Markdown</a> <a href="/tags/wechat-dev/" style="font-size: 15px;">wechat-dev</a> <a href="/tags/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/" style="font-size: 15px;">路径规划</a> <a href="/tags/motion-planning/" style="font-size: 15px;">motion planning</a> <a href="/tags/A/" style="font-size: 15px;">A*</a> <a href="/tags/LPA/" style="font-size: 15px;">LPA*</a> <a href="/tags/RRT-Connect/" style="font-size: 15px;">RRT_Connect</a> <a href="/tags/RRT/" style="font-size: 15px;">RRT*</a> <a href="/tags/RRT/" style="font-size: 15px;">RRT</a> <a href="/tags/ROS/" style="font-size: 15px;">ROS</a> <a href="/tags/controller-manager/" style="font-size: 15px;">controller_manager</a> <a href="/tags/gazebo/" style="font-size: 15px;">gazebo</a> <a href="/tags/controller-manager/" style="font-size: 15px;">controller-manager</a> <a href="/tags/ur5/" style="font-size: 15px;">ur5</a> <a href="/tags/xacro/" style="font-size: 15px;">xacro</a> <a href="/tags/SEI-CERT-C/" style="font-size: 15px;">SEI CERT C++</a> <a href="/tags/%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/" style="font-size: 15px;">编码规范</a> <a href="/tags/%E7%BF%BB%E8%AF%91/" style="font-size: 15px;">翻译</a> <a href="/tags/CERT-Containers/" style="font-size: 15px;">CERT Containers</a> <a href="/tags/Input-Output/" style="font-size: 15px;">Input Output</a> <a href="/tags/Integers/" style="font-size: 15px;">Integers</a> <a href="/tags/INT/" style="font-size: 15px;">INT</a> <a href="/tags/Memory-Management/" style="font-size: 15px;">Memory Management</a> <a href="/tags/Object-Oriented-Programming/" style="font-size: 15px;">Object Oriented Programming</a> <a href="/tags/OOP/" style="font-size: 15px;">OOP</a> <a href="/tags/Characters-and-Strings/" style="font-size: 15px;">Characters and Strings</a> <a href="/tags/STR/" style="font-size: 15px;">STR</a> <a href="/tags/roslaunch/" style="font-size: 15px;">roslaunch</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/posts/2113816124/">FIO51-CPP. 关闭不再需要的文件</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/2518610003/">OPP-CPP58. 拷贝操作绝不能改变源对象</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/294055068/">OPP-CPP57. 优先使用特定的成员函数和重载的运算符而不是C标准库函数</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/3554254475/">OOP56-CPP. 尊重替换handler的要求</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/3554254475/">OOP55-CPP. 不要使用成员指针运算符来访问不存在的成员</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/144696281/">OOP54-CPP. 优雅地处理自我拷贝赋值</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/3904355907/">OOP53-CPP. 按照规范顺序编写构造函数的成员初始化</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/4027020077/">OOP52-CPP. 不要删除一个无虚析构的多态对象</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/1084595410/">OOP51-CPP-不要切分派生对象</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/2354633166/">OOP50-CPP 不要在构造函数和析构函数中调用虚函函函数</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2022 <a href="/." rel="nofollow">Sun of Beach.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0"></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><script type="text/javascript" color="0,0,0" opacity="0.5" zIndex="-2" count="200" src="//lib.baomitu.com/canvas-nest.js/latest/canvas-nest.js"></script><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>