<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="个人站，学习记录、实践教程、资料收集等，哈哈哈。"><title>CTR52-CPP. 确保库函数不要溢出 | Sun of Beach</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><div class="darkmode-toggle">🌓</div><script>var prefersDarkMode = window.matchMedia('(prefers-color-scheme: dark)');
var toggle = document.querySelector('.darkmode-toggle');
var html = document.querySelector('html');

html.dataset.dark = localStorage.dark || prefersDarkMode.matches;

toggle.addEventListener('click', () => {
localStorage.dark = !(html.dataset.dark == 'true');
html.dataset.dark = localStorage.dark;
});</script><meta name="generator" content="Hexo 6.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">CTR52-CPP. 确保库函数不要溢出</h1><a id="logo" href="/.">Sun of Beach</a><p class="description">Stay Angry, Stay Foolish</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">CTR52-CPP. 确保库函数不要溢出</h1><div class="post-meta">2020-06-25<span> | </span><span class="category"><a href="/categories/SEI-CERT-C/">SEI CERT C++</a></span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 1.8k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i><span class="post-count"> 8</span><span class="post-meta-item-text"> 分钟</span></span></span></div><div class="post-content"><p>原文链接：</p>
<p><a target="_blank" rel="noopener" href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/CTR52-CPP.+Guarantee+that+library+functions+do+not+overflow">CTR52-CPP. Guarantee that library functions do not overflow</a></p>
<p><a target="_blank" rel="noopener" href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/CTR52-CPP.+Guarantee+that+library+functions+do+not+overflow">https://wiki.sei.cmu.edu/confluence/display/cplusplus/CTR52-CPP.+Guarantee+that+library+functions+do+not+overflow</a></p>
<span id="more"></span>

<p>拷贝数据到一个不够容纳这些数据的容器中导致缓冲区溢出。为了避免这类错误，被拷贝到目标容器的数据必须严格限制在目标容器的尺寸下，或者更完美的，目标容器必须确保足够大来容纳将被拷贝的数据。</p>
<p>Copying data into a container that is not large enough to hold that data results in a buffer overflow. To prevent such errors, data copied to the destination container must be restricted on the basis of the destination container’s size, or preferably, the destination container must be guaranteed to be large enough to hold the data to be copied.</p>
<p>由拷贝数据到尺寸不足的缓冲区导致的 <a target="_blank" rel="noopener" href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-vulnerability">漏洞</a> 也会涉及 null 结尾的字符串。参阅 <a target="_blank" rel="noopener" href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/STR50-CPP.+Guarantee+that+storage+for+strings+has+sufficient+space+for+character+data+and+the+null+terminator">STR50-CPP. Guarantee that storage for strings has sufficient space for character data and the null terminator</a> 获取涉及字符串的例子。</p>
<p><a target="_blank" rel="noopener" href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-vulnerability">Vulnerabilities</a> that result from copying data to an undersized buffer can also involve null-terminated strings. Consult <a target="_blank" rel="noopener" href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/STR50-CPP.+Guarantee+that+storage+for+strings+has+sufficient+space+for+character+data+and+the+null+terminator">STR50-CPP. Guarantee that storage for strings has sufficient space for character data and the null terminator</a> for specific examples of this rule that involve strings.</p>
<p>拷贝可以使用 <code>std::memcpy()</code> 函数。然而， <code>std::memmove()</code> 和 <code>std::memset()</code> 函数也会导致相同的漏洞，因为在覆写一块内存时没有检查该块是否有效。这类问题不止现定于 C 标准库函数；标准模板库 (STL) 泛型算法，例如 <code>std::copy()</code>，<code>std::fill()</code>，和 <code>std::transform()</code> 也假定有效的输出缓冲区尺寸 [<a target="_blank" rel="noopener" href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-ISO/IEC14882-2014">ISO&#x2F;IEC 14882-2014</a>].。</p>
<p>Copies can be made with the <code>std::memcpy()</code> function. However, the <code>std::memmove()</code> and <code>std::memset()</code> functions can also have the same vulnerabilities because they overwrite a block of memory without checking that the block is valid. Such issues are not limited to C standard library functions; standard template library (STL) generic algorithms, such as <code>std::copy()</code>, <code>std::fill()</code>, and <code>std::transform()</code>, also assume valid output buffer sizes [<a target="_blank" rel="noopener" href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-ISO/IEC14882-2014">ISO&#x2F;IEC 14882-2014</a>].</p>
<h2 id="不合规代码示例-Noncompliant-Code-Example"><a href="#不合规代码示例-Noncompliant-Code-Example" class="headerlink" title="不合规代码示例 Noncompliant Code Example"></a>不合规代码示例 Noncompliant Code Example</h2><p>STL 容器也会遭受与数组数据类型相同的漏洞。<code>std::copy()</code> 算法没有提供内部边界检查，会导致缓冲区溢出。在这个不合规的示例代码中，使用 <code>std::copy()</code>，把一个整型的 vector 从 <code>src</code> 拷贝到 <code>dest</code> 中。因为 <code>std::copy()</code> 不会展开 <code>dest</code> vector，程序在拷贝第一个元素时将溢出缓冲区。</p>
<p>STL containers can be subject to the same vulnerabilities as array data types. The <code>std::copy()</code> algorithm provides no inherent bounds checking and can lead to a buffer overflow. In this noncompliant code example, a vector of integers is copied from <code>src</code> to <code>dest</code> using <code>std::copy()</code>. Because <code>std::copy()</code> does nothing to expand the <code>dest</code> vector, the program will overflow the buffer on copying the first element.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt; &amp;src)</span> </span>&#123;</span><br><span class="line">  std::vector&lt;<span class="type">int</span>&gt; dest;</span><br><span class="line">  std::<span class="built_in">copy</span>(src.<span class="built_in">begin</span>(), src.<span class="built_in">end</span>(), dest.<span class="built_in">begin</span>());</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个风险在适用任何期望将值填入目标迭代器的算法。大多数 STL 算法期望目标容器有足够的空间来容纳提供的值。</p>
<p>This hazard applies to any algorithm that takes a destination iterator, expecting to fill it with values. Most of the STL algorithms expect the destination container to have sufficient space to hold the values provided.</p>
<h2 id="合规方案-Sufficient-Initial-Capacity-Compliant-Solution-Sufficient-Initial-Capacity"><a href="#合规方案-Sufficient-Initial-Capacity-Compliant-Solution-Sufficient-Initial-Capacity" class="headerlink" title="合规方案 (Sufficient Initial Capacity) Compliant Solution (Sufficient Initial Capacity)"></a>合规方案 (Sufficient Initial Capacity) Compliant Solution (Sufficient Initial Capacity)</h2><p>使用 <code>std::copy()</code> 恰当的方式是确保目标容器可以容纳所有正被拷贝进去的元素。这个合规方案扩容 vector 容量优先拷贝操作。</p>
<p>The proper way to use <code>std::copy()</code> is to ensure the destination container can hold all the elements being copied to it. This compliant solution enlarges the capacity of the vector prior to the copy operation.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt; &amp;src)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Initialize dest with src.size() default-inserted elements</span></span><br><span class="line">  <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">dest</span><span class="params">(src.size())</span></span>;</span><br><span class="line">  std::<span class="built_in">copy</span>(src.<span class="built_in">begin</span>(), src.<span class="built_in">end</span>(), dest.<span class="built_in">begin</span>());</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="合规方案-Per-Element-Growth-Compliant-Solution-Per-Element-Growth"><a href="#合规方案-Per-Element-Growth-Compliant-Solution-Per-Element-Growth" class="headerlink" title="合规方案 (Per-Element Growth) Compliant Solution (Per-Element Growth)"></a>合规方案 (Per-Element Growth) Compliant Solution (Per-Element Growth)</h2><p>可选的方法是提供一个 <code>std::back_insert_iterator</code> 作为目标容器的实参。这个迭代器会对每个算法提供的元素扩展目标容器，这保证了目标容器将变得足够大来容纳被提供的元素。</p>
<p>An alternative approach is to supply a <code>std::back_insert_iterator</code> as the destination argument. This iterator expands the destination container by one element for each element supplied by the algorithm, which guarantees the destination container will become sufficiently large to hold the elements provided.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt; &amp;src)</span> </span>&#123;</span><br><span class="line">  std::vector&lt;<span class="type">int</span>&gt; dest;</span><br><span class="line">  std::<span class="built_in">copy</span>(src.<span class="built_in">begin</span>(), src.<span class="built_in">end</span>(), std::<span class="built_in">back_inserter</span>(dest));</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="合规的方案-Assignment-Compliant-Solution-Assignment"><a href="#合规的方案-Assignment-Compliant-Solution-Assignment" class="headerlink" title="合规的方案 (Assignment) Compliant Solution (Assignment)"></a>合规的方案 (Assignment) Compliant Solution (Assignment)</h2><p>最简单的方法就是直接用 <code>src</code> 来构造 <code>dest</code>，像这个合规方案里展示的。</p>
<p>The simplest solution is to construct <code>dest</code> from <code>src</code> directly, as in this compliant solution.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt; &amp;src)</span> </span>&#123;</span><br><span class="line">  <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">dest</span><span class="params">(src)</span></span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="不合规代码示例-Noncompliant-Code-Example-1"><a href="#不合规代码示例-Noncompliant-Code-Example-1" class="headerlink" title="不合规代码示例 Noncompliant Code Example"></a>不合规代码示例 Noncompliant Code Example</h2><p>在这个不合规的代码示例中, <code>std::fill_n()</code> 被用来填充 10 个值为 <code>0x42</code> 到缓冲区中。然而，缓冲区没有为这些数据分配任何空间，所以该操作导致缓冲区溢出。</p>
<p>In this noncompliant code example, <code>std::fill_n()</code> is used to fill a buffer with 10 instances of the value <code>0x42</code>. However, the buffer has not allocated any space for the elements, so this operation results in a buffer overflow.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">  std::<span class="built_in">fill_n</span>(v.<span class="built_in">begin</span>(), <span class="number">10</span>, <span class="number">0x42</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="合规的方案-Sufficient-Initial-Capacity-Compliant-Solution-Sufficient-Initial-Capacity"><a href="#合规的方案-Sufficient-Initial-Capacity-Compliant-Solution-Sufficient-Initial-Capacity" class="headerlink" title="合规的方案 (Sufficient Initial Capacity) Compliant Solution (Sufficient Initial Capacity)"></a>合规的方案 (Sufficient Initial Capacity) Compliant Solution (Sufficient Initial Capacity)</h2><p>这个合规的方案保证在试图填充容器之前容器的容量是足够的。</p>
<p>This compliant solution ensures the capacity of the vector is sufficient before attempting to fill the container.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">  std::<span class="built_in">fill_n</span>(v.<span class="built_in">begin</span>(), <span class="number">10</span>, <span class="number">0x42</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然而，这个合规方案是不充分的。构造器将默认构造 10 个类型为 <code>int</code> 的元素，在调用 <code>std::fill_n()</code> 时，这些元素立马被替换，这意味着容器内的每个元素被初始化的两次。</p>
<p>However, this compliant solution is inefficient. The constructor will default-construct 10 elements of type <code>int</code>, which are subsequently replaced by the call to <code>std::fill_n()</code>, meaning that each element in the container is initialized twice.</p>
<h2 id="合规的方案-Fill-Initialization-Compliant-Solution-Fill-Initialization"><a href="#合规的方案-Fill-Initialization-Compliant-Solution-Fill-Initialization" class="headerlink" title="合规的方案 (Fill Initialization) Compliant Solution (Fill Initialization)"></a>合规的方案 (Fill Initialization) Compliant Solution (Fill Initialization)</h2><p>这个合规方案中初始化 <code>v</code> 为 10 个值都为 <code>0x42</code> 的元素。</p>
<p>This compliant solution initializes <code>v</code> to 10 elements whose values are all <code>0x42</code>.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">10</span>, <span class="number">0x42</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="风险评估-Risk-Assessment"><a href="#风险评估-Risk-Assessment" class="headerlink" title="风险评估 Risk Assessment"></a>风险评估 Risk Assessment</h2><p>拷贝数据到不足以容纳数据大小的缓冲区中导致缓冲区溢出。攻击者可以 <a target="_blank" rel="noopener" href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-exploit">利用</a> 这个状况来执行任意代码。</p>
<p>Copying data to a buffer that is too small to hold the data results in a buffer overflow. Attackers can <a target="_blank" rel="noopener" href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-exploit">exploit</a> this condition to execute arbitrary code.</p>
<table>
<thead>
<tr>
<th align="left">Rule</th>
<th align="left">Severity</th>
<th align="left">Likelihood</th>
<th align="left">Remediation Cost</th>
<th align="left">Priority</th>
<th align="left">Level</th>
</tr>
</thead>
<tbody><tr>
<td align="left">CTR52-CPP</td>
<td align="left">High</td>
<td align="left">Likely</td>
<td align="left">Medium</td>
<td align="left"><strong>P18</strong></td>
<td align="left"><strong>L1</strong></td>
</tr>
</tbody></table>
<h2 id="Automated-Detection"><a href="#Automated-Detection" class="headerlink" title="Automated Detection"></a>Automated Detection</h2><table>
<thead>
<tr>
<th align="left">Tool</th>
<th align="left">Version</th>
<th align="left">Checker</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a target="_blank" rel="noopener" href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/CodeSonar">CodeSonar</a></td>
<td align="left"><img src="https://wiki.sei.cmu.edu/confluence/plugins/servlet/confluence/placeholder/macro?definition=e2luY2x1ZGU6Q29kZVNvbmFyX1Z9&locale=zh_CN&version=2" alt="img"></td>
<td align="left">**BADFUNC.BO.*****LANG.MEM.BO**</td>
<td align="left">A collection of warning classes that report uses of library functions prone to internal buffer overflows.Buffer Overrun</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/Parasoft">Parasoft C&#x2F;C++test</a></td>
<td align="left"><img src="https://wiki.sei.cmu.edu/confluence/plugins/servlet/confluence/placeholder/macro?definition=e2luY2x1ZGU6UGFyYXNvZnRfVn0&locale=zh_CN&version=2" alt="img"></td>
<td align="left"><strong>CERT_CPP-CTR52-a</strong></td>
<td align="left">Do not pass empty container iterators to std algorithms as destinations</td>
</tr>
</tbody></table>
<h2 id="Related-Vulnerabilities"><a href="#Related-Vulnerabilities" class="headerlink" title="Related Vulnerabilities"></a>Related Vulnerabilities</h2><p>Search for <a target="_blank" rel="noopener" href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions">vulnerabilities</a> resulting from the violation of this rule on the <a target="_blank" rel="noopener" href="https://www.kb.cert.org/vulnotes/bymetric?searchview&query=FIELD+KEYWORDS+contains+CTR52-CPP">CERT website</a>.</p>
<h2 id="Related-Guidelines"><a href="#Related-Guidelines" class="headerlink" title="Related Guidelines"></a>Related Guidelines</h2><table>
<thead>
<tr>
<th><a target="_blank" rel="noopener" href="https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=88046682">SEI CERT C++ Coding Standard</a></th>
<th><a target="_blank" rel="noopener" href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/STR50-CPP.+Guarantee+that+storage+for+strings+has+sufficient+space+for+character+data+and+the+null+terminator">STR50-CPP. Guarantee that storage for strings has sufficient space for character data and the null terminator</a></th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="https://wiki.sei.cmu.edu/confluence/display/c/SEI+CERT+C+Coding+Standard">SEI CERT C Coding Standard</a></td>
<td><a target="_blank" rel="noopener" href="https://wiki.sei.cmu.edu/confluence/display/c/ARR38-C.+Guarantee+that+library+functions+do+not+form+invalid+pointers">ARR38-C. Guarantee that library functions do not form invalid pointers</a></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://cwe.mitre.org/">MITRE CWE</a></td>
<td><a target="_blank" rel="noopener" href="http://cwe.mitre.org/data/definitions/119.html">CWE 119</a>, Failure to Constrain Operations within the Bounds of an Allocated Memory Buffer <a target="_blank" rel="noopener" href="http://cwe.mitre.org/data/definitions/805.html">CWE 805</a>, Buffer Access with Incorrect Length Value</td>
</tr>
</tbody></table>
<h2 id="Bibliography"><a href="#Bibliography" class="headerlink" title="Bibliography"></a>Bibliography</h2><table>
<thead>
<tr>
<th>[<a target="_blank" rel="noopener" href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-ISO/IEC14882-2014">ISO&#x2F;IEC 14882-2014</a>]</th>
<th>Subclause 25.3, “Mutating Sequence Operations”</th>
</tr>
</thead>
<tbody><tr>
<td>[<a target="_blank" rel="noopener" href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-ISO/IECTR24772-2013">ISO&#x2F;IEC TR 24772-2013</a>]</td>
<td>Buffer Overflow in Heap [XYB] Buffer Overflow in Stack [XYW] Unchecked Array Indexing [XYZ]</td>
</tr>
<tr>
<td>[<a target="_blank" rel="noopener" href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-Meyers01">Meyers 2001</a>]</td>
<td>Item 30, “Make Sure Destination Ranges Are Big Enough”</td>
</tr>
</tbody></table>
<hr>
<p><a target="_blank" rel="noopener" href="https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=88046457"><img src="https://wiki.sei.cmu.edu/confluence/download/attachments/88046682/button_arrow_left.png?version=1&modificationDate=1216910800000&api=v2" alt="SEI CERT C++ Coding Standard &gt; SEI CERT C++ Coding Standard &gt; button_arrow_left.png"></a> <a target="_blank" rel="noopener" href="https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=88046331"><img src="https://wiki.sei.cmu.edu/confluence/download/attachments/88046682/button_arrow_up.png?version=1&modificationDate=1216910618000&api=v2" alt="SEI CERT C++ Coding Standard &gt; SEI CERT C++ Coding Standard &gt; button_arrow_up.png"></a> <a target="_blank" rel="noopener" href="https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=88046456"><img src="https://wiki.sei.cmu.edu/confluence/download/attachments/88046682/button_arrow_right.png?version=1&modificationDate=1216910815000&api=v2" alt="SEI CERT C++ Coding Standard &gt; SEI CERT C++ Coding Standard &gt; button_arrow_right.png"></a></p>
</div><div id="donate"><link rel="stylesheet" type="text/css" href="/css/donate.css?v=1.0.0"><script type="text/javascript" src="/js/donate.js?v=1.0.0" successtext="复制成功！"></script><a class="pos-f tr3" id="github" href="https://github.com/Kaiyuan/donate-page" target="_blank" title="Github"></a><div id="DonateText">Donate</div><ul class="list pos-f" id="donateBox"><li id="WeChat" qr="/img/wechatpay.jpg"></li></ul><div class="pos-f left-100" id="QRBox"><div id="MainBox"></div></div></div><div class="post-copyright"><script type="text/javascript" src="/js/copyright.js?v=1.0.0" successtext="复制成功！"></script><link rel="stylesheet" type="text/css" href="/css/copyright.css?v=1.0.0"><p><span>本文标题：</span>CTR52-CPP. 确保库函数不要溢出</p><p><span>文章作者：</span>xwnb</p><p><span>发布时间：</span>2020-06-25</p><p><span>最后更新：</span>2023-03-31</p><p><span>原始链接：</span><a href="/posts/3185197214/">https://xwnb.github.io/posts/3185197214/</a><span class="copy-path"><i class="fa fa-clipboard" data-clipboard-text="https://xwnb.github.io/posts/3185197214/"></i></span></p><p><span>版权声明：</span>本博客所有文章除特别声明外，均采用 BY-NC-SA 许可协议。转载请注明出处！并保留本声明。感谢您的阅读和支持！</p></div><br><script type="text/javascript" src="/js/share.js?v=1.0.0" async></script><a class="article-share-link" data-url="https://xwnb.github.io/posts/3185197214/" data-id="clfx0qvf7001n1hn13t8r8grb" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAK4AAACuCAAAAACKZ2kyAAABz0lEQVR42u3aS47DMAwEUd//0s42WViuJkPlg9JqgDHk5ywaFMXjwOt8WutnyPNkt9aSK1dum3su19Uzayghrve//CS5cuVu5JJg4iASanxPuXLl/gp3jUsLILly5f4Hl4fXF+WuXLlyQy6Pp6sXp6zxs5pcuXIbXN6lnPt7pL8rV67cEvcM17r4WAdc7Y0vO8iVK3cLlwdK2sgghU7tvXLlyt3D5RUFqTdqAxb8QleuXLnTXNLsIMUKCcR0vOOyIpMrV+4wN4XyaEsTNLhokStX7kYu2bp20fLen0CuXLnT3NrVaa2U6ewQHH7kypXb5nbiqdZrqV3Y3OSuXLlyh7m8kZEWN6SdioJPrly5w9wgPsJxis5U1c3hR65cucPcWjlCQod/Bh8PlStX7k5uOjaRXpDUnkdzZHLlyh3mptcnJHpIq4UXUnLlyt3PrU1Fpv8lhc7NM3Llyh3mnuFKmyO85dFqfMiVK/etXL5qLZJ+t6b4MXLlym1zeXilA1u1IAvOanLlyh3mpkHDhyqCc1h6VpMrV+5XcvmlCC+VjtrXyJUr96Nc3mANLki4UK5cuRu5ncZHbTyL7ClXrtxPceMowSULb5XyH0KuXLnD3AeGnUjnta0//AAAAABJRU5ErkJggg==">分享</a><div class="tags"><a href="/tags/SEI CERT C++"><i class="fa fa-tag">SEI CERT C++</i></a><a href="/tags/编码规范"><i class="fa fa-tag">编码规范</i></a><a href="/tags/翻译"><i class="fa fa-tag">翻译</i></a><a href="/tags/CERT Containers"><i class="fa fa-tag">CERT Containers</i></a></div><div class="post-nav"><a class="pre" href="/posts/676034886/">CTR53-CPP. 使用有效的迭代器范围</a><a class="next" href="/posts/39044419/">CTR51-CPP. 使用有效的引用，指针，迭代器来引用容器的元素</a></div></div></div></div><div class="pure-u-1 pure-u-md-1-4"><div id="sidebar"><div class="widget"><div class="author-info"><a class="info-avatar" href="/about/" title="关于"><img class="nofancybox" src="/img/avatar.jpg"/></a><p>Stay Angry, Stay Foolish.</p><a class="info-icon" href="https://juejin.cn/user/435824491237181" title="掘金" target="_blank" style="margin-inline:5px"> <i class="fa fa-external-link-square" style="margin-inline:5px"></i></a><a class="info-icon" href="https://github.com/xwnb" title="GitHub" target="_blank" style="margin-inline:5px"> <i class="fa fa-github-square" style="margin-inline:5px"></i></a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/ROS%E5%AD%A6%E4%B9%A0/">ROS学习</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/SEI-CERT-C/">SEI CERT C++</a><span class="category-list-count">34</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Tutorial/">Tutorial</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/">微信小程序开发</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6/">自动驾驶</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a><span class="category-list-count">5</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6/" style="font-size: 15px;">自动驾驶</a> <a href="/tags/AirSim/" style="font-size: 15px;">AirSim</a> <a href="/tags/Tutorial/" style="font-size: 15px;">Tutorial</a> <a href="/tags/Markdown/" style="font-size: 15px;">Markdown</a> <a href="/tags/wechat-dev/" style="font-size: 15px;">wechat-dev</a> <a href="/tags/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/" style="font-size: 15px;">路径规划</a> <a href="/tags/motion-planning/" style="font-size: 15px;">motion planning</a> <a href="/tags/A/" style="font-size: 15px;">A*</a> <a href="/tags/LPA/" style="font-size: 15px;">LPA*</a> <a href="/tags/RRT-Connect/" style="font-size: 15px;">RRT_Connect</a> <a href="/tags/RRT/" style="font-size: 15px;">RRT*</a> <a href="/tags/RRT/" style="font-size: 15px;">RRT</a> <a href="/tags/ROS/" style="font-size: 15px;">ROS</a> <a href="/tags/controller-manager/" style="font-size: 15px;">controller_manager</a> <a href="/tags/gazebo/" style="font-size: 15px;">gazebo</a> <a href="/tags/controller-manager/" style="font-size: 15px;">controller-manager</a> <a href="/tags/ur5/" style="font-size: 15px;">ur5</a> <a href="/tags/xacro/" style="font-size: 15px;">xacro</a> <a href="/tags/SEI-CERT-C/" style="font-size: 15px;">SEI CERT C++</a> <a href="/tags/%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/" style="font-size: 15px;">编码规范</a> <a href="/tags/%E7%BF%BB%E8%AF%91/" style="font-size: 15px;">翻译</a> <a href="/tags/CERT-Containers/" style="font-size: 15px;">CERT Containers</a> <a href="/tags/Input-Output/" style="font-size: 15px;">Input Output</a> <a href="/tags/Integers/" style="font-size: 15px;">Integers</a> <a href="/tags/INT/" style="font-size: 15px;">INT</a> <a href="/tags/Memory-Management/" style="font-size: 15px;">Memory Management</a> <a href="/tags/Object-Oriented-Programming/" style="font-size: 15px;">Object Oriented Programming</a> <a href="/tags/OOP/" style="font-size: 15px;">OOP</a> <a href="/tags/Characters-and-Strings/" style="font-size: 15px;">Characters and Strings</a> <a href="/tags/STR/" style="font-size: 15px;">STR</a> <a href="/tags/roslaunch/" style="font-size: 15px;">roslaunch</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/posts/2113816124/">FIO51-CPP. 关闭不再需要的文件</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/2518610003/">OPP-CPP58. 拷贝操作绝不能改变源对象</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/294055068/">OPP-CPP57. 优先使用特定的成员函数和重载的运算符而不是C标准库函数</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/3554254475/">OOP56-CPP. 尊重替换handler的要求</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/3554254475/">OOP55-CPP. 不要使用成员指针运算符来访问不存在的成员</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/144696281/">OOP54-CPP. 优雅地处理自我拷贝赋值</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/3904355907/">OOP53-CPP. 按照规范顺序编写构造函数的成员初始化</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/4027020077/">OOP52-CPP. 不要删除一个无虚析构的多态对象</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/1084595410/">OOP51-CPP-不要切分派生对象</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/2354633166/">OOP50-CPP 不要在构造函数和析构函数中调用虚函函函数</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2023 <a href="/." rel="nofollow">Sun of Beach.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0"></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><script type="text/javascript" color="0,0,0" opacity="0.5" zIndex="-2" count="200" src="//lib.baomitu.com/canvas-nest.js/latest/canvas-nest.js"></script><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="复制成功！"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>