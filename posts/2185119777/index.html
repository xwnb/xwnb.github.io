<!-- build time:Mon Nov 15 2021 16:08:35 GMT+0000 (Coordinated Universal Time) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 4.2.1"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Helvetica Neue, Helvetica, Hiragino Sans GB, Microsoft YaHei, Source Han Sans CN, WenQuanYi Micro Hei, Arial, sans-serif:300,300italic,400,400italic,700,700italic|Consolas, Monaco, Menlo, monospace:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"xwnb.github.io",root:"/",scheme:"Gemini",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!0,show_result:!0,style:"flat"},back2top:{enable:!0,sidebar:!1,scrollpercent:!0},bookmark:{enable:!0,color:"#222",save:"auto"},fancybox:!0,mediumzoom:!1,lazyload:!0,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="原文链接：MEM51-CPP. Properly deallocate dynamically allocated resources"><meta property="og:type" content="article"><meta property="og:title" content="MEM51-CPP. 正确地释放动态分配的资源"><meta property="og:url" content="https://xwnb.github.io/posts/2185119777/index.html"><meta property="og:site_name" content="Sun of Beach"><meta property="og:description" content="原文链接：MEM51-CPP. Properly deallocate dynamically allocated resources"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2021-11-10T22:56:17.000Z"><meta property="article:modified_time" content="2021-11-15T16:08:09.515Z"><meta property="article:author" content="村口最靓的 小Xu"><meta property="article:tag" content="SEI CERT C++"><meta property="article:tag" content="编码规范"><meta property="article:tag" content="翻译"><meta property="article:tag" content="Memory Management"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://xwnb.github.io/posts/2185119777/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/theme-next/theme-next-needmoreshare2@1/needsharebutton.min.css"><style>#needsharebutton-float{bottom:88px;cursor:pointer;left:-8px;position:fixed;z-index:9999}#needsharebutton-float .btn{border:1px solid $btn-default-border-color;border-radius:4px;padding:0 10px 0 14px}</style><title>MEM51-CPP. 正确地释放动态分配的资源 | Sun of Beach</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript><link rel="alternate" href="/atom.xml" title="Sun of Beach" type="application/atom+xml"></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">Sun of Beach</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">Stay Angry, Stay Foolish</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-commonweal"><a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><div class="reading-progress-bar"></div><a role="button" class="book-mark-link book-mark-link-fixed"></a> <a href="https://github.com/xwnb" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://xwnb.github.io/posts/2185119777/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/profile-picture.jpg"><meta itemprop="name" content="村口最靓的 小Xu"><meta itemprop="description" content="个人站，学习记录、实践教程、资料收集等，哈哈哈。"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Sun of Beach"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">MEM51-CPP. 正确地释放动态分配的资源</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-11-10 22:56:17" itemprop="dateCreated datePublished" datetime="2021-11-10T22:56:17+00:00">2021-11-10</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2021-11-15 16:08:09" itemprop="dateModified" datetime="2021-11-15T16:08:09+00:00">2021-11-15</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/SEI-CERT-C/" itemprop="url" rel="index"><span itemprop="name">SEI CERT C++</span></a> </span></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span id="busuanzi_value_page_pv"></span></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>7.7k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>7 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><p>原文链接：</p><p><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/MEM51-CPP.+Properly+deallocate+dynamically+allocated+resources" target="_blank" rel="noopener">MEM51-CPP. Properly deallocate dynamically allocated resources</a></p><a id="more"></a><hr><p>C 语言提供了几种分配内存的方式，例如 <code>std::malloc()</code>, <code>std::calloc()</code>, 和 <code>std::realloc()</code> 。这些也可以被 C++ 使用。然而，对于释放内存而言，C 语言只定义了一种简单的方式：<code>std::free()</code> 。关于 C 分配和释放内存要求的条款，见 <a href="https://wiki.sei.cmu.edu/confluence/display/c/MEM31-C.+Free+dynamically+allocated+memory+when+no+longer+needed" target="_blank" rel="noopener">MEM31-C. Free dynamically allocated memory when no longer needed</a> 和 <a href="https://wiki.sei.cmu.edu/confluence/display/c/MEM34-C.+Only+free+memory+allocated+dynamically" target="_blank" rel="noopener">MEM34-C. Only free memory allocated dynamically</a></p><p>C++ 语言提供了额外的集中分配内存的方式，例如运算符 <code>new</code>, <code>new []</code> 和 placement <code>new</code> ，还有<a href="http://www.cplusplus.com/reference/memory/allocator/" target="_blank" rel="noopener">分配器对象（allocator objects）</a> 。不像 C，C++ 提供了多种释放动态内存的方法，例如运算符 <code>delete</code> ，<code>delete []()</code> 和分配器对象上的释放函数(deallocation functions)。</p><p>除了 <code>nullptr</code> ，不要对其他对象调用释放函数，或者下述相应分配函数返回的指针。</p><table><thead><tr><th style="text-align:left">分配器</th><th style="text-align:left">释放器</th></tr></thead><tbody><tr><td style="text-align:left">global<code>operator new()/new</code></td><td style="text-align:left">global<code>operator delete</code>()<code>/delete</code></td></tr><tr><td style="text-align:left">global<code>operator new[]()/new[]</code></td><td style="text-align:left">global<code>operator delete[]()/delete[]</code></td></tr><tr><td style="text-align:left">class-specific<code>operator new()/new</code></td><td style="text-align:left"><code>class-specific operator delete</code>()<code>/delete</code></td></tr><tr><td style="text-align:left"><code>class-specific operator new[]()/new[]</code></td><td style="text-align:left"><code>class-specific operator delete[]()/delete[]</code></td></tr><tr><td style="text-align:left">placement <code>operator new</code>()</td><td style="text-align:left">N/A</td></tr><tr><td style="text-align:left"><code>allocator&lt;T&gt;::allocate()</code></td><td style="text-align:left"><code>allocator&lt;T&gt;::deallocate()</code></td></tr><tr><td style="text-align:left"><code>std::malloc()</code>, <code>std::calloc()</code>, <code>std::realloc()</code></td><td style="text-align:left"><code>std::free()</code></td></tr><tr><td style="text-align:left"><code>std::get_temporary_buffer()</code></td><td style="text-align:left"><code>std::return_temporary_buffer()</code></td></tr></tbody></table><p>向不正确的释放函数传递一个指针将导致 <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-undefinedbehavior" target="_blank" rel="noopener">未定义行为</a>.</p><p>C++ 标准, [expr.delete], 段落 2 [<a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-ISO/IEC14882-2014" target="_blank" rel="noopener">ISO/IEC 14882-2014</a>], 部分叙述如下:</p><blockquote><p>首选 (<em>delete object</em>)，<code>delete</code> 操作数可能是一个空指针值，一个由前述 <em>new-表达式</em> 创建的指向非数组对象的指针，或者指向一个表示类似 (Clause 10) 的基类对象的子对象 (1.8) 指针。如果不是，该行为是未定义的。其次 (delete array)，<code>delete</code> 操作数可能是一个空指针值或者由先前数组 <em>new-表达式</em> 创建的指针。否则，该行为是未定义的。</p></blockquote><p>释放一个非动态分配（包括由 placement <code>new()</code> 产生的非动态指针的指针）是未定义行为，因为该指针并不是从分配函数中获取的。释放一个已经传入过释放函数中的指针是未定义的，因为指针已经不再指向之前已动态分配过的内存。</p><p>当像 <code>new</code> 操作符被调用时，这导致同名的可重载的操作符被调用，比如 <code>operator new()</code> 。这些可重载的函数也可能被直接调用，但是和对应操作符有相同的限制。这就是说，调用 <code>operator delete()</code> ，并传入一个指针参数和对该指针调用 <code>delete</code> 操作符限制是一样的。进一步说，重载版本受作用域限制。因此，调用一个类型指定操作符来分配一个对象，但通过全局操作符来释放这个对象，这是可能的（但不允许）。</p><p>除了 <code>new</code> 和 <code>delete</code> 操作符，当使用其他内存管理函数，见 <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/MEM53-CPP.+Explicitly+construct+and+destruct+objects+when+manually+managing+object+lifetime" target="_blank" rel="noopener">MEM53-CPP. Explicitly construct and destruct objects when manually managing object lifetime</a> 获取关于对象生命周期管理信息。</p><h2 id="不合规代码示例-placement-new"><a class="header-anchor" href="#不合规代码示例-placement-new">¶</a>不合规代码示例 (placement <code>new()</code>)</h2><p>在这个不合规的代码示例中，局部变量 <code>space</code> 被当作表达式传入 placement <code>new</code> 操作符中。调用返回的指针接着被传入到 <code>::operator delete()</code> ，由于 <code>::operator delete()</code> 试图去释放并不是由 <code>::operator new()</code> 返回的指针，导致了 <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-undefinedbehavior" target="_blank" rel="noopener">未定义行为</a> 。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">  S() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"S::S()"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line">  ~S() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"S::~S()"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">alignas</span>(struct S) <span class="keyword">char</span> space[<span class="keyword">sizeof</span>(struct S)];</span><br><span class="line">  S *s1 = <span class="keyword">new</span> (&amp;space) S;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">delete</span> s1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="合规方案-placement-new"><a class="header-anchor" href="#合规方案-placement-new">¶</a>合规方案 (placement <code>new()</code>)</h2><p>这个合规方案移除了对 <code>::operator delete()的</code>调用，而用显式地调用 <code>s1</code> 的析构函数来替代。这是为数不多的几次需要确保显式调用析构函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">  S() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"S::S()"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line">  ~S() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"S::~S()"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">alignas</span>(struct S) <span class="keyword">char</span> space[<span class="keyword">sizeof</span>(struct S)];</span><br><span class="line">  S *s1 = <span class="keyword">new</span> (&amp;space) S;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"> </span><br><span class="line">  s1-&gt;~S();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="不合规代码示例-Uninitialized-delete"><a class="header-anchor" href="#不合规代码示例-Uninitialized-delete">¶</a>不合规代码示例 (Uninitialized <code>delete</code>)</h2><p>在这个不合规代码例子中，在同一个 <code>try</code> 块内试图进行两次内存分配。如果某一个失败了，那么 <code>catch</code> 块试图释放已经被分配的资源。然而，由于指针值并没有初始化为已知的值，<code>i1</code> 内存分配错误可能造成传入 <code>::operator delete()</code> 的值 (<code>i2</code>中的)并不是之前调用 <code>::operator new()</code> 所返回的，导致 <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-undefinedbehavior" target="_blank" rel="noopener">未定义行为</a>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;new&gt;</span></span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> *i1, *i2;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    i1 = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">    i2 = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (<span class="built_in">std</span>::bad_alloc &amp;) &#123;</span><br><span class="line">    <span class="keyword">delete</span> i1;</span><br><span class="line">    <span class="keyword">delete</span> i2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="合规方案-Uninitialized-delete"><a class="header-anchor" href="#合规方案-Uninitialized-delete">¶</a>合规方案 (Uninitialized <code>delete</code>)</h2><p>这个兼容方案将两个指针均初始化为 <code>nullptr</code> ，可以被合法传入 <code>::operator delete().</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;new&gt;</span></span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> *i1 = <span class="literal">nullptr</span>, *i2 = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    i1 = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">    i2 = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (<span class="built_in">std</span>::bad_alloc &amp;) &#123;</span><br><span class="line">    <span class="keyword">delete</span> i1;</span><br><span class="line">    <span class="keyword">delete</span> i2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="不合规代码示例-Double-Free"><a class="header-anchor" href="#不合规代码示例-Double-Free">¶</a>不合规代码示例 (Double-Free)</h2><p>一旦指针被传入到正确的释放函数中，该指针值将不可用。当并未在调用后续分配函数返回时重新赋值，该指针第二次传入释放函数，造成试图释放未动态分配的内存。管理着堆的潜在数据结构（注：该指针指向的已经被释放的内存堆）某种程度上会造成崩毁——会在程序中引入安全 <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-vulnerability" target="_blank" rel="noopener">漏洞 (vulnerabilities)</a>。 这种类型的问题被称为 <em>二次释放漏洞 (double-free vulnerabilities)</em> 。实践中，二次释放漏洞可能会 <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-exploit" target="_blank" rel="noopener">利用</a> 执行任意代码。</p><p>在这个不合规的代码例子中，类 <code>C</code> 拥有一个 <code>P *</code> 的所有权——后续会在类的析构函数中释放。C++ 标准，[class.copy]，段落 7 [<a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-ISO/IEC14882-2014" target="_blank" rel="noopener">ISO/IEC 14882-2014</a>], 陈述如下:</p><blockquote><p>如果在类的定义未显式声明一个拷贝构造函数，将会隐式声明一个拷贝构造函数。如果类的定义声明了一个移动构造函数或者移动赋值运算，被隐式声明的拷贝构造函数将被定义为 deleted；否则，其（注：被隐式声明的拷贝构造函数）将被定义为 default (8.4)。如果该类包含一个用户自定义的拷贝赋值运算或者析构函数，后者要被弃用（注：用户需要显式自定义拷贝构造函数）。</p><p>If the class definition does not explicitly declare a copy constructor, one is declared implicitly. If the class definition declares a move constructor or move assignment operator, the implicitly declared copy constructor is defined as deleted; otherwise, it is defined as defaulted (8.4). The latter case is deprecated if the class has a user-declared copy assignment operator or a user-declared destructor.</p></blockquote><p><code>C</code> 尽管存在用户定义的析构函数，但是含有一个隐式的默认拷贝构造函数，并且这个默认的拷贝构造函数将拷贝存储在 <code>p</code> 中的指针值，这将导致二次释放：第一次释放发生在当 <code>g()</code> 退出时，第二次释放发生在当 <code>h()</code> 退出时。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">P</span> &#123;</span>&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> &#123;</span></span><br><span class="line">  P *p;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  C(P *p) : p(p) &#123;&#125;</span><br><span class="line">  ~C() &#123; <span class="keyword">delete</span> p; &#125; </span><br><span class="line">   </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(C c)</span> </span>&#123;</span><br><span class="line">  c.f();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">h</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  P *p = <span class="keyword">new</span> P;</span><br><span class="line">  <span class="function">C <span class="title">c</span><span class="params">(p)</span></span>;</span><br><span class="line">  g(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="合规方案-Double-Free"><a class="header-anchor" href="#合规方案-Double-Free">¶</a>合规方案 (Double-Free)</h2><p>在这个合规方案中，<code>C</code> 的拷贝构造函数和拷贝赋值运算被显式删除。这个删除将会使先前不合规代码示例程序 <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-ill-formed" target="_blank" rel="noopener">不合语法的 (ill-formed)</a> ——由于 <code>g</code> 的定义使用了被删除的拷贝构造函数。因此，<code>g()</code> 被修改为接受其引用参数，消除二次释放。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">P</span> &#123;</span>&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> &#123;</span></span><br><span class="line">  P *p;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  C(P *p) : p(p) &#123;&#125;</span><br><span class="line">  C(<span class="keyword">const</span> C&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  ~C() &#123; <span class="keyword">delete</span> p; &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">void</span> <span class="keyword">operator</span>=(<span class="keyword">const</span> C&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">   </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(C &amp;c)</span> </span>&#123;</span><br><span class="line">  c.f();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">h</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  P *p = <span class="keyword">new</span> P;</span><br><span class="line">  <span class="function">C <span class="title">c</span><span class="params">(p)</span></span>;</span><br><span class="line">  g(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="不合规代码示例-array-new"><a class="header-anchor" href="#不合规代码示例-array-new">¶</a>不合规代码示例 (array <code>new[]</code>)</h2><p>在接下来这个不合规的代码示例中，一个使用数组 <code>new[]</code> 来分配的数组，但是通过 <code>delete</code> 而不是 <code>delete[]</code> 来释放内存，导致 <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-undefinedbehavior" target="_blank" rel="noopener">未定义行为</a>.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> *<span class="built_in">array</span> = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">delete</span> <span class="built_in">array</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="合规方案-array-new"><a class="header-anchor" href="#合规方案-array-new">¶</a>合规方案 (array <code>new[]</code>)</h2><p>在这个合规方案中，通过调用 <code>delelte[]</code> 替换 <code>delete</code> 来修复，使代码遵循使用正确的配对的内存分配和释放函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> *<span class="built_in">array</span> = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">delete</span>[] <span class="built_in">array</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="不合规代码示例-malloc"><a class="header-anchor" href="#不合规代码示例-malloc">¶</a>不合规代码示例 (<code>malloc()</code>)</h2><p>在这个不合规的代码示例中，混用了 <code>malloc()</code> 和 <code>delete</code> 的调用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> *i = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span> *&gt;(<span class="built_in">std</span>::<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)));</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">delete</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子没有违背 <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/MEM53-CPP.+Explicitly+construct+and+destruct+objects+when+manually+managing+object+lifetime" target="_blank" rel="noopener">MEM53-CPP. Explicitly construct and destruct objects when manually managing object lifetime</a> 因为它遵循 MEM53-CPP-EX1 异常.</p><h2 id="实现细节"><a class="header-anchor" href="#实现细节">¶</a>实现细节</h2><p>有些 <code>::operator new()</code> 的实现会调用 <code>std::malloc()</code> 。在这类实现中， <code>::operator delete()</code> 函数被要求调用 <code>std::free()</code> 去释放指针，并且非合规的代码示例将表现为正确定义的行为。然而，不应该依赖于实现，这里有个 <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-implementation" target="_blank" rel="noopener">实现</a> 的细节，实现没有义务使用潜在的 C 内存管理函数来实现 C++ 内存管理操作。</p><h2 id="合规方案-malloc"><a class="header-anchor" href="#合规方案-malloc">¶</a>合规方案 (<code>malloc()</code>)</h2><p>在这个合规方案中，指针由 <code>std::malloc()</code> 分配，调用 <code>std::free()</code> 来释放，而不是 <code>delete.</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> *i = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span> *&gt;(<span class="built_in">std</span>::<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)));</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">free</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="不合规代码示例-new"><a class="header-anchor" href="#不合规代码示例-new">¶</a>不合规代码示例 ( <code>new</code> )</h2><p>这个不合规的代码示例调用 <code>std::free()</code> 来释放通过 <code>new</code> 分配的内存。由此产生了一个 <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-undefinedbehavior" target="_blank" rel="noopener">未定义行为</a> 的副作用——由于使用了不正确的释放函数，该对象的析构函数并不会被调用，通过 <code>std::free()</code> 无法释放对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">  ~S();</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  S *s = <span class="keyword">new</span> S();</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">free</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，该代码违背了 <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/MEM53-CPP.+Explicitly+construct+and+destruct+objects+when+manually+managing+object+lifetime" target="_blank" rel="noopener">MEM53-CPP. Explicitly construct and destruct objects when manually managing object lifetime</a>.</p><h2 id="合规方案-new"><a class="header-anchor" href="#合规方案-new">¶</a>合规方案 (<code>new</code>)</h2><p>在这个合规方案中，由 <code>new</code> 分配的指针通过调用 <code>delete</code> 来释放，而不是 <code>std::free()</code> 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct&#96; &#96;S &#123;&#96;&#96; &#96;&#96;~S();&#96;&#96;&#125;;&#96; &#96;void&#96; &#96;f() &#123;&#96;&#96; &#96;&#96;S *s &#x3D; &#96;&#96;new&#96; &#96;S();&#96;&#96; &#96;&#96;&#x2F;&#x2F; ...&#96;&#96; &#96;&#96;delete&#96; &#96;s;&#96;&#96;&#125;</span><br></pre></td></tr></table></figure><h2 id="不合规代码示例-Class-new"><a class="header-anchor" href="#不合规代码示例-Class-new">¶</a>不合规代码示例 (Class <code>new</code>)</h2><p>在这个不合规代码示例中，<code>operator new()</code> 的类特定(class-specific)的实现重载了全局 <code>new</code> 操作符。当 <code>new</code> 被调用时，类特定的重载版本被选中，因此 <code>S::operator new()</code> 被调用。然而，由于该对象由作用域内的 <code>::delete</code> 操作符销毁，全局的 <code>operator delete()</code> 函数被调用，而不是类他特定的实现的 <code>S::operator delete()</code>，导致 <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-undefinedbehavior" target="_blank" rel="noopener">未定义行为</a>.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;new&gt;</span></span></span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="built_in">size</span>)</span> <span class="title">noexcept</span><span class="params">(<span class="literal">true</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">malloc</span>(<span class="built_in">size</span>);</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *ptr)</span> <span class="title">noexcept</span><span class="params">(<span class="literal">true</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">free</span>(ptr);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  S *s = <span class="keyword">new</span> S;</span><br><span class="line">  ::<span class="keyword">delete</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="合规方案-class-new"><a class="header-anchor" href="#合规方案-class-new">¶</a>合规方案 (class <code>new</code>)</h2><p>在这个合规方案中，作用域内的 <code>::delete</code> 调用被非域内的 <code>delete</code> 调用所替代, 引起 <code>S::operator delete()</code>被调用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;new&gt;</span></span></span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="built_in">size</span>)</span> <span class="title">noexcept</span><span class="params">(<span class="literal">true</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">malloc</span>(<span class="built_in">size</span>);</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *ptr)</span> <span class="title">noexcept</span><span class="params">(<span class="literal">true</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">free</span>(ptr);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  S *s = <span class="keyword">new</span> S;</span><br><span class="line">  <span class="keyword">delete</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="不合规代码示例-std-unique-ptr"><a class="header-anchor" href="#不合规代码示例-std-unique-ptr">¶</a>不合规代码示例 (<code>std::unique_ptr</code>)</h2><p>在这个不合规代码示例中，声明了一个 <code>std::unique_ptr</code> 来持有一个对象的指针——但是直接由对象数组来初始化的。当该 <code>std::unique_ptr</code> 被销毁时，默认的删除器调用 <code>delete</code> 而不是 <code>delete[]</code> ，导致了未定义行为。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span>&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;S&gt; s&#123;<span class="keyword">new</span> S[<span class="number">10</span>]&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="合规方案-std-unique-ptr"><a class="header-anchor" href="#合规方案-std-unique-ptr">¶</a>合规方案 (<code>std::unique_ptr</code>)</h2><p>在这个合规方案中，声明了一个 <code>std::unique_ptr</code> 来持有一个对象数组，而不是持有指向一个对象的指针。此外，用 <code>std::make_unique()</code> 来初始化这个智能指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span>&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;S[]&gt; s = <span class="built_in">std</span>::make_unique&lt;S[]&gt;(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>std::make_unique()</code> 而不是直接初始化，如果 <code>std::unique_ptr</code> 的结果不是正确类型，将发出诊断 (emit a diagnostic) 。如果它被用在不合规的代码例子中，结果将会是不合规范的程序，而不是未定义行为。最好用 <code>std::make_unique()</code> 来代替其他手动初始化的方式。</p><h2 id="不合规代码示例-std-shared-ptr"><a class="header-anchor" href="#不合规代码示例-std-shared-ptr">¶</a>不合规代码示例 (<code>std::shared_ptr</code>)</h2><p>在这个不合规代码示例中，声明了一个 <code>std::shared_ptr</code> 来持有一个对象的指针——但是直接由对象数组来初始化的。和使用 <code>std::unique_ptr</code> 一样，当该 <code>std::shared_ptr</code> 被销毁时，默认的删除器调用 <code>delete</code> 而不是 <code>delete[]</code> ，导致了未定义行为。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span>&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;S&gt; s&#123;<span class="keyword">new</span> S[<span class="number">10</span>]&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="合规方案-std-shared-ptr"><a class="header-anchor" href="#合规方案-std-shared-ptr">¶</a>合规方案 (<code>std::shared_ptr</code>)</h2><p>不同于 <code>std::unique_ptr</code> 的合规方案，那些调用 <code>std::make_unique()</code> 来创建指向数组的独占指针的地方，调用数组类型的 <code>std::make_shared()</code> 是不合语法规范的。反之，这个合规方案为共享指针类型手动指定了一个自定义的删除器，来保证潜在的数组被正确的删除。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span>&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;S&gt; s&#123;<span class="keyword">new</span> S[<span class="number">10</span>], [](<span class="keyword">const</span> S *ptr) &#123; <span class="keyword">delete</span> [] ptr; &#125;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="风险评估"><a class="header-anchor" href="#风险评估">¶</a>风险评估</h2><p>传递一个从先前并不匹配的分配函数获取的指针值到一个释放函数中会导致 <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-undefinedbehavior" target="_blank" rel="noopener">未定义行为</a>，可以引起可利用的 <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-vulnerability" target="_blank" rel="noopener">漏洞</a>.</p><table><thead><tr><th style="text-align:left">Rule</th><th style="text-align:left">Severity</th><th style="text-align:left">Likelihood</th><th style="text-align:left">Remediation Cost</th><th style="text-align:left">Priority</th><th style="text-align:left">Level</th></tr></thead><tbody><tr><td style="text-align:left">MEM51-CPP</td><td style="text-align:left">High</td><td style="text-align:left">Likely</td><td style="text-align:left">Medium</td><td style="text-align:left"><strong>P18</strong></td><td style="text-align:left"><strong>L1</strong></td></tr></tbody></table><h2 id="Automated-Detection"><a class="header-anchor" href="#Automated-Detection">¶</a>Automated Detection</h2><table><thead><tr><th style="text-align:left">Tool</th><th style="text-align:left">Version</th><th style="text-align:left">Checker</th><th style="text-align:left">Description</th></tr></thead><tbody><tr><td style="text-align:left"><a href="https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=222953724" target="_blank" rel="noopener">Astrée</a></td><td style="text-align:left">20.10</td><td style="text-align:left">**invalid_dynamic_memory_allocation dangling_pointer_use **</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/Axivion+Bauhaus+Suite" target="_blank" rel="noopener">Axivion Bauhaus Suite</a></td><td style="text-align:left">7.2.0</td><td style="text-align:left"><strong>CertC+±MEM51</strong></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/Clang" target="_blank" rel="noopener">Clang</a></td><td style="text-align:left">3.9</td><td style="text-align:left"><code>clang-analyzer-cplusplus.NewDeleteLeaks</code> <code>-Wmismatched-new-deleteclang-analyzer-unix.MismatchedDeallocator</code></td><td style="text-align:left">Checked by <code>clang-tidy</code>, but does not catch all violations of this rule</td></tr><tr><td style="text-align:left"><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/CodeSonar" target="_blank" rel="noopener">CodeSonar</a></td><td style="text-align:left">6.1p0</td><td style="text-align:left">**ALLOC.FNH ALLOC.DF <a href="http://ALLOC.TM" target="_blank" rel="noopener">ALLOC.TM</a> **</td><td style="text-align:left">Free non-heap variable Double free Type mismatch</td></tr><tr><td style="text-align:left"><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/Helix+QAC" target="_blank" rel="noopener">Helix QAC</a></td><td style="text-align:left">2021.2</td><td style="text-align:left"><strong>C<ins>2110, C</ins>2111, C<ins>2112, C</ins>2113, C<ins>2118, C</ins>3337, C<ins>3339, C</ins>4262, C<ins>4263, C</ins>4264</strong></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/Klocwork" target="_blank" rel="noopener">Klocwork</a></td><td style="text-align:left">2021.1</td><td style="text-align:left"><strong><a href="https://support.roguewave.com/documentation/klocwork/en/current/certcandcsecurecodingstandardidsmappedtoklocworkcandccheckers/" target="_blank" rel="noopener">CL.FFM.ASSIGN</a></strong> <strong><a href="https://support.roguewave.com/documentation/klocwork/en/current/certcandcsecurecodingstandardidsmappedtoklocworkcandccheckers/" target="_blank" rel="noopener">CL.FFM.COPY</a></strong> <strong><a href="https://support.roguewave.com/documentation/klocwork/en/current/certcandcsecurecodingstandardidsmappedtoklocworkcandccheckers/" target="_blank" rel="noopener">CL.FMM</a>****<a href="https://support.roguewave.com/documentation/klocwork/en/current/certcandcsecurecodingstandardidsmappedtoklocworkcandccheckers/" target="_blank" rel="noopener">FMM.MIGHT</a></strong> <strong><a href="https://support.roguewave.com/documentation/klocwork/en/current/certcandcsecurecodingstandardidsmappedtoklocworkcandccheckers/" target="_blank" rel="noopener">FMM.MUST</a></strong> <strong><a href="https://support.roguewave.com/documentation/klocwork/en/current/certcandcsecurecodingstandardidsmappedtoklocworkcandccheckers/" target="_blank" rel="noopener">FNH.MIGHT</a></strong> <strong><a href="https://support.roguewave.com/documentation/klocwork/en/current/certcandcsecurecodingstandardidsmappedtoklocworkcandccheckers/" target="_blank" rel="noopener">FNH.MUST</a></strong> <strong><a href="https://support.roguewave.com/documentation/klocwork/en/current/certcandcsecurecodingstandardidsmappedtoklocworkcandccheckers/" target="_blank" rel="noopener">FUM.GEN.MIGHT</a></strong> <strong><a href="https://support.roguewave.com/documentation/klocwork/en/current/certcandcsecurecodingstandardidsmappedtoklocworkcandccheckers/" target="_blank" rel="noopener">FUM.GEN.MUST</a><strong><strong><a href="https://support.roguewave.com/documentation/klocwork/en/current/certcandcsecurecodingstandardidsmappedtoklocworkcandccheckers/" target="_blank" rel="noopener">UNINIT.CTOR.MIGHT</a> <a href="https://support.roguewave.com/documentation/klocwork/en/current/certcandcsecurecodingstandardidsmappedtoklocworkcandccheckers/" target="_blank" rel="noopener">UNINIT.CTOR.MUST</a> <a href="https://support.roguewave.com/documentation/klocwork/en/current/certcandcsecurecodingstandardidsmappedtoklocworkcandccheckers/" target="_blank" rel="noopener">UNINIT.HEAP.MIGHT</a> <a href="https://support.roguewave.com/documentation/klocwork/en/current/certcandcsecurecodingstandardidsmappedtoklocworkcandccheckers/" target="_blank" rel="noopener">UNINIT.HEAP.MUST</a></strong></strong><a href="https://support.roguewave.com/documentation/klocwork/en/current/certcandcsecurecodingstandardidsmappedtoklocworkcandccheckers/" target="_blank" rel="noopener">UNINIT.STACK.ARRAY.MIGHT</a> <strong><strong><a href="https://support.roguewave.com/documentation/klocwork/en/current/certcandcsecurecodingstandardidsmappedtoklocworkcandccheckers/" target="_blank" rel="noopener">UNINIT.STACK.ARRAY.PARTIAL.MUST</a></strong></strong><a href="https://support.roguewave.com/documentation/klocwork/en/current/certcandcsecurecodingstandardidsmappedtoklocworkcandccheckers/" target="_blank" rel="noopener">UNINIT.STACK.ARRAY.MUST</a> <a href="https://support.roguewave.com/documentation/klocwork/en/current/certcandcsecurecodingstandardidsmappedtoklocworkcandccheckers/" target="_blank" rel="noopener">UNINIT.STACK.MIGHT</a> <a href="https://support.roguewave.com/documentation/klocwork/en/current/certcandcsecurecodingstandardidsmappedtoklocworkcandccheckers/" target="_blank" rel="noopener">UNINIT.STACK.MUST</a></strong></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/LDRA" target="_blank" rel="noopener">LDRA tool suite</a></td><td style="text-align:left">9.7.1</td><td style="text-align:left"><strong>232 S, 236 S, 239 S, 407 S, 469 S, 470 S, 483 S, 484 S, 485 S, 64 D, 112 D</strong>** **</td><td style="text-align:left">Partially implemented</td></tr><tr><td style="text-align:left"><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/Parasoft" target="_blank" rel="noopener">Parasoft C/C++test</a></td><td style="text-align:left">2021.1</td><td style="text-align:left"><strong>CERT_CPP-MEM51-a</strong> <strong>CERT_CPP-MEM51-b</strong> <strong>CERT_CPP-MEM51-c</strong> <strong>CERT_CPP-MEM51-d</strong></td><td style="text-align:left">Use the same form in corresponding calls to new/malloc and delete/free Always provide empty brackets ([]) for delete when deallocating arrays Both copy constructor and copy assignment operator should be declared for classes with a nontrivial destructor Properly deallocate dynamically allocated resources</td></tr><tr><td style="text-align:left"><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/Parasoft" target="_blank" rel="noopener">Parasoft Insure++</a></td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left">Runtime detection</td></tr><tr><td style="text-align:left"><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/Polyspace+Bug+Finder" target="_blank" rel="noopener">Polyspace Bug Finder</a></td><td style="text-align:left">R2021b</td><td style="text-align:left"><a href="https://www.mathworks.com/help/bugfinder/ref/certcmem51cpp.html" target="_blank" rel="noopener">CERT C++: MEM51-CPP</a></td><td style="text-align:left">Checks for:Invalid deletion of pointerInvalid free of pointerDeallocation of previously deallocated pointerRule partially covered.</td></tr><tr><td style="text-align:left"><a href="https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=88046345" target="_blank" rel="noopener">PRQA QA-C++</a></td><td style="text-align:left">4.4</td><td style="text-align:left"><strong>2110, 2111, 2112, 2113, 2118*<em>,*</em></strong><strong><em>*3337, 3339*</em>, 4262, 4263, 4264</strong></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/PVS-Studio" target="_blank" rel="noopener">PVS-Studio</a></td><td style="text-align:left">7.15</td><td style="text-align:left"><a href="https://pvs-studio.com/en/docs/warnings/v515/" target="_blank" rel="noopener"><strong>V515</strong></a>, <a href="https://pvs-studio.com/en/docs/warnings/v554/" target="_blank" rel="noopener"><strong>V554</strong></a>, <a href="https://pvs-studio.com/en/docs/warnings/v611/" target="_blank" rel="noopener"><strong>V611</strong></a>, <a href="https://pvs-studio.com/en/docs/warnings/v701/" target="_blank" rel="noopener"><strong>V701</strong></a>, <a href="https://pvs-studio.com/en/docs/warnings/v748/" target="_blank" rel="noopener"><strong>V748</strong></a>, <a href="https://pvs-studio.com/en/docs/warnings/v773/" target="_blank" rel="noopener"><strong>V773</strong></a>, <strong><a href="https://pvs-studio.com/en/docs/warnings/v1066/" target="_blank" rel="noopener">V1066</a></strong></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><a href="https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=88046388" target="_blank" rel="noopener">SonarQube C/C++ Plugin</a></td><td style="text-align:left">4.10</td><td style="text-align:left"><strong><a href="https://www.sonarsource.com/products/codeanalyzers/sonarcfamilyforcpp/rules-cpp.html#RSPEC-1232" target="_blank" rel="noopener">S1232</a></strong></td><td style="text-align:left"></td></tr></tbody></table><h2 id="Related-Vulnerabilities"><a class="header-anchor" href="#Related-Vulnerabilities">¶</a>Related Vulnerabilities</h2><p>Search for <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-vulnerability" target="_blank" rel="noopener">vulnerabilities</a> resulting from the violation of this rule on the <a href="https://www.kb.cert.org/vulnotes/bymetric?searchview&amp;query=FIELD+KEYWORDS+contains+MEM31-CPP" target="_blank" rel="noopener">CERT website</a>.</p><h2 id="Related-Guidelines"><a class="header-anchor" href="#Related-Guidelines">¶</a>Related Guidelines</h2><table><thead><tr><th><a href="https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=88046682" target="_blank" rel="noopener">SEI CERT C++ Coding Standard</a></th><th><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/MEM53-CPP.+Explicitly+construct+and+destruct+objects+when+manually+managing+object+lifetime" target="_blank" rel="noopener">MEM53-CPP. Explicitly construct and destruct objects when manually managing object lifetime</a></th></tr></thead><tbody><tr><td><a href="https://wiki.sei.cmu.edu/confluence/display/c/SEI+CERT+C+Coding+Standard" target="_blank" rel="noopener">SEI CERT C Coding Standard</a></td><td><a href="https://wiki.sei.cmu.edu/confluence/display/c/MEM31-C.+Free+dynamically+allocated+memory+when+no+longer+needed" target="_blank" rel="noopener">MEM31-C. Free dynamically allocated memory when no longer needed </a><a href="https://wiki.sei.cmu.edu/confluence/display/c/MEM34-C.+Only+free+memory+allocated+dynamically" target="_blank" rel="noopener">MEM34-C. Only free memory allocated dynamically</a></td></tr><tr><td><a href="http://cwe.mitre.org/" target="_blank" rel="noopener">MITRE CWE</a></td><td><a href="http://cwe.mitre.org/data/definitions/590.html" target="_blank" rel="noopener">CWE 590</a>, Free of Memory Not on the Heap <a href="http://cwe.mitre.org/data/definitions/415.html" target="_blank" rel="noopener">CWE 415</a>, Double Free <a href="http://cwe.mitre.org/data/definitions/404.html" target="_blank" rel="noopener">CWE 404</a>, Improper Resource Shutdown or Release <a href="http://cwe.mitre.org/data/definitions/762.html" target="_blank" rel="noopener">CWE 762</a>, Mismatched Memory Management Routines</td></tr></tbody></table><h2 id="Bibliography"><a class="header-anchor" href="#Bibliography">¶</a>Bibliography</h2><table><thead><tr><th>[<a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-Dowd07" target="_blank" rel="noopener">Dowd 2007</a>]</th><th>“Attacking <code>delete</code> and <code>delete []</code> in C++”</th></tr></thead><tbody><tr><td>[<a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-Henricson97" target="_blank" rel="noopener">Henricson 1997</a>]</td><td>Rule 8.1, &quot;<code>delete</code> should only be used with <code>new&quot;</code> Rule 8.2, &quot;<code>delete []</code> should only be used with <code>new []&quot;</code></td></tr><tr><td>[<a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-ISO/IEC14882-2014" target="_blank" rel="noopener">ISO/IEC 14882-2014</a>]</td><td>Subclause 5.3.5, “Delete” Subclause 12.8, “Copying and Moving Class Objects” Subclause 18.6.1, “Storage Allocation and Deallocation” Subclause 20.7.11, “Temporary Buffers”</td></tr><tr><td>[<a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-Meyers05" target="_blank" rel="noopener">Meyers 2005</a>]</td><td>Item 16, &quot;Use the Same Form in Corresponding Uses of <code>new</code> and <code>delete</code>&quot;</td></tr><tr><td>[<a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-Seacord2013" target="_blank" rel="noopener">Seacord 2013</a>]</td><td>Chapter 4, “Dynamic Memory Management”</td></tr><tr><td>[<a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-Viega05" target="_blank" rel="noopener">Viega 2005</a>]</td><td>“Doubly Freeing Memory”</td></tr></tbody></table></div><div class="popular-posts-header">推荐文章</div><ul class="popular-posts"><li class="popular-posts-item"><div class="popular-posts-title"><a href="/posts/2305000242/" rel="bookmark">MEM56-CPP. 不要在不相关的智能指针中存放一个已有所属的指针值</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/posts/3526747646/" rel="bookmark">MEM55-CPP. 遵守替换动态内存管理的要求</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/posts/1817611852/" rel="bookmark">MEM54-CPP. 为 placement new 提供足够内存容量的正确对齐的指针</a></div></li></ul><div class="reward-container"><div></div><button onclick='var e=document.getElementById("qr");e.style.display="none"===e.style.display?"block":"none"'>打赏</button><div id="qr" style="display:none"><div style="display:inline-block"><img src="/images/wechatpay.jpg" alt="村口最靓的 小Xu 微信支付"><p>微信支付</p></div><div style="display:inline-block"><img src="/images/alipay.jpg" alt="村口最靓的 小Xu 支付宝"><p>支付宝</p></div></div></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者： </strong>村口最靓的 小Xu</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="https://xwnb.github.io/posts/2185119777/" title="MEM51-CPP. 正确地释放动态分配的资源">https://xwnb.github.io/posts/2185119777/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class="followme"><p>欢迎关注我的其它发布渠道</p><div class="social-list"><div class="social-item"><a target="_blank" class="social-link" href="/images/wechat_channel.jpg"><span class="icon"><i class="fab fa-weixin"></i> </span><span class="label">WeChat</span></a></div><div class="social-item"><a target="_blank" class="social-link" href="/atom.xml"><span class="icon"><i class="fa fa-rss"></i> </span><span class="label">RSS</span></a></div><div class="social-item"><a target="_blank" class="social-link" href="https://blog.csdn.net/xiaowei1234565"><span class="icon"><i class="fab fa-blogger"></i> </span><span class="label">CSDN</span></a></div></div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/SEI-CERT-C/" rel="tag"><i class="fa fa-tag"></i> SEI CERT C++</a> <a href="/tags/%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/" rel="tag"><i class="fa fa-tag"></i> 编码规范</a> <a href="/tags/%E7%BF%BB%E8%AF%91/" rel="tag"><i class="fa fa-tag"></i> 翻译</a> <a href="/tags/Memory-Management/" rel="tag"><i class="fa fa-tag"></i> Memory Management</a></div><div class="post-widgets"><div class="wp_rating"><div id="wpac-rating"></div></div></div><div class="post-nav"><div class="post-nav-item"><a href="/posts/1181891836/" rel="prev" title="MEM52-CPP. 检测并处理内存分配错误"><i class="fa fa-chevron-left"></i> MEM52-CPP. 检测并处理内存分配错误</a></div><div class="post-nav-item"><a href="/posts/1419131790/" rel="next" title="MEM50-CPP. 不要访问被释放的内存">MEM50-CPP. 不要访问被释放的内存 <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><script>window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#不合规代码示例-placement-new"><span class="nav-text">不合规代码示例 (placement new())</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#合规方案-placement-new"><span class="nav-text">合规方案 (placement new())</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#不合规代码示例-Uninitialized-delete"><span class="nav-text">不合规代码示例 (Uninitialized delete)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#合规方案-Uninitialized-delete"><span class="nav-text">合规方案 (Uninitialized delete)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#不合规代码示例-Double-Free"><span class="nav-text">不合规代码示例 (Double-Free)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#合规方案-Double-Free"><span class="nav-text">合规方案 (Double-Free)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#不合规代码示例-array-new"><span class="nav-text">不合规代码示例 (array new[])</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#合规方案-array-new"><span class="nav-text">合规方案 (array new[])</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#不合规代码示例-malloc"><span class="nav-text">不合规代码示例 (malloc())</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实现细节"><span class="nav-text">实现细节</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#合规方案-malloc"><span class="nav-text">合规方案 (malloc())</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#不合规代码示例-new"><span class="nav-text">不合规代码示例 ( new )</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#合规方案-new"><span class="nav-text">合规方案 (new)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#不合规代码示例-Class-new"><span class="nav-text">不合规代码示例 (Class new)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#合规方案-class-new"><span class="nav-text">合规方案 (class new)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#不合规代码示例-std-unique-ptr"><span class="nav-text">不合规代码示例 (std::unique_ptr)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#合规方案-std-unique-ptr"><span class="nav-text">合规方案 (std::unique_ptr)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#不合规代码示例-std-shared-ptr"><span class="nav-text">不合规代码示例 (std::shared_ptr)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#合规方案-std-shared-ptr"><span class="nav-text">合规方案 (std::shared_ptr)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#风险评估"><span class="nav-text">风险评估</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Automated-Detection"><span class="nav-text">Automated Detection</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Related-Vulnerabilities"><span class="nav-text">Related Vulnerabilities</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Related-Guidelines"><span class="nav-text">Related Guidelines</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Bibliography"><span class="nav-text">Bibliography</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="村口最靓的 小Xu" src="/images/profile-picture.jpg"><p class="site-author-name" itemprop="name">村口最靓的 小Xu</p><div class="site-description" itemprop="description">个人站，学习记录、实践教程、资料收集等，哈哈哈。</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">39</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">6</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">25</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/xwnb" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;xwnb" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a> </span><span class="links-of-author-item"><a href="/www.weibo.com" title="Weibo → www.weibo.com"><i class="fab fa-weibo fa-fw"></i>Weibo</a> </span><span class="links-of-author-item"><a href="/www.google.com" title="Google → www.google.com"><i class="fab fa-google fa-fw"></i>Google</a> </span><span class="links-of-author-item"><a href="https://www.zhihu.com/" title="Zhihu → https:&#x2F;&#x2F;www.zhihu.com" rel="noopener" target="_blank"><i class="fab fa-zhihu fa-fw"></i>Zhihu</a></span></div><div class="links-of-blogroll motion-element"><div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i> Friend Links</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"><a href="https://blog.csdn.net/xiaowei1234565" title="https:&#x2F;&#x2F;blog.csdn.net&#x2F;xiaowei1234565" rel="noopener" target="_blank">CSDN</a></li><li class="links-of-blogroll-item"><a href="https://www.cnblogs.com/" title="https:&#x2F;&#x2F;www.cnblogs.com&#x2F;" rel="noopener" target="_blank">CNBLOGS</a></li><li class="links-of-blogroll-item"><a href="https://www.oschina.net/" title="https:&#x2F;&#x2F;www.oschina.net&#x2F;" rel="noopener" target="_blank">OSCHINA</a></li><li class="links-of-blogroll-item"><a href="https://www.v2ex.com/" title="https:&#x2F;&#x2F;www.v2ex.com&#x2F;" rel="noopener" target="_blank">V2EX</a></li></ul></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><img src="http://ghchart.rshah.org/xwnb" alt="xwnb's Github chart"><div class="copyright">&copy; 2018 – <span itemprop="copyrightYear">2021</span> <span class="with-love"><i class="fa fa-user-circle"></i> </span><span class="author" itemprop="copyrightHolder">村口最靓的 小Xu</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-chart-area"></i> </span><span title="站点总字数">135k</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span title="站点阅读时长">2:03</span></div><div class="busuanzi-count"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="post-meta-item" id="busuanzi_container_site_uv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-divider">|</span> <span class="post-meta-item" id="busuanzi_container_site_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer></div><script src="/lib/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script><script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script><script>!function(){var e,t,o=document.getElementsByTagName("link");if(o.length>0)for(i=0;i<o.length;i++)"canonical"==o[i].rel.toLowerCase()&&o[i].href&&(e=o[i].href);t=e?e.split(":")[0]:window.location.protocol.split(":")[0],e||(e=window.location.href),!function(){var i=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,o=e,r=document.referrer;if(!i.test(o)){var n="https"===String(t).toLowerCase()?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";r?(n+="?r="+encodeURIComponent(document.referrer),o&&(n+="&l="+o)):o&&(n+="?l="+o);var a=new Image;a.src=n}}(window)}()</script><script>if (CONFIG.page.isPost) {
    wpac_init = window.wpac_init || [];
    wpac_init.push({
      widget: 'Rating',
      id    : ,
      el    : 'wpac-rating',
      color : 'fc6423'
    });
    (function() {
      if ('WIDGETPACK_LOADED' in window) return;
      WIDGETPACK_LOADED = true;
      var mc = document.createElement('script');
      mc.type = 'text/javascript';
      mc.async = true;
      mc.src = '//embed.widgetpack.com/widget.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(mc, s.nextSibling);
    })();
  }</script><script src="/js/local-search.js"></script><script src="//cdn.jsdelivr.net/npm/quicklink@1/dist/quicklink.umd.js"></script><script>window.addEventListener('load', () => {
      quicklink({
        timeout : 3000,
        priority: true,
        ignores : [uri => uri.includes('#'),uri => uri === 'https://xwnb.github.io/posts/2185119777/',]
      });
      });</script><div id="needsharebutton-float"><span class="btn"><i class="fa fa-share-alt" aria-hidden="true"></i></span></div><script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-needmoreshare2@1/needsharebutton.min.js"></script><script>flOptions={},flOptions.iconStyle="box",flOptions.boxForm="vertical",flOptions.position="middleRight",flOptions.networks="Weibo,Wechat,Douban,QQZone,Twitter,Facebook",new needShareButton("#needsharebutton-float",flOptions)</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><div id="aplayer"></div><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script><meting-js server="netease" type="playlist" id="60498371" autoplay fixed="true" mutex="true" order="random"></meting-js></body></html><!-- rebuild by neat -->