<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Markdown语法学习笔记</title>
    <url>/posts/4176222009/</url>
    <content><![CDATA[<p><strong>Markdown</strong>是一种轻量级标记语言，创始人为约翰·格鲁伯（英语：John Gruber）。它允许人们“使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML（或者HTML）文档”。这种语言吸收了很多在电子邮件中已有的纯文本标记的特性。</p>
<a id="more"></a>
<p>由于<strong>Markdown</strong>的轻量化、易读易写特性，并且对于图片，图表、数学式都有支持，当前许多网站都广泛使用<strong>Markdown</strong>来撰写帮助文档或是用于论坛上发表消息。例如：GitHub、reddit、Diaspora、Stack Exchange、OpenStreetMap 、SourceForge等。甚至Markdown能被使用来撰写电子书。</p>
<h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><blockquote>
<h4 id="1-Markdown历史"><a href="#1-Markdown历史" class="headerlink" title="1. Markdown历史"></a><a href="#Markdown历史">1. <strong>Markdown</strong>历史</a></h4><h4 id="2-Markdown主要语法"><a href="#2-Markdown主要语法" class="headerlink" title="2. Markdown主要语法"></a><a href="#Markdown主要语法">2. <strong>Markdown</strong>主要语法</a></h4><h4 id="3-其他语法"><a href="#3-其他语法" class="headerlink" title="3. 其他语法"></a><a href="#其他语法">3. 其他语法</a></h4><h4 id="4-参考链接"><a href="#4-参考链接" class="headerlink" title="4. 参考链接"></a><a href="#参考链接">4. 参考链接</a></h4></blockquote>
<div STYLE="page-break-after: always;"></div>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><hr>
<h2 id="Markdown历史"><a href="#Markdown历史" class="headerlink" title="Markdown历史"></a><strong>Markdown</strong>历史</h2><hr>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><strong>John Gruber</strong>在2004年创造了<strong>Markdown</strong>语言，在语法上有很大一部分是跟<a href="https://zh.wikipedia.org/wiki/%E4%BA%9A%E4%BC%A6%C2%B7%E6%96%AF%E6%B2%83%E8%8C%A8" target="_blank" rel="noopener"><strong>Aaron Swartz</strong></a>共同合作的。<strong>Markdown</strong>的目标是实现「易读易写」。可读性，无论如何，都是最重要的。一份使用<strong>Markdown</strong>格式撰写的文件应该可以直接以纯文本发布，并且看起来不会像是由许多标签或是格式指令所构成。<strong>Markdown</strong>语法受到一些既有 text-to-HTML 格式的影响，包括 Setext、atx、Textile、reStructuredText、Grutatext 和 EtText，而最大灵感来源其实是纯文本电子邮件的格式。</p>
<h3 id="Aaron-Swartz-大神"><a href="#Aaron-Swartz-大神" class="headerlink" title="Aaron Swartz 大神"></a>Aaron Swartz 大神</h3><p><a href="https://zh.wikipedia.org/wiki/%E4%BA%9A%E4%BC%A6%C2%B7%E6%96%AF%E6%B2%83%E8%8C%A8" target="_blank" rel="noopener"><strong>Aaron Swartz</strong></a>（1986年11月8日－2013年1月11日）是美国计算机程序员、企业家、作家、政治活动者和互联网黑客主义者。他参与开发了RSS网上信息源发布格式、Markdown文本发布格式、知识共享组织、web.py网站开发框架，同时是社交媒体Reddit的联合创始人。</p>
<blockquote>
<ul>
<li><p><strong><em>2009年</em></strong>，他协助成立了渐进社会变革活动委员会，期以了解有效的互联网运动。  </p>
</li>
<li><p><strong><em>2010年</em></strong>，他成为哈佛大学埃德蒙·萨夫拉伦理研究中心的学者，在劳伦斯·莱斯格的领导下进行研究。他曾成立在线群组求进会——因反对禁止网络盗版法案的运动而闻名。</p>
</li>
<li><p><strong><em>2011年</em></strong>，他被麻省理工学院警署以其非法闯入的罪名逮捕：通过麻省理工学院校园网络，透过学院给予的访客账户，大规模系统性地下载JSTOR上的学术期刊。联邦检察官对他提起两项网络诈骗和十一项违反《计算机欺诈和滥用法》行为的诉讼——亚伦·斯沃茨将面临合计最高35年的刑期并处100万美元罚金、没收财产、归还失窃物品和监视居住的处罚。<br>他拒绝了联邦检察官提议其在联邦监狱服刑6个月的认罪协商。随后他被发现死在其于纽约布鲁克林区的公寓内，自缢而死。  </p>
</li>
<li><p><strong><em>2013年</em></strong>，亚伦·斯沃茨被追授入互联网名人堂。</p>
</li>
</ul>
</blockquote>
<p><img data-src="https://github.com/younghz/Markdown/raw/master/resource/Aaron_Swartz.jpg" alt="Aaron Swartz"></p>
<hr>
<h2 id="Markdown主要语法"><a href="#Markdown主要语法" class="headerlink" title="Markdown主要语法"></a><strong>Markdown</strong>主要语法</h2><hr>
<p><strong>Markdown</strong>语法主要分为如下几大部分：<br><a href="#标题"><strong>标题</strong></a><br><a href="#段落"><strong>段落</strong></a><br><a href="#字体"><strong>字体</strong></a><br><a href="#横线"><strong>横线</strong></a><br><a href="#引用区块"><strong>引用区块</strong></a><br><a href="#代码区块"><strong>代码区块</strong></a><br><a href="#列表"><strong>列表</strong></a><br><a href="#链接"><strong>链接</strong></a><br><a href="#图片"><strong>图片</strong></a><br><a href="#表格"><strong>表格</strong></a><br><a href="#反斜杠"><strong>反斜杠</strong></a><br><a href="#符号\`"><strong>符号`</strong></a>  </p>
<hr>
<h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><hr>
<h4 id="用-和-标记一级和二级标题。"><a href="#用-和-标记一级和二级标题。" class="headerlink" title="用=和-标记一级和二级标题。"></a>用<code>=</code>和<code>-</code>标记一级和二级标题。</h4><blockquote>
<p>一级标题<br><code>=========</code><br>二级标题<br><code>---------</code></p>
</blockquote>
<p>效果：</p>
<blockquote>
<h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题   "></a>一级标题   </h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2></blockquote>
<h4 id="使用-，可表示1-6级标题"><a href="#使用-，可表示1-6级标题" class="headerlink" title="使用#，可表示1-6级标题"></a>使用<code>#</code>，可表示1-6级标题</h4><blockquote>
<p><code># 一级标题</code><br><code>## 二级标题</code><br><code>### 三级标题</code><br><code>#### 四级标题</code><br><code>##### 五级标题</code><br><code>###### 六级标题</code>    </p>
</blockquote>
<p>效果：</p>
<blockquote>
<h1 id="一级标题-1"><a href="#一级标题-1" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题-1"><a href="#二级标题-1" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6></blockquote>
<hr>
<h3 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h3><p>段落的前后要有空行，所谓的空行是指没有文字内容。若想在段内强制换行的方式是使用<strong>两个以上空格加上回车</strong>。</p>
<hr>
<h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><h4 id="粗体和斜体"><a href="#粗体和斜体" class="headerlink" title="粗体和斜体"></a>粗体和斜体</h4><p>使用<code>*</code>或<code>_</code>包含需要标记为斜体或加粗的文字：  </p>
<blockquote>
<p><code>*斜体文本*</code><br><code>_斜体文本_</code><br><code>**粗体文本**</code><br><code>__粗体文本__</code><br><code>***粗斜体文本***</code><br><code>___粗斜体文本___</code>  </p>
</blockquote>
<p>效果：  </p>
<blockquote>
<p><em>斜体文本</em><br>_斜体文本_<br><strong>粗体文本</strong><br><strong>粗体文本</strong><br><strong><em>粗斜体文本</em></strong><br><strong>_粗斜体文本_</strong>  </p>
</blockquote>
<h4 id="上下标"><a href="#上下标" class="headerlink" title="上下标"></a>上下标</h4><p>使用<code>&lt;sub&gt;</code>标签：  </p>
<blockquote>
<p>上标：<code>X&lt;sub&gt;2&lt;/sub&gt;</code><br>下标：<code>O&lt;sup&gt;2&lt;/sup&gt;</code></p>
</blockquote>
<p>效果：    </p>
<blockquote>
<p>上标：X<sub>2</sub><br>下标：O<sup>2</sup></p>
</blockquote>
<hr>
<h3 id="横线"><a href="#横线" class="headerlink" title="横线"></a>横线</h3><hr>
<h4 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h4><p>在一行中用三个以上的<code>*</code>、<code>-</code>、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格（不建议加空格）：  </p>
<blockquote>
<p><code>* * *</code><br><code>***</code><br><code>*****</code><br><code>- - -</code><br><code>----------</code>  </p>
</blockquote>
<p>效果：</p>
<blockquote>
<hr>
<hr>
<hr>
<h2 id=""><a href="#" class="headerlink" title="- - -"></a>- - -</h2></blockquote>
<h4 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h4><p>在文字的两端加上两个波浪线<code>~~</code>即可:  </p>
<blockquote>
<p><code>~~Markdown删除线~~</code>  </p>
</blockquote>
<p>效果：  </p>
<blockquote>
<p><del>Markdown删除线</del></p>
</blockquote>
<h4 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h4><p>使用<code>&lt;u&gt;</code>标签：</p>
<blockquote>
<p><code>&lt;u&gt;Markdown下划线&lt;/u&gt;</code></p>
</blockquote>
<p>效果：  </p>
<blockquote>
<p><u>Markdown下划线</u></p>
</blockquote>
<hr>
<h3 id="2-5-引用区块"><a href="#2-5-引用区块" class="headerlink" title="2.5 引用区块"></a>2.5 引用区块</h3><hr>
<h4 id="行内引用"><a href="#行内引用" class="headerlink" title="行内引用"></a>行内引用</h4><p>使用符号`（Esc下面那个符号）:</p>
<blockquote>
<p>这是`行内`引用</p>
</blockquote>
<p>效果：  </p>
<blockquote>
<p>这是<code>行内</code>引用。</p>
</blockquote>
<h4 id="引用区块"><a href="#引用区块" class="headerlink" title="引用区块"></a>引用区块</h4><p>在段首使用符号<code>&gt;</code>：<br><code>&gt; **Markdown** 引用单行文本</code><br><code>&gt; **Markdown** 引用单行文本</code></p>
<p>效果：  </p>
<blockquote>
<p><strong>Markdown</strong> 引用单行文本<br><strong>Markdown</strong> 引用单行文本</p>
</blockquote>
<h4 id="嵌套引用区块"><a href="#嵌套引用区块" class="headerlink" title="嵌套引用区块"></a>嵌套引用区块</h4><p>使用多个<code>&gt;</code>完成嵌套引用：<br><code>&gt; 单行引用</code><br><code>&gt;&gt; 嵌套引用</code><br><code>&gt;&gt;&gt; 三次嵌套引用</code><br><code>&gt;&gt;&gt; 三次嵌套引用</code> </p>
<p>效果</p>
<blockquote>
<p>单行引用</p>
<blockquote>
<p>二层引用<br>二层嵌套</p>
<blockquote>
<p>三层嵌套引用<br>三层嵌套引用</p>
</blockquote>
</blockquote>
</blockquote>
<hr>
<h3 id="代码区块"><a href="#代码区块" class="headerlink" title="代码区块"></a>代码区块</h3><hr>
<p>对代码区块进缩进处理，通过<strong>每行</strong>缩进四个空格或一个制表符即可，但是没有语法高亮和行号显示。代码文本：<br><code>void main()</code><br><code>{</code><br>&emsp;&emsp;<code>printf(&quot;Hello, Markdown.&quot;);</code><br><code>}</code> </p>
<h4 id="使用空格或制表符"><a href="#使用空格或制表符" class="headerlink" title="使用空格或制表符"></a>使用空格或制表符</h4><pre><code>void main()
{
    printf(&quot;Hello, Markdown.&quot;);
}
</code></pre><h4 id="通过标签"><a href="#通过标签" class="headerlink" title="通过标签"></a>通过标签</h4><p>使用标签<code>&lt;pre&gt;&lt;/pre&gt;</code>也可以实现缩进：<br><code>&lt;pre&gt;</code><br><code>int main(int argc, int *argv[])</code><br><code>{</code><br>&emsp;&emsp;<code>printf(&quot;Hello, Markdown.&quot;);</code><br><code>}</code><br><code>&lt;/pre&gt;</code></p>
<p>效果：  </p>
<pre>
int main(int argc, int *argv[])    
{    
    printf("Hello, Markdown.");    
}   
</pre>

<h4 id="增加高亮和行号"><a href="#增加高亮和行号" class="headerlink" title="增加高亮和行号"></a>增加高亮和行号</h4><p>类似多行注释，在代码块首位各用三个符号`来处理，并指定代码语言（C语言为例）：</p>
<p>```C<br><code>int main(int argc, int *argv[])</code><br><code>{</code><br>&emsp;&emsp;<code>printf(&quot;Hello, Markdown.&quot;);</code><br><code>}</code><br>```</p>
<p>效果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">int</span> *argv[])</span>    </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello, Markdown."</span>);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><h4 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h4><p>使用<code>·</code>、<code>+</code>、或<code>-</code>任意一种标记无序列表，如：</p>
<blockquote>
<p>- 第一项<br>- 第二项<br>- 第三项  </p>
<p>+ 第一项<br>+ 第二项<br>+ 第三项  </p>
<p>* 第一项<br>* 第二项<br>* 第三项  </p>
</blockquote>
<p><strong>注意</strong>：标记后面最少有一个_空格_或_制表符_。若不在引用区块中，必须和前方段落之间存在空行。</p>
<p>效果：</p>
<blockquote>
<ul>
<li>第一项</li>
<li>第二项</li>
<li>第三项</li>
</ul>
</blockquote>
<h4 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h4><p>有序列表的标记方式是将上述的符号换成数字,并辅以<code>.</code>，如：</p>
<blockquote>
<p>&emsp;&emsp;<code>1. 第一项</code><br>&emsp;&emsp;<code>2. 第二项</code><br>&emsp;&emsp;<code>3. 第三项</code>    </p>
</blockquote>
<p>效果：</p>
<blockquote>
<ol>
<li>第一项</li>
<li>第二项</li>
<li>第三项</li>
</ol>
</blockquote>
<h4 id="列表嵌套"><a href="#列表嵌套" class="headerlink" title="列表嵌套"></a>列表嵌套</h4><p>列表嵌套只需在子列表中的选项添加四个空格或缩进TAB即可，也可在列表内进行区块引用：  </p>
<blockquote>
<p>&emsp;&emsp;<code>1. 第一项</code><br>&emsp;&emsp;&emsp;&emsp;<code>- 第一项嵌套的第一个元素</code><br>&emsp;&emsp;&emsp;&emsp;<code>- 第一项嵌套的第二个元素</code><br>&emsp;&emsp;<code>2. 第二项</code><br>&emsp;&emsp;&emsp;&emsp;<code>&gt; 第二项嵌套的第一个元素</code><br>&emsp;&emsp;&emsp;&emsp;<code>&gt; 第二项嵌套的第二个元素</code>  </p>
</blockquote>
<p>效果：  </p>
<blockquote>
<ol>
<li>第一项<ul>
<li>第一项嵌套的第一个元素</li>
<li>第一项嵌套的第二个元素</li>
</ul>
</li>
<li>第二项<blockquote>
<p>第二项第一个元素区块引用<br>第二项第二个元素区块引用</p>
</blockquote>
</li>
</ol>
</blockquote>
<h4 id="GFM-task-list"><a href="#GFM-task-list" class="headerlink" title="GFM task list"></a>GFM task list</h4><p>带选择框的选项列表：  </p>
<pre>
- [x] GFM task list 1
- [x] GFM task list 2
- [ ] GFM task list 3
    - [ ] GFM task list 3-1
    - [ ] GFM task list 3-2
    - [ ] GFM task list 3-3
- [ ] GFM task list 4
    - [ ] GFM task list 4-1
    - [ ] GFM task list 4-2
</pre>

<p>效果：  </p>
<ul>
<li>[x] GFM task list 1</li>
<li>[x] GFM task list 2</li>
<li>[ ] GFM task list 3<ul>
<li>[ ] GFM task list 3-1</li>
<li>[ ] GFM task list 3-2</li>
<li>[ ] GFM task list 3-3</li>
</ul>
</li>
<li>[ ] GFM task list 4<ul>
<li>[ ] GFM task list 4-1</li>
<li>[ ] GFM task list 4-2</li>
</ul>
</li>
</ul>
<hr>
<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>链接可以由两种形式生成：<strong>行内式</strong>和<strong>参考式</strong>。 </p>
<h4 id="行内式"><a href="#行内式" class="headerlink" title="行内式"></a>行内式</h4><p>方式为<code>[链接名称](链接地址)</code>或<code>&lt;链接地址&gt;</code></p>
<blockquote>
<p><code>这是一个链接 [github treading](https://github.com/trending)</code><br><code>这是另一个链接 &lt;https://github.com/explore&gt;</code></p>
</blockquote>
<p>效果：</p>
<blockquote>
<p>这是一个链接 <a href="https://github.com/trending" target="_blank" rel="noopener">github treading</a><br>这是另一个链接 <a href="https://github.com/explore" target="_blank" rel="noopener">https://github.com/explore</a></p>
</blockquote>
<h4 id="参考式"><a href="#参考式" class="headerlink" title="参考式"></a>参考式</h4><p>链接也可以用变量（数字或字符串）来代替：</p>
<blockquote>
<p><code>这是一个链接 [github treading][1]</code><br><code>这是另一个链接 [github explore][explore]</code><br><del><strong>(上下之间必须有空行)</strong></del><br><code>[1]:https://github.com/trending</code><br><code>[explore]:https://github.com/explore</code>  </p>
</blockquote>
<p>效果：</p>
<blockquote>
<p>这是一个链接 [github treading][1]<br>这是另一个链接 [github explore][explore]  </p>
<p>[1]:<a href="https://github.com/trending" target="_blank" rel="noopener">https://github.com/trending</a>   </p>
<p>[explore]:<a href="https://github.com/explore" target="_blank" rel="noopener">https://github.com/explore</a></p>
</blockquote>
<p><strong>注意</strong>：上述的<code>[1]:https://github.com/trending</code>不出现在区块中。</p>
<hr>
<h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><hr>
<p>添加图片的形式和链接相似，只需在链接的基础上前方加一个<code>！</code>，支持行内式和参考式。如上文<strong>Aaron Swartz</strong>的图片链接:    </p>
<blockquote>
<p><code>![Aaron Swartz](https://github.com/younghz/Markdown/raw/master/resource/Aaron_Swartz.jpg)</code>  </p>
</blockquote>
<hr>
<h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><p>使用<code>|</code>来分隔不同的单元格，使用<code>-</code>来分隔表头和其他行。使用<code>-:</code>，<code>:-</code>，<code>:-:</code>设置表格的对齐方式：</p>
<blockquote>
<p><code>| 这是左对齐 | 这是右对齐 | 这是居中对齐 |</code><br><code>| :--------- | ---------: | :----------: |</code><br><code>| 单元格     |     单元格 |    单元格    |</code><br><code>| 单元格     |     单元格 |    单元格    |</code>  </p>
</blockquote>
<p>效果：  </p>
<blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">这是左对齐</th>
<th style="text-align:right">这是右对齐</th>
<th style="text-align:center">这是居中对齐</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">单元格</td>
<td style="text-align:right">单元格</td>
<td style="text-align:center">单元格</td>
</tr>
<tr>
<td style="text-align:left">单元格</td>
<td style="text-align:right">单元格</td>
<td style="text-align:center">单元格</td>
</tr>
</tbody>
</table>
</div>
</blockquote>
<hr>
<h3 id="反斜杠"><a href="#反斜杠" class="headerlink" title="反斜杠"></a>反斜杠</h3><hr>
<p><strong>反转义</strong>，使符号成为普通符号。</p>
<pre>
\\    反斜线 
\`    反引号
\*    星号 
\_    下划线
\{\}  花括号
\[\]  方括号
\(\)  小括号
\#    井字号
\+    加号
\-    减号
\.    英文句点
\!    感叹号
\!    感叹号
</pre>

<p>效果</p>
<blockquote>
<p>\ 反斜线<br>` 反引号<br>* 星号<br>_ 下划线<br>\{\} 花括号<br>[] 方括号<br>() 小括号<br># 井字号<br>+ 加号<br>- 减号<br>. 英文句点<br>! 感叹号  </p>
</blockquote>
<hr>
<h3 id="符号"><a href="#符号" class="headerlink" title="符号`"></a>符号`</h3><hr>
<p>起到标记作用。如：</p>
<blockquote>
<p>`ctrl+a`</p>
</blockquote>
<p>效果：</p>
<blockquote>
<p><code>ctrl+a</code>    </p>
</blockquote>
<hr>
<h2 id="其他语法"><a href="#其他语法" class="headerlink" title="其他语法"></a>其他语法</h2><hr>
<p>使用两个美元符$$$$包裹<strong>TeX</strong>或<strong>LaTeX</strong>格式的数学公式来实现。</p>
<h2 id="—"><a href="#—" class="headerlink" title="—-"></a>—-</h2><p><strong>其他</strong>：关于其它扩展语法可参见具体工具的使用说明。</p>
<hr>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><hr>
<p><a href="https://www.runoob.com/markdown/md-tutorial.html" target="_blank" rel="noopener">https://www.runoob.com/markdown/md-tutorial.html</a><br><a href="https://markdown.tw" target="_blank" rel="noopener">https://markdown.tw</a><br><a href="https://github.com/younghz/Markdown" target="_blank" rel="noopener">https://github.com/younghz/Markdown</a>    </p>
<h2 id="—-1"><a href="#—-1" class="headerlink" title="—-"></a>—-</h2><p><strong><em>笔下是语法，心中格式化</em></strong></p>
<hr>
]]></content>
      <categories>
        <category>Tutorial</category>
      </categories>
      <tags>
        <tag>Tutorial</tag>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序开发-input正则</title>
    <url>/posts/1318413979/</url>
    <content><![CDATA[<p>检查 <code>input</code>输入框是否输入限制字符。如果是，则丢弃；否则，正常输入。</p>
<a id="more"></a>
<p><code>input</code> 标签具有 <code>bindinput</code> 属性，支持输入数据的双向绑定，类似 <code>Vue</code> 中的 <code>v-model</code>。</p>
<blockquote>
<p>键盘输入时触发，<code>event.detail = {value, cursor, keyCode}，keyCode</code> 为键值，2.1.0 起支持，处理函数可以直接 return 一个字符串，将替换输入框的内容。</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"digit"</span> <span class="attr">bindinput</span>=<span class="string">"regInput"</span> <span class="attr">maxlength</span>=<span class="string">"15"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>匹配正则通过则返回所有字符，不通过则去掉最后一个不匹配的字符返回。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*正则匹配*/</span></span><br><span class="line">regInput(e)&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="regexp">/^(\d?)+(\.\d&#123;0,2&#125;)?$/</span>.test(e.detail.value))&#123;</span><br><span class="line">    <span class="keyword">return</span> e.detail.value;</span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> e.detail.value.substring(<span class="number">0</span>,e.detail.value.length<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.jb51.net/article/145878.htm" target="_blank" rel="noopener">https://www.jb51.net/article/145878.htm</a></p>
]]></content>
      <categories>
        <category>微信小程序开发</category>
      </categories>
      <tags>
        <tag>wechat-dev</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序开发-布局flex</title>
    <url>/posts/208261819/</url>
    <content><![CDATA[<p>微信小程序开发-布局flex</p>
<a id="more"></a>
<h2 id="flex布局"><a href="#flex布局" class="headerlink" title="flex布局"></a><strong><code>flex</code>布局</strong></h2><p>微信小程序 <code>View</code> 支持两种布局方式：<code>Block</code> 和 <code>Flex</code><br>所有 <code>View</code> 默认都是 <code>block</code>。要使用 flex 布局的话需要显式的声明。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">"main"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">"item item1"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">"item item2"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">"item item3"</span>&gt;</span>3<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>1) 未设置 <code>flex</code>，竖向布局</strong></p>
<pre><code>1
2
3
</code></pre><p><strong>2) <code>flex</code> 布局，在样式中加入 <code>display: flex;</code></strong></p>
<pre><code>123
</code></pre><h2 id="flex-direction"><a href="#flex-direction" class="headerlink" title="flex-direction"></a><strong><code>flex-direction</code></strong></h2><h3 id="横向布局"><a href="#横向布局" class="headerlink" title="横向布局"></a>横向布局</h3><ul>
<li><p><code>flex-direction: row</code>：从左到右的水平方向为主轴  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">123</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>flex-direction: row-reverse</code>：从右到左的水平方向为主轴</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">321</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="justify-content"><a href="#justify-content" class="headerlink" title="justify-content"></a><strong><code>justify-content</code></strong></h2><p>横向的布局属性</p>
<ul>
<li><p><code>lex-start</code>：主轴起点对齐(默认值)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">123</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>flex-end</code>：主轴结束点对齐</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">123</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>center</code>：在主轴中居中对齐</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">123</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>space-between</code>：两端对齐，除了两端的子元素分别靠向两端的容器之外，其他子元素之间的间隔都相等</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1        2        3</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>space-around</code>：每个子元素之间的距离相等，两端的子元素距离容器的距离也和其它子元素之间的距离相同</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1      2      3</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="纵向布局"><a href="#纵向布局" class="headerlink" title="纵向布局"></a>纵向布局</h3><ul>
<li><code>flex-direction: column</code>：从上到下的垂直方向为主轴  </li>
<li><code>flex-direction: column-reverse</code>：从下到上的垂直方向为主轴</li>
</ul>
<h2 id="align-items"><a href="#align-items" class="headerlink" title="align-items"></a><strong><code>align-items</code></strong></h2><p>纵向布局属性：</p>
<ul>
<li><code>stretch</code> 填充整个容器(默认值)</li>
<li><code>flex-start</code> 侧轴的起点对齐 （这里我们手动设置下子 view 的高度，来看的明显一些）</li>
<li><code>flex-end</code> 侧轴的终点对齐</li>
<li><code>center</code> 在侧轴中居中对齐</li>
<li><code>baseline</code> 以子元素的第一行文字对齐</li>
</ul>
<h2 id="align-self"><a href="#align-self" class="headerlink" title="align-self"></a><strong><code>align-self</code></strong></h2><p>子 <code>View</code> 的属性 <code>align-self</code>，可以覆盖父元素的 <code>align-items</code> 属性，它有6个值可选：<code>auto | flex-start | flex-end | center | baseline | stretch</code> （ <code>auto</code> 为继承父元素 <code>align-items</code> 属性，其他和 <code>align-items</code> 一致）</p>
<h2 id="flex-wrap"><a href="#flex-wrap" class="headerlink" title="flex-wrap"></a><strong><code>flex-wrap</code></strong></h2><p>用于控制子 <code>View</code> 是否换行</p>
<ul>
<li><code>nowrap</code> ：不换行（默认）</li>
<li><code>wrap</code> ：换行</li>
<li><code>wrap-reverse</code> ：换行，第一行在最下面</li>
</ul>
<h2 id="order"><a href="#order" class="headerlink" title="order"></a><strong><code>order</code></strong></h2><p>控制子元素的排列顺序，默认为<code>0</code>。<br>把 <code>item3</code> 设置 <code>order:-1;</code> 可以把 <code>item3</code> 排在前面<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">312</span><br></pre></td></tr></table></figure></p>
<h2 id="flex-grow"><a href="#flex-grow" class="headerlink" title="flex-grow"></a><strong><code>flex-grow</code></strong></h2><p><code>.wxss</code>中修改代码如下：在 <code>item1</code> 中增加： <code>flex-grow: 1</code>，在 <code>item3</code> 中增加： <code>flex-grow: 2``，表示在一行中如果有剩余空间的话，item3</code> 之外的子 <code>view</code> 占1份空间，而 <code>item3</code> 子 <code>view</code> 占2份空间(可以理解为剩余空间 <code>item3</code> 最多可以占2份空间)。</p>
<h2 id="flex-shrink"><a href="#flex-shrink" class="headerlink" title="flex-shrink"></a><strong><code>flex-shrink</code></strong></h2><p><code>.wxss</code>中再增加4个子 <code>view</code> 并修改代码如下：<code>i3</code> 的<code>flex-shrink: 0</code>，其余子 <code>view</code> 为 <code>flex-shrink: 1</code>，这表示当空间不足时所有子 <code>view</code> 都等比缩小，但是 <code>i3</code> 的 <code>view</code> 保持大小不变.</p>
<h2 id="flex-basis"><a href="#flex-basis" class="headerlink" title="flex-basis"></a><strong><code>flex-basis</code></strong></h2><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a><strong>注意</strong></h2><p><code>flex</code> 是 <code>grow</code> ，<code>shrink</code> ，<code>basis</code> 几个属性的合并<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attribute">flex</span>: grow shrink basis</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><code>flex-flow</code> 是 <code>flex-direction</code> 和 <code>flex-wrap</code> 两个属性的组合<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attribute">flex-flow</span>: wrap row</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>微信小程序开发</category>
      </categories>
      <tags>
        <tag>wechat-dev</tag>
      </tags>
  </entry>
  <entry>
    <title>路径规划-RRT</title>
    <url>/posts/2955947163/</url>
    <content><![CDATA[<h1 id="路径规划之-Rapidly-Exploring-Random-Trees-快速扩展随机树"><a href="#路径规划之-Rapidly-Exploring-Random-Trees-快速扩展随机树" class="headerlink" title="路径规划之 Rapidly-Exploring Random Trees (快速扩展随机树)"></a>路径规划之 Rapidly-Exploring Random Trees (快速扩展随机树)</h1><p>RRTs 作为一种 single-query 的规划算法被引入，它有效地覆盖了 q~init~ 和 q~goal~ 之间的空间。该规划器最初也是为 kinodynamic 运动规划而开发的，就像在 ESTs 中一样，只构建一棵树。RRTs 的适用范围超出了 kinodynamic 规划问题。RRT 算法已被证明是概率完备的。</p>
<a id="more"></a>
<p><img data-src="rrt.gif" alt="rrt.gif"></p>
<h2 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h2><p>$T$表示一颗树。 $T_{init}$ 和 $T_{goal}$ 根节分别为 $q_{init}$ 和 $q_{goal}$ 的树。每棵树$T$都是增量扩展的。在每次迭代中，在 $Q_{free}$ 中随机均匀采样一点 $q_{rand}$ 。在$T$中找到距离 $q_{rand}$ 最近的节点 $q_{near}$ ，并尝试从 $q_{near}$ 向 $q_{rand}$ 方向移动一段距离 $step_size$ ，生成一个新节点 $q_{new}$ 。若该节点是无碰撞的(collision-free)，则添加节点 $q_{new}$ 到 $T$ 的顶点集合(vertices)中，添加 $(q_{near}, q_{new})$ 到 $T$ 的边集合(edges)中。下图展示了 RRT 在二维欧式空间扩展一个点的过程。</p>
<p><img data-src="algorithm_rrt_extension.png" alt="Figure 7.14"></p>
<h3 id="伪码"><a href="#伪码" class="headerlink" title="伪码"></a>伪码</h3><p><img data-src="algorithm_rrt.png" alt="Algorithms RRT"></p>
<h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><ol>
<li>初始化随机树，树结点和边只包含起点 $q_{start}$（根节点）。边和书中有一点区别，因为这里的节点用了一个链表结构，这里每个扩展节点 ($q_{new}$) 包含有一个后向指针，指向源节点 ($q_{near}$)，所以不需要单独定义边。只要构造出树，最后反向遍历即可完成路径的构造。</li>
<li>起始点 start 加入到树节点和边中</li>
<li>开始迭代</li>
<li><code>GenerateRandomNode()</code>: 在状态空间（机械臂的关节空间或者笛卡尔空间；小车可达的二维地图空间）中随机采样一个点 $q_{rand}$ 。为加快 RRT 到达目标点 $q_{goal}$ 的速度，在随机采样过程中，加随机的概率 p 来决定，此次扩展的目标点 $q_{goal}$ 是随机点还是目标点 $q_{goal}$ 。当 $0\ltp prob$ 时，取随机采样点；否则取目标点 $q_{goal}$ 。这个概率不宜过大，否则容易陷入障碍物包围圈中不容易跳出。</li>
<li><code>FindNearestNode(qrand)</code>: 遍历 RRT 树节点，返回距离 $q_{rand}$ 最近的一个节点 $q_{near}$</li>
<li><code>ExtendTree(qnear, qrand)</code>: 沿着 $(q_{near}, q_{rand})$ 方向，以一定的步长 $step_size$ 扩展一个新节点 $q_{new}$, 如果扩展不成功（超出地图范围），返回 None，放弃这次扩展。</li>
<li><code>CollsionFree(qnear, qnew)</code>: 对 $(q_{near}, q_{new})$ 路径进行碰撞检查，包括路径过程中及起始点是否有障碍物。这里采用等间距采样，检查路径中位置点所处网格是否包络障碍物。如果发生碰撞，则放弃扩展。</li>
<li>如果新节点 $q_{new}$ 被接受（新节点不为<code>None</code>且与 $(q_{near}, q_{new})$ 之间的路径无碰撞），则将该点加入到树中，并将该节点的后向指针 $q_{new}.parent$ 指向 $q_{near}$ 。这样，在找到目标点时，根据该指针，可遍历得到完整的路径。为了防止树节点过多，可以再检查$q_{new}$是否与树中某个节点过于接近（一般取小于扩展步长），如果是，则也可以放弃此次扩展。但是这也会导致算法时间增长，毕竟要遍历树节点计算距离。</li>
<li><code>IsArrival(qnew)</code>: 检查是否到达目标点 $q_{goal}$ , 如果新节点 $q_{new}$ 距离目标点 $q_{goal}$ 小于扩展步长 $step_size$ ，且无碰撞，则认为找到，将目标点 $q_{goal}$ 作为树的最后一个节点添加到 RRT 树中。</li>
<li><code>FindPath()</code>: 根据目标节点 $q_{goal}$ 的反向指针，遍历至起点 $q_{start}$ ，即完成路径的构造。</li>
<li><code>SmoothPath(path)</code>: 上一步的路径是按照步长一个节点一个节点扩展的，因此这里可以对路径进行圆滑，遍历路径的节点，取最长不碰撞的节点构造新路径。</li>
</ol>
<h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, pos=[<span class="number">0</span>, <span class="number">0</span>])</span>:</span></span><br><span class="line">        self.pos = pos</span><br><span class="line">        self.parent = <span class="literal">None</span></span><br></pre></td></tr></table></figure>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">map_path: 地图图片路径</span></span><br><span class="line"><span class="string">qstart: 起点坐标 [row, col]</span></span><br><span class="line"><span class="string">qgoal: 目标点坐标 [row, col]</span></span><br><span class="line"><span class="string">grid_size: 网格大小（用来碰撞检测）</span></span><br><span class="line"><span class="string">step_size: 扩展步长</span></span><br><span class="line"><span class="string">max_steps: 最大扩展节点数</span></span><br><span class="line"><span class="string">goal_prob: 增加趋向目标点概率（贪婪）</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">rrt = RRT(map_path, qstart, qgoal, grid_size,</span><br><span class="line">          step_size, max_steps, goal_prob)</span><br></pre></td></tr></table></figure>
<h3 id="Planning"><a href="#Planning" class="headerlink" title="Planning"></a>Planning</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Planning</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    rrt planning</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    self.AddVertices(self.qstart)</span><br><span class="line">    self.AddEdges(<span class="literal">None</span>, self.qstart)</span><br><span class="line"></span><br><span class="line">    k = <span class="number">-1</span></span><br><span class="line">    <span class="keyword">while</span> k &lt; self.max_steps:</span><br><span class="line">        k += <span class="number">1</span></span><br><span class="line">        qrand = self.GenerateRandomNode()</span><br><span class="line">        _, qnear = self.FindNearestNode(qrand)</span><br><span class="line">        qnew = self.ExtendTree(qnear, qrand)</span><br><span class="line">        <span class="keyword">if</span> qnew <span class="keyword">and</span> self.CollsionFree(qnear, qnew):</span><br><span class="line">            self.AddVertices(qnew)</span><br><span class="line">            self.AddEdges(qnear, qnew)</span><br><span class="line"></span><br><span class="line">            self.DrawEdges(qnear, qnew)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.IsArrival(qnew):</span><br><span class="line">                print(<span class="string">"Found"</span>)</span><br><span class="line">                self.AddVertices(self.qgoal)</span><br><span class="line">                self.AddEdges(qnew, self.qgoal)</span><br><span class="line"></span><br><span class="line">                path = self.FindPath()</span><br><span class="line">                self.DrawPath(path)</span><br><span class="line">                smooth_path = self.SmoothPath(path)</span><br><span class="line">                self.DrawPath(smooth_path)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    print(<span class="string">'Not Found'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>路径规划</category>
      </categories>
      <tags>
        <tag>路径规划</tag>
        <tag>motion planning</tag>
        <tag>RRT</tag>
      </tags>
  </entry>
  <entry>
    <title>路径规划-A_Star</title>
    <url>/posts/1627378678/</url>
    <content><![CDATA[<h1 id="路径规划之-A-Star-A"><a href="#路径规划之-A-Star-A" class="headerlink" title="路径规划之 A_Star (A*)"></a>路径规划之 A_Star (A*)</h1><p>A*算法是一种基于启发式搜索的算法，该算法综合了 BFS(最佳优先搜索)和 Dijkstra 算法的优点：在进行启发式搜索提高算法效率的同时，可以保证找到一条最优路径。</p>
<a id="more"></a>
<p><img data-src="a_star.gif" alt="a_star.gif"></p>
<h2 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h2><p>A*算法扩展路径时，在主循环的每次迭代中，基于路当前节点到起点的成本以及将路径一直扩展到目标所需的估计成本来执行此操作。即选择最小化路径:</p>
<blockquote>
<p>$f(n)=g(n)+h(n)$</p>
</blockquote>
<p>随着路径的扩展，以扩展到的但未计算的节点放入列表 $open_table$ , 完成计算的节点放入列表 $close_table$。算法每次从 $open_table$ 中选择 $f(n)$ 最小的节点作为当前节点开始扩展。一直到找到目标点或者达到最大搜索次数而终止。</p>
<p>该公式包含有一下特征：</p>
<blockquote>
<p>如果$g(n)=0$, 即只计算当前节点<code>n</code>到目标节点<code>goal</code>的估计函数$h(n)$, 而不计算起点<code>start</code>到当前节点<code>n</code>的距离，算法转换为使用贪心策略的最佳优先搜索(BFS), 搜索速度提高，但是路径不是最优的<br>如果$h(n)$不大于当前节点<code>n</code>到目标节点<code>goal</code>的实际距离，则一定能得到最优解， 且$h(n)$越小，需要计算的节点越多，算法速度降低。<br>如果$h(n)=0$, 即只需求出起点<code>start</code>到当前节点<code>n</code>的最短路径$g(n)$，而不计算任何评估函数$h(n)$，则转化为单源最短路径问题，即 Dijkstra 算法，此时需要计算最多的顶点.</p>
</blockquote>
<p>其中：</p>
<blockquote>
<p>$f(n)$: 目标函数, 规划过程即最小化 f(n)；<br>$g(n)$: 起点$start$到当前节点$n$的实际距离；<br>$h(n)$: 启发函数, 当前节点$n$到终点$goal$的估计距离；<br>$open_table$: 记录需要搜寻过的节点列表<br>$close_table$: 记录已经被搜寻过的节点列表</p>
</blockquote>
<p>常用的启发函数$h(n)$一般有:</p>
<ul>
<li><p>曼哈顿距离:</p>
<blockquote>
<p>$d_{mahattan}=|p1.x-p2.x|+|p1.y-p2.y|$</p>
</blockquote>
</li>
<li><p>切比雪夫距离:</p>
<blockquote>
<p>$d_{chebyshev}=max(|p1.x-p2.x|,|p1.y-p2.y|)$</p>
</blockquote>
</li>
<li><p>欧式距离:</p>
<blockquote>
<p>$d_{euclidean}=\sqrt{(p1.x-p2.x)^2+(p1.y-p2.y)^2}$</p>
</blockquote>
</li>
<li><p>对角距离:</p>
<blockquote>
<p>$d_{diagonal}=(|p1.x-p2.x|+|p1.y-p2.y|)+\sqrt{2}-2\times min(|p1.x-p2.x|,|p1.y-p2.y|)$</p>
</blockquote>
</li>
</ul>
<h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><ul>
<li><p>初始化<code>A_STAR.__init__</code>: 初始化地图，对地图图片二值化处理，网格节点划分，若网格内包含障碍物，则该网格节点标记为障碍物: <code>Node.is_obs = True</code></p>
</li>
<li><p>输入需要随机产生的障碍物网格个数(可选);</p>
</li>
<li><p>计算起点<code>qstart</code>的$h$,$g$,$f$值,这里选择 $h=d_{mahattan}$, $g=d_{diagonal}$计算.将节点放入<code>open_table</code></p>
</li>
<li><p>开始迭代, 若迭代次数达到上限或者<code>open_table</code>为空, 则退出迭代：</p>
<ul>
<li><p>从<code>open_table</code>列表中选择<code>f</code>值最小的节点作为当前节点,记为<code>best_node</code></p>
</li>
<li><p>若<code>best_node</code>为目标节点<code>goal</code>, 即找到目标, 遍历<code>best_node</code>的父节点链表并逆序, 得到完整路径, 退出算法. 否则继续下一步:</p>
</li>
<li><p>将<code>best_node</code>从<code>open_table</code>列表弹出, 并放入<code>close_table</code>列表中.</p>
</li>
<li><p>搜索<code>best_node</code>的 8 个邻接节点<code>Neighbors</code>,对其中每个邻接节点<code>neighbor</code>:</p>
<ul>
<li><p>若该<code>neighbor</code>在<code>close_table</code>中,或者不可达, 则跳过该<code>neighbor</code>,检查下一个邻接节点, 否则继续下一步:</p>
</li>
<li><p>计算该<code>neighbor</code>的新<code>g</code>值(<code>tentative_g</code>), 即为当前节点<code>best_node</code>的<code>g</code>值加上, 当前节点<code>best_node</code>到该邻接节点<code>neighbor</code>的实际距离:<br><code>tentative_g = best_node.g + Distance(best_node, neighbor)</code></p>
</li>
<li><p>若该<code>neighbor</code>不在<code>open_table</code>中, 计算该<code>neighbor</code>的<code>g</code>, <code>h</code>, <code>f</code>值, 并放入<code>open_table</code>中</p>
</li>
<li><p>若该<code>neighbor</code>在<code>open_table</code>中:</p>
<ul>
<li><p>若该邻接节点<code>neighbor</code>新的<code>tentative_g</code>值比已有的<code>g</code>值小, 意味着当前节点<code>best_node</code>通过该<code>neighbor</code>可以更快的到达终点.</p>
</li>
<li><p>更新该<code>neighbor</code>节点的<code>g</code>值为<code>tentative_g</code>,并更新<code>f</code>值</p>
</li>
<li><p>更新该该<code>neighbor</code>节点的父节点为当前节点<code>best_node</code>.</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, pos)</span>:</span></span><br><span class="line">        self.pos = pos          <span class="comment"># 当前节点的位置坐标</span></span><br><span class="line">        self.g = float(<span class="string">'inf'</span>)   <span class="comment"># 当前节点的g(n),g_score</span></span><br><span class="line">        self.h = float(<span class="string">'inf'</span>)   <span class="comment"># 当前节点的的h(n),h_score</span></span><br><span class="line">        self.f = float(<span class="string">'inf'</span>)   <span class="comment"># 当前节点的的f(n), f_score</span></span><br><span class="line">        self.p = <span class="literal">None</span>           <span class="comment"># 当前节点的父节点</span></span><br><span class="line">        self.is_obs = <span class="literal">False</span>     <span class="comment"># 当前节点是否是障碍物</span></span><br></pre></td></tr></table></figure>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">map_path:   地图图片路径</span></span><br><span class="line"><span class="string">qstart:     起点坐标 [row, col]</span></span><br><span class="line"><span class="string">qgoal:      目标点坐标 [row, col]</span></span><br><span class="line"><span class="string">grid_size:  网格大小（用来碰撞检测）</span></span><br><span class="line"><span class="string">max_steps:  最大扩展节点数</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">a_star = A_STAR(map_path, qstart, qgoal, grid_size, max_steps)</span><br></pre></td></tr></table></figure>
<h3 id="Planning"><a href="#Planning" class="headerlink" title="Planning"></a>Planning</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Planning</span><span class="params">(self)</span>:</span></span><br><span class="line"></span><br><span class="line">    color_close = (random.randint(<span class="number">0</span>, <span class="number">255</span>),</span><br><span class="line">                   random.randint(<span class="number">0</span>, <span class="number">255</span>),</span><br><span class="line">                   random.randint(<span class="number">0</span>, <span class="number">255</span>))</span><br><span class="line"></span><br><span class="line">    color_open = (random.randint(<span class="number">0</span>, <span class="number">255</span>),</span><br><span class="line">                  random.randint(<span class="number">0</span>, <span class="number">255</span>),</span><br><span class="line">                  random.randint(<span class="number">0</span>, <span class="number">255</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># input numbers of obstacle grid if necessary</span></span><br><span class="line">    num = input(<span class="string">"input obstacle numbers: "</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        input_num = eval(num)</span><br><span class="line">        <span class="keyword">if</span> type(input_num) == int:</span><br><span class="line">            obstacle_set = self.AddObstacle(input_num)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># init qstart node</span></span><br><span class="line">    self.qstart.g = <span class="number">0</span></span><br><span class="line">    self.qstart.h = self.HScore(self.qstart)</span><br><span class="line">    self.qstart.f = self.FScore(self.qstart)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># init open_table and close_table</span></span><br><span class="line">    self.open_table = set()</span><br><span class="line">    self.close_table = set()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># add start node into open_table</span></span><br><span class="line">    self.open_table.add(self.qstart)</span><br><span class="line"></span><br><span class="line">    k = <span class="number">-1</span></span><br><span class="line">    <span class="keyword">while</span> k &lt; self.max_steps <span class="keyword">or</span> len(self.open_table) != <span class="number">0</span>:</span><br><span class="line"></span><br><span class="line">        <span class="comment"># get the node in open_table having the lowest f_score value</span></span><br><span class="line">        best_node = min(self.open_table, key=<span class="keyword">lambda</span> node: node.f)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># reach the goal node</span></span><br><span class="line">        <span class="keyword">if</span> best_node.pos == self.qgoal.pos:</span><br><span class="line">            print(<span class="string">"Found"</span>)</span><br><span class="line">            self.FindPath()</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># remove the best node in open table and add it into close table</span></span><br><span class="line">        self.open_table.remove(best_node)</span><br><span class="line">        self.close_table.add(best_node)</span><br><span class="line">        self.DrawGrid(best_node.pos, color_close)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># traversal the neighbors of best node</span></span><br><span class="line">        <span class="keyword">for</span> neighbor <span class="keyword">in</span> self.Neighbors(best_node):</span><br><span class="line"></span><br><span class="line">            <span class="comment"># if neighbor is in close table or is collision, skip</span></span><br><span class="line">            <span class="keyword">if</span> neighbor <span class="keyword">in</span> self.close_table <span class="keyword">or</span> self.CollisionFree(best_node, neighbor) == <span class="literal">False</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># calculate the tentative_g which is the distance from start to the neighbor through best_node</span></span><br><span class="line">            tentative_g = self.GScore(best_node, neighbor)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># check the neighbor is in open table or not</span></span><br><span class="line">            <span class="keyword">if</span> neighbor <span class="keyword">not</span> <span class="keyword">in</span> self.open_table:</span><br><span class="line">                <span class="comment"># if neighbor not in open table,</span></span><br><span class="line">                <span class="comment"># then calculate the g, h, f values and add it into open table</span></span><br><span class="line">                neighbor.g = tentative_g</span><br><span class="line">                neighbor.h = self.HScore(neighbor)</span><br><span class="line">                neighbor.f = self.FScore(neighbor)</span><br><span class="line">                neighbor.p = best_node</span><br><span class="line">                self.open_table.add(neighbor)</span><br><span class="line">                self.DrawGrid(neighbor.pos, color_open)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># if neighbor in open table,</span></span><br><span class="line">                <span class="comment"># then compare the tentative_g and neighbor.g</span></span><br><span class="line">                <span class="keyword">if</span> tentative_g &lt; neighbor.g:</span><br><span class="line">                    <span class="comment"># the path from best_node to neighbor is better than previous</span></span><br><span class="line">                    neighbor.g = tentative_g</span><br><span class="line">                    neighbor.f = self.FScore(neighbor)</span><br><span class="line">                    neighbor.p = best_node</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"Not Found"</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>路径规划</category>
      </categories>
      <tags>
        <tag>路径规划</tag>
        <tag>motion planning</tag>
        <tag>A*</tag>
      </tags>
  </entry>
  <entry>
    <title>路径规划-LPA_Star</title>
    <url>/posts/367356294/</url>
    <content><![CDATA[<h1 id="路径规划之-LPA-Star-LPA"><a href="#路径规划之-LPA-Star-LPA" class="headerlink" title="路径规划之 LPA_Star (LPA*)"></a>路径规划之 LPA_Star (LPA*)</h1><p>LPA*是 A*的增量版本. 相比于 A*算法, 首次规划时, 两者过程类似. 假如地图发生变化, A*算法需要重新规划路径. 而 LPA*算法可以通过在当前搜索期间内更新前一次搜索的 g 值（距起始距离）来适应地图变化而无需重新计算整个地图。</p>
<a id="more"></a>
<p><img data-src="lpa_star.gif" alt="lpa_star.gif"></p>
<h2 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h2><p>局部连续（Locally Consistent）：$g(s)=rhs(s)$。当所有节点均为局部连续状态时，g(s)的值等于 s 到起始点的最短距离（注意，反向不成立）。这个概念很重要，当上述条件满足时，我们可以找到任意一点 u 到起始点的最短路径，假设当前位置为 s,父辈节点 s’(向着起始点前进的下一个节点)通过最小化(g(s’)+c(s,s’))来获得，不断重复直到到达 sStart。然而，LPA*并不需要使所有节点均为局部连续状态，它通过启发式搜索将关注点放在搜索上，并且只更新那些与计算最短路径相关的节点的 g 值。</p>
<p>局部过连续（Locally Overconsistent）：$g(s)&gt;rhs(s)$。当优先队列 U 中取出的节点为局部过连续状态时，意味着 g(s)可以通过父辈节点使自己到起点的路径更短，此时将设置 g(s)=rhs(s)，节点状态变为局部连续状态。</p>
<p>局部欠连续(Locally Underconsistent)：$g(s)&lt;rhs(s)$。这种情况通常出现在父辈的某一节点突然变为障碍的情况下，造成父辈节点到起点的路径变大，从而需要修改 g(s)的值，如果节点处于这种状态，则当它由优先队列中取出时，将其 g 值设置为无穷大，即将该节点状态变为局部过连续，而局部过连续的点将会被再次添加到优先队列中，这样就可以在它下次被取出时将其作为局部过连续状态处理，最终达到局部连续状态（如果这一节点与我们要搜索的最短路径相关的话）。</p>
<p>LPA*维持着每个节点的到起点的估计距离: <a href="algorithm_lpa_star_g.png">$g(s)$</a> 首次搜索时, $g(s)$ 的计算方式和 A*相同, 并将这个值带到下次搜索过程中.<br><img data-src="algorithm_lpa_star_g.png" alt="algorithm_lpa_star_g"></p>
<p>此外 LPA*还维护着一个基于 $g(s)$ 的前瞻估计距离: <a href="algorithm_lpa_star_rhs.png">$rhs(s)$</a>.<br><img data-src="algorithm_lpa_star_rhs.png" alt="algorithm_lpa_star_rhs"></p>
<p>A*算法维护着 OPEN 和 CLOSED 列表来避免节点被重复搜索. LPA*通过检查局部一致性来避免节点重复搜索, 不需要维护 COLSED 列表. OPEN 列表是一个优先队列, 使得 A*可以通过队列中具有最小 $f(s)$ 值的节点来进行边的扩展. LPA*也维持着一个只包含局部欠一致(locally inconsistent)节点的优先队列. 优先队列根据节点的 keys 值排列(相当于 A*的 $f(s)$ 值排列). 该 keys 是一个二维变量:</p>
<blockquote>
<p>$k(s)=[k1(s),k2(s)]$</p>
</blockquote>
<p>其中:</p>
<blockquote>
<p>$k1(s)=min(g(s),rhs(s)+h(s))$, 相当于 A*的$f(s)$ &gt; $k2(s)=min(g(s),rhs(s))$, 相当于 A*的$g(s)$</p>
</blockquote>
<p>定义: $k(s1) \leq (s2)$ 为 $k1(s1) \leq k1(s2)$ 或者 $(k1(s1)=k1(s2) \text{ and }k2(s1) \leq k2(s2))$</p>
<h3 id="伪码"><a href="#伪码" class="headerlink" title="伪码"></a>伪码</h3><p>算法伪码如下图所示 <a href="algorithm_lpa_star.png">Algorithms LAP*</a><br><img data-src="algorithm_lpa_star.png" alt="3"></p>
<h3 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h3><p><a href="algorithm_lpa_star_first_search.png">第一次搜索</a><br><img data-src="algorithm_lpa_star_first_search.png" alt="4"></p>
<p><a href="algorithm_lpa_star_secord_search.png">第二次搜索</a><br><img data-src="algorithm_lpa_star_secord_search.png" alt="5"></p>
<h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><ul>
<li><p>初始化<code>LPA_STAR.__init__</code>: 初始化地图，对地图图片二值化处理，网格节点划分，若网格内包含障碍物，则该网格节点标记为障碍物: <code>Node.is_obs = True</code></p>
</li>
<li><p>输入需要随机产生的障碍物网格个数(可选);</p>
</li>
<li><p><code>Initialize()</code>: 初始化所有节点的$g(s)=\infin$, $rhs(s)=\infin$, 实际实现中，不需要初始化所有节点，只需要在遇到一个新节点时初始化该节点. 起点$s_{start}$是一个局部欠一致节点, 计算$keys(s_{start})$, 并将节点$s_{start}$放入优先队列中.</p>
</li>
<li><p>初始化<code>Initialize()</code>保证了首次调用<code>ComputeShortestPath()</code>是一个 A*算法。</p>
</li>
<li><p>等待地图更新， 这里通过用户输入障碍物网格数来模拟地图更新。</p>
</li>
<li><p>地图更新时，导致节点之间的距离<code>DistanceCost</code>发生变化, 调用<code>UpdateVertex(s)</code>更新受影响节点参数<code>rhs</code>和<code>keys</code>。这也这些节点和优先队列之间的联系也发生变化，可能成为局部一致或者局部不一致状态。</p>
</li>
<li><p>重新调用<code>ComputeShortestPath()</code>来根据优先队列顺序展开局部不一致的节点。</p>
<ul>
<li><p>如果展开的节点处于局部过一致(<code>locally overconsistent</code>)状态, 即$g(s)&gt;rhs(s)$, 那么将该节点设置为局部一致(<code>locally consistent</code>), 即$g(s)=rhs(s)$。</p>
</li>
<li><p>如果展开的节点处于局部欠一致(<code>locally underconsistent</code>)状态，即$g(s)&lt;rhs(s)$, 那么将该节点的<code>g</code>值设置为无穷大， 即$g(s)=\infin$</p>
</li>
<li><p>上述两种情况中受该展开节点的<code>g</code>值变化会影响后置节点，所以还需要更新受其影响的节点，调用<code>UpdateVertex(s)</code>来更新。</p>
</li>
</ul>
</li>
<li><p>LPA*扩展停止条件为：目标节点$s_{goal}$处于局部一致并且下一个待展开的节点<code>keys</code>值不小于$s_{goal}$的<code>keys</code>值。若搜索结束之后目标节点$s_{goal}$的<code>g</code>值为无穷大，那路径不存在。</p>
</li>
<li><p>将目标节点$s_{goal}$的后置链表反转即可得到$s_{start}$到$s_{goal}$的路径</p>
</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, pos)</span>:</span></span><br><span class="line">        self.pos = pos          <span class="comment"># 当前节点的位置坐标</span></span><br><span class="line">        self.g = float(<span class="string">'inf'</span>)   <span class="comment"># 当前节点的g(s),g_score</span></span><br><span class="line">        self.h = float(<span class="string">'inf'</span>)   <span class="comment"># 当前节点的的h(s),h_score</span></span><br><span class="line">        self.rhs = float(<span class="string">'inf'</span>) <span class="comment"># rhs(s)</span></span><br><span class="line">        self.keys = [float(<span class="string">'inf'</span>), float(<span class="string">'inf'</span>)]    <span class="comment"># 优先队列keys(s)值</span></span><br><span class="line">        self.p = <span class="literal">None</span>           <span class="comment"># 当前节点的父节点</span></span><br><span class="line">        self.is_obs = <span class="literal">False</span>     <span class="comment"># 当前节点是否是障碍物</span></span><br></pre></td></tr></table></figure>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">map_path:   地图图片路径</span></span><br><span class="line"><span class="string">qstart:     起点坐标 [row, col]</span></span><br><span class="line"><span class="string">qgoal:      目标点坐标 [row, col]</span></span><br><span class="line"><span class="string">grid_size:  网格大小（用来碰撞检测）</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">lpa_star = LPA_STAR(map_path, qstart, qgoal, grid_size)</span><br></pre></td></tr></table></figure>
<h3 id="Planning"><a href="#Planning" class="headerlink" title="Planning"></a>Planning</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">CalculateKey</span><span class="params">(self, s)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    the priority queue ordered by k1(f_score used in A*), then k2</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    key2 = min([s.g, s.rhs])</span><br><span class="line">    <span class="keyword">return</span> [key2 + s.h, key2]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Initialize</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    init</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    self.U = []</span><br><span class="line">    self.qstart.rhs = <span class="number">0</span></span><br><span class="line">    self.qstart.keys = [self.qstart.h, <span class="number">0</span>]</span><br><span class="line">    self.U.append(self.qstart)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">UpdateVertex</span><span class="params">(self, u)</span>:</span></span><br><span class="line">    <span class="comment"># u = copy.deepcopy(u)</span></span><br><span class="line">    <span class="keyword">if</span> u.pos != self.qstart.pos:</span><br><span class="line">        new_rhs = float(<span class="string">'inf'</span>)</span><br><span class="line">        <span class="comment"># predessors = self.Predessors(u)</span></span><br><span class="line">        predessors = self.SuccessorsCollisionFree(u)</span><br><span class="line">        <span class="keyword">for</span> pred <span class="keyword">in</span> predessors:</span><br><span class="line">            tmp_rhs = pred.g + self.DistanceCost(pred, u)</span><br><span class="line">            <span class="keyword">if</span> tmp_rhs &lt; new_rhs:</span><br><span class="line">                new_rhs = tmp_rhs</span><br><span class="line">                u.p = pred</span><br><span class="line">        u.rhs = new_rhs</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> node_index, node <span class="keyword">in</span> enumerate(self.U):</span><br><span class="line">        <span class="keyword">if</span> node.pos == u.pos:</span><br><span class="line">            self.U.pop(node_index)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> u.g != u.rhs:</span><br><span class="line">        u.keys = self.CalculateKey(u)</span><br><span class="line">        self.UInsert(u)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ComputeShortestPath</span><span class="params">(self)</span>:</span></span><br><span class="line"></span><br><span class="line">    color_close = (random.randint(<span class="number">0</span>, <span class="number">255</span>),</span><br><span class="line">                   random.randint(<span class="number">0</span>, <span class="number">255</span>),</span><br><span class="line">                   random.randint(<span class="number">0</span>, <span class="number">255</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (len(self.U) != <span class="number">0</span>) <span class="keyword">and</span> ((self.TopKey() &lt; self.CalculateKey(self.qgoal)) <span class="keyword">or</span> (self.qgoal.rhs != self.qgoal.g)):</span><br><span class="line"></span><br><span class="line">        u = self.U.pop(<span class="number">0</span>)</span><br><span class="line">        self.DrawGrid(u.pos, color_close)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> u.g &gt; u.rhs:</span><br><span class="line">            u.g = u.rhs</span><br><span class="line">            successors = self.SuccessorsCollisionFree(u)</span><br><span class="line">            <span class="keyword">for</span> succ <span class="keyword">in</span> successors:</span><br><span class="line">                self.UpdateVertex(succ)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            u.g = float(<span class="string">'inf'</span>)</span><br><span class="line">            self.UpdateVertex(u)</span><br><span class="line">            successors = self.SuccessorsCollisionFree(u)</span><br><span class="line">            <span class="keyword">for</span> succ <span class="keyword">in</span> successors:</span><br><span class="line">                self.UpdateVertex(succ)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> self.qgoal.rhs == self.qgoal.g <span class="keyword">and</span> self.qgoal.rhs != float(<span class="string">'inf'</span>):</span><br><span class="line">        self.FindPath()</span><br><span class="line">        print(<span class="string">'Found Path'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">'Not Found Path'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Planning</span><span class="params">(self)</span>:</span></span><br><span class="line"></span><br><span class="line">    num = input(<span class="string">"input obstacle numbers: "</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        input_num = eval(num)</span><br><span class="line">        <span class="keyword">if</span> type(input_num) == int:</span><br><span class="line">            self.AddObstacle(input_num)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> self.ComputeShortestPath() == <span class="literal">False</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        num = input(<span class="string">"input obstacle numbers: "</span>)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            input_num = eval(num)</span><br><span class="line">            <span class="keyword">if</span> type(input_num) == int:</span><br><span class="line">                obstacle_set = self.AddObstacle(input_num)</span><br><span class="line">                <span class="keyword">for</span> obs <span class="keyword">in</span> obstacle_set:</span><br><span class="line">                    successors = self.SuccessorsExcludeObstacle(obs)</span><br><span class="line">                    <span class="keyword">for</span> succ <span class="keyword">in</span> successors:</span><br><span class="line">                        self.UpdateVertex(succ)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>路径规划</category>
      </categories>
      <tags>
        <tag>路径规划</tag>
        <tag>motion planning</tag>
        <tag>LPA*</tag>
      </tags>
  </entry>
  <entry>
    <title>路径规划-RRT_Connect</title>
    <url>/posts/2708526344/</url>
    <content><![CDATA[<h1 id="路径规划之-RRT-Connect-平衡双向快速扩展随机树"><a href="#路径规划之-RRT-Connect-平衡双向快速扩展随机树" class="headerlink" title="路径规划之 RRT_Connect (平衡双向快速扩展随机树)"></a>路径规划之 RRT_Connect (平衡双向快速扩展随机树)</h1><p>单颗 RRT 树每次搜索只从初始节点开始在状态空间中快速随机扩展节点，带有一定的盲目性。RRT_Connect 算法是一种基于双向扩展平衡的连结型双树(Balanced Bidirectional RRT)：两颗 RRTs 分别基于 $q_{init}$ 和 $q_{goal}$ 扩展；贪心启发式的连接方法使每棵树扩展时一次移动更长的距离。<a href="https://ieeexplore.ieee.org/document/844730" target="_blank" rel="noopener">作者</a>原文中举例了平面地图以及 6-DOF 的机械臂来验证 RRT_Connect.</p>
<a id="more"></a>
<p><img data-src="rrt_connect.gif" alt="rrt_connect.gif"></p>
<h2 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h2><p>分别在起点 $q_{init}$ 和终点 $q_{goal}$ 构造两棵树 $T_1$ 和 $T_2$，扩展节点方式同 RRT。首先 $T_1$ 从 $q_{init}$ 随机采样 $q_{rand}$ 作为目标点扩展一个新节点 $𝑞_{𝑛𝑒𝑤}$ ，以这个新节点 $𝑞_{𝑛𝑒𝑤}$ 作为第二棵树 $T_2$ 的目标点来扩展新节点 $𝑞_{𝑛𝑒𝑤}^′$。如果 $𝑞_{𝑛𝑒𝑤}^′$ 没有碰撞，继续以$𝑞_{𝑛𝑒𝑤}$作为目标点扩展$T_2$，直到扩展失败(遇到障碍，进行下一次循环扩展或者 $𝑞_{𝑛𝑒𝑤}^′=𝑞_{𝑛𝑒𝑤}$ 两棵树相连，即 connect，整个算法结束)。每次扩展需要考虑两棵树的平衡性，节点多少或总路径的长度。交换次序，选择较短的树进行扩展。<br>首先，RRT_Connect 算法以另一棵树的新节点作为目标点扩展，直到扩展失败。每次扩展更加贪婪，步长更长，使得树的生长更快；其次，两棵树不断朝向对方交替扩展，相比于随机扩展的方式具有一定的启发性质，特别当起始位姿和目标位姿处于约束区域时，两棵树可以通过朝向对方快速扩展而逃离各自的约束区域。</p>
<h3 id="伪码"><a href="#伪码" class="headerlink" title="伪码"></a>伪码</h3><p><img data-src="algorithm_rrt_connect.png" alt="Algorithms RRT_Connect"></p>
<h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, pos=[<span class="number">0</span>, <span class="number">0</span>])</span>:</span></span><br><span class="line">        self.pos = pos</span><br><span class="line">        self.parent = <span class="literal">None</span></span><br></pre></td></tr></table></figure>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">map_path: 地图图片路径</span></span><br><span class="line"><span class="string">qstart: 起点坐标 [row, col]</span></span><br><span class="line"><span class="string">qgoal: 目标点坐标 [row, col]</span></span><br><span class="line"><span class="string">grid_size: 网格大小（用来碰撞检测）</span></span><br><span class="line"><span class="string">step_size: 扩展步长</span></span><br><span class="line"><span class="string">max_steps: 最大扩展节点数</span></span><br><span class="line"><span class="string">goal_prob: 增加趋向目标点概率（贪婪）</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">rrt_connect = RRT_CONNECT(map_path, qstart, qgoal, grid_size,</span><br><span class="line">                          step_size, max_steps, goal_prob)</span><br></pre></td></tr></table></figure>
<h3 id="Planning"><a href="#Planning" class="headerlink" title="Planning"></a>Planning</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Planning</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    RRT_CONNECT planning</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    # 初始化两颗树：分别在起点qstart和终点qgoal构造两棵树,</span></span><br><span class="line"><span class="string">    # 节点树分别记为vertices_t1和vetices_t2.</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    vertices_t1 = []</span><br><span class="line">    self.AddVertices(self.qstart, vertices_t1)</span><br><span class="line">    self.AddEdges(<span class="literal">None</span>, self.qstart)</span><br><span class="line"></span><br><span class="line">    vertices_t2 = []</span><br><span class="line">    self.AddVertices(self.qgoal, vertices_t2)</span><br><span class="line">    self.AddEdges(<span class="literal">None</span>, self.qgoal)</span><br><span class="line"></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    # 开始迭代</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    k = <span class="number">0</span></span><br><span class="line">    new_qgoal = self.qgoal</span><br><span class="line">    <span class="keyword">while</span> k &lt;= self.max_steps:</span><br><span class="line">        k += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        # 随机采样qrand_t1作为目标点，沿(qnear_t1, qrand_t1)方向,</span></span><br><span class="line"><span class="string">        # 以step_size步长扩展第一棵树的节点qnew_t1.</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        qrand_t1 = self.GenerateRandomNode(</span><br><span class="line">            [<span class="number">0</span>, self.map_shape[<span class="number">0</span>]], [<span class="number">0</span>, self.map_shape[<span class="number">1</span>]],</span><br><span class="line">            new_qgoal, self.goal_prob)</span><br><span class="line"></span><br><span class="line">        _, qnear_t1 = self.FindNearestNode(qrand_t1, vertices_t1)</span><br><span class="line">        qnew_t1 = self.ExtendTree(qnear_t1, qrand_t1, self.step_size)</span><br><span class="line"></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        # 检查qnew_t1是否扩展成功且没有碰撞</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="keyword">if</span> qnew_t1 <span class="keyword">and</span> self.CollsionFree(qnear_t1, qnew_t1, self.grid_size):</span><br><span class="line">            <span class="string">'''</span></span><br><span class="line"><span class="string">            将qnew_t1加入到第一颗树vertices_t1中</span></span><br><span class="line"><span class="string">            '''</span></span><br><span class="line">            self.AddVertices(qnew_t1, vertices_t1)</span><br><span class="line">            self.AddEdges(qnear_t1, qnew_t1)</span><br><span class="line"></span><br><span class="line">            self.DrawEdges(self.src_map, qnear_t1, qnew_t1)</span><br><span class="line"></span><br><span class="line">            <span class="string">'''</span></span><br><span class="line"><span class="string">            # 以qnew_t1为目标点，沿(qnear_t2, qnew_t1)方向</span></span><br><span class="line"><span class="string">            # 以step_size步长扩展第二棵树的节点qnew_t2.</span></span><br><span class="line"><span class="string">            '''</span></span><br><span class="line">            k += <span class="number">1</span></span><br><span class="line">            _, qnear_t2 = self.FindNearestNode(qnew_t1, vertices_t2)</span><br><span class="line">            qnew_t2 = self.ExtendTree(qnear_t2, qnew_t1, self.step_size)</span><br><span class="line"></span><br><span class="line">            <span class="string">'''</span></span><br><span class="line"><span class="string">            # 检查qnew_t1是否扩展成功且没有碰撞</span></span><br><span class="line"><span class="string">            '''</span></span><br><span class="line">            <span class="keyword">if</span> qnew_t2 <span class="keyword">and</span> self.CollsionFree(qnear_t2, qnew_t2, self.grid_size):</span><br><span class="line">                <span class="string">'''</span></span><br><span class="line"><span class="string">                # 将qnew_t1加入到第一颗树vertices_t1中</span></span><br><span class="line"><span class="string">                '''</span></span><br><span class="line">                self.AddVertices(qnew_t2, vertices_t2)</span><br><span class="line">                self.AddEdges(qnear_t2, qnew_t2)</span><br><span class="line"></span><br><span class="line">                self.DrawEdges(self.src_map, qnear_t2, qnew_t2)</span><br><span class="line"></span><br><span class="line">                <span class="string">'''</span></span><br><span class="line"><span class="string">                # 这里一直以qnew_t1为目标点，扩展qnew_t2，</span></span><br><span class="line"><span class="string">                # 除非qnew_t2扩展失败或qnew_t2到达qnew_t1。</span></span><br><span class="line"><span class="string">                # 扩展qnew_t2带有一定的贪婪特性，所以扩展树相比RRT更快速</span></span><br><span class="line"><span class="string">                '''</span></span><br><span class="line">                <span class="keyword">while</span> k &lt;= self.max_steps <span class="keyword">and</span> self.IsArrival(qnew_t2, qnew_t1, self.step_size) == <span class="literal">False</span>:</span><br><span class="line">                    k += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                    <span class="string">'''</span></span><br><span class="line"><span class="string">                    # 以qnew_t1为目标点，沿(qnew_t2, qnew_t1)方向</span></span><br><span class="line"><span class="string">                    # 以step_size步长扩展新节点qnew_mid.</span></span><br><span class="line"><span class="string">                    '''</span></span><br><span class="line">                    qnew_mid = self.ExtendTree(</span><br><span class="line">                        qnew_t2, qnew_t1, self.step_size)</span><br><span class="line"></span><br><span class="line">                    <span class="string">'''</span></span><br><span class="line"><span class="string">                    # 检查qnew_mid是否扩展成功且没有碰撞</span></span><br><span class="line"><span class="string">                    '''</span></span><br><span class="line">                    <span class="keyword">if</span> qnew_mid <span class="keyword">and</span> self.CollsionFree(qnew_t2, qnew_mid, self.grid_size):</span><br><span class="line">                        <span class="string">'''</span></span><br><span class="line"><span class="string">                        # 如果qnew_mid扩展成功，则将其加入到第二棵树中.</span></span><br><span class="line"><span class="string">                        '''</span></span><br><span class="line">                        self.AddVertices(qnew_mid, vertices_t2)</span><br><span class="line">                        self.AddEdges(qnew_t2, qnew_mid)</span><br><span class="line"></span><br><span class="line">                        self.DrawEdges(self.src_map, qnew_t2, qnew_mid)</span><br><span class="line"></span><br><span class="line">                        <span class="string">'''</span></span><br><span class="line"><span class="string">                        # 将第二棵树新扩展的节点qnew_mid作为qnew_t2继续扩展</span></span><br><span class="line"><span class="string">                        '''</span></span><br><span class="line">                        qnew_t2 = qnew_mid</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="string">'''</span></span><br><span class="line"><span class="string">                        # 如果qnew_mid扩展失败，则跳出该循环.</span></span><br><span class="line"><span class="string">                        '''</span></span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">            <span class="string">'''</span></span><br><span class="line"><span class="string">            检查两棵树是否相连,若相连，则完成路径规划</span></span><br><span class="line"><span class="string">            '''</span></span><br><span class="line">            <span class="keyword">if</span> self.IsArrival(qnew_t2, qnew_t1, self.step_size):</span><br><span class="line">                print(<span class="string">"Found"</span>)</span><br><span class="line">                <span class="string">'''</span></span><br><span class="line"><span class="string">                # 如果两棵树连上了，说明找到路径了，把最后一个节点添加到树中。</span></span><br><span class="line"><span class="string">                '''</span></span><br><span class="line">                copy_qnew_t1 = copy.deepcopy(qnew_t1)</span><br><span class="line">                self.AddVertices(copy_qnew_t1, vertices_t2)</span><br><span class="line">                self.AddEdges(qnew_t2, copy_qnew_t1)</span><br><span class="line"></span><br><span class="line">                <span class="string">'''</span></span><br><span class="line"><span class="string">                # 合并两棵树，注意终点树的节点指针与起点树反向</span></span><br><span class="line"><span class="string">                '''</span></span><br><span class="line">                path = self.MergeTree(vertices_t1, vertices_t2)</span><br><span class="line">                self.DrawPath(self.src_map, path)</span><br><span class="line"></span><br><span class="line">                <span class="string">'''</span></span><br><span class="line"><span class="string">                # 路径圆滑</span></span><br><span class="line"><span class="string">                '''</span></span><br><span class="line">                smooth_path = self.SmoothPath(path, self.grid_size)</span><br><span class="line">                self.DrawPath(self.src_map, smooth_path)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        # 当第二棵树扩展失败后，回到第一棵树扩展时，检查两棵树的节点个数，</span></span><br><span class="line"><span class="string">        # 选择较短树进行扩展，使两棵树保持相对平衡。新的目标点为较长树的最后一个节点</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="keyword">if</span> (len(vertices_t2) &lt; len(vertices_t1)):</span><br><span class="line">            vertices_t2, vertices_t1 = vertices_t1, vertices_t2</span><br><span class="line">            <span class="comment"># edges_t2, edges_t1 = edges_t1, edges_t2</span></span><br><span class="line"></span><br><span class="line">            new_qgoal = vertices_t2[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"NotFound"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>[1]: Kuffner J J , Lavalle S M . RRT-connect: An efficient approach to single-query path planning[C]// Proceedings 2000 ICRA. Millennium Conference. IEEE International Conference on Robotics and Automation. Symposia Proceedings (Cat. No.00CH37065). IEEE, 2002.</p>
]]></content>
      <categories>
        <category>路径规划</category>
      </categories>
      <tags>
        <tag>路径规划</tag>
        <tag>motion planning</tag>
        <tag>RRT_Connect</tag>
      </tags>
  </entry>
  <entry>
    <title>路径规划-RRT_Star</title>
    <url>/posts/3092301982/</url>
    <content><![CDATA[<h1 id="路径规划之-RRT-Star"><a href="#路径规划之-RRT-Star" class="headerlink" title="路径规划之 RRT_Star"></a>路径规划之 RRT_Star</h1><p>RRT_Connect 相对于 RRT 虽然增加了启发式策略和贪婪思想，但他们的路径都不是最优的。搜索路径都是基于随机采样，缺少评价函数。RRT_Star 算法在 RRT 的基础上，基于代价函数来重新选择新父节点，重新布线新子节点，保证算法渐进最优解。</p>
<a id="more"></a>
<p><img data-src="rrt_star.gif" alt="rrt_star.gif"></p>
<h2 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h2><p>RRT* 构造方式和 RRT 类似，区别在于重新选择父节点和重新布线这个过程。在寻找到新节点 $q_{new}$ 时，先进行碰撞检测，若 ($q_{near}$， $q_{new}$) 没有碰撞，并不立即将新节点和新边加入到树中。而是首先<strong>重新选择父节点</strong>：寻找以 $q_{new}$ 为圆心，以半径$r$内的所有邻接节点，作为$q_{new}$ 的潜在父节点 $q_{proential_parents}$ 。然后遍历所有潜在父节点，若 $q_{protential_parents}$ 到 $q_{new}$ 无碰撞，则计算从起点 $q_{start}$ 到潜在父节点$q_{protential_parents}$，再到新节点$q_{new}$的总路径长。选择最短路径的潜在父节点(假设记为$q_{min_parent}$)作为$q_{new}$的父节点，添加边 ($q_{min_parent}, q_{new}$) 到树中。 在完成父节点的重新选择后，再对该邻域<strong>重新布线</strong>：再次遍历该邻接节点集合中除 $q_{min_parent}$ 之外的剩余节点，作为 $q_{new}$ 的潜在子节点 $q_{proential_children}$，若 $q_{new}$ 到 $q_{protential_children}$ 无碰撞，则计算从起点 $q_{start}$ 到新节点 $q_{new}$ ，再到潜在子节点 $q_{protential_children}$ 的总路径长。选择最短路径的潜在子节点 (假设记为 $q_{min_child}$ )，将该节点的父节点设置为 $q_{new}$ 的新节点，删除边 ($q_{parent_of_min_child}$, $q_{min_child}$) 添加边 ($q_{new}$, $q_{min_parent}$) 到树中。因为我们通过链表来构建树，所以设置父节点也相当于添加边；更改父节点，相当于删除了原来的边并添加新边。通过上述两次选择，使得 RRT* 达到渐进最优，并且构造树的节点和边大大减少，提高的搜索效率。</p>
<h3 id="伪码"><a href="#伪码" class="headerlink" title="伪码"></a>伪码</h3><p><img data-src="algorithm_rrt_star.png" alt="Algorithms RRT_Connect"></p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, pos=[<span class="number">0</span>, <span class="number">0</span>])</span>:</span></span><br><span class="line">        self.pos = pos</span><br><span class="line">        self.parent = <span class="literal">None</span></span><br></pre></td></tr></table></figure>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">map_path: 地图图片路径</span></span><br><span class="line"><span class="string">qstart: 起点坐标 [row, col]</span></span><br><span class="line"><span class="string">qgoal: 目标点坐标 [row, col]</span></span><br><span class="line"><span class="string">grid_size: 网格大小（用来碰撞检测）</span></span><br><span class="line"><span class="string">step_size: 扩展步长</span></span><br><span class="line"><span class="string">neighbor_radius: 邻域半径，有公式计算的，这里为简单起见，选择定制</span></span><br><span class="line"><span class="string">max_steps: 最大扩展节点数</span></span><br><span class="line"><span class="string">goal_prob: 增加趋向目标点概率（贪婪）</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">rrt_star = RRT_STAR(map_path, qstart, qgoal, grid_size,</span><br><span class="line">                    step_size, parent_radius, max_steps, goal_prob)</span><br></pre></td></tr></table></figure>
<h3 id="Planning"><a href="#Planning" class="headerlink" title="Planning"></a>Planning</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Planning</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    RRT_STAR planning</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 初始化树，添加起点</span></span><br><span class="line">    vertices = []</span><br><span class="line">    self.AddVertices(self.qstart, vertices)</span><br><span class="line">    self.AddEdges(<span class="literal">None</span>, self.qstart)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 开始扩展</span></span><br><span class="line">    k = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> k &lt;= self.max_steps:</span><br><span class="line">        k += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 随机采样节点qrand，</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 扩展新节点qnew</span></span><br><span class="line">        qrand = self.GenerateRandomNode(</span><br><span class="line">            [<span class="number">0</span>, self.map_shape[<span class="number">0</span>]], [<span class="number">0</span>, self.map_shape[<span class="number">1</span>]],</span><br><span class="line">            self.qgoal, self.goal_prob)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 遍历树节点 vertices，选择距离最近的节点 qnear</span></span><br><span class="line">        _, qnear = self.FindNearestNode(qrand, vertices)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 扩展新节点 qnew</span></span><br><span class="line">        qnew = self.ExtendTree(qnear, qrand, self.step_size)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 判断 qnew 扩展成功，且(qnear, qnew)无碰撞</span></span><br><span class="line">        <span class="keyword">if</span> qnew <span class="keyword">and</span> self.CollsionFree(qnear, qnew, self.grid_size):</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 寻找以qnew为圆心，parent_radius为半径的圆内邻接节点neighbors_free</span></span><br><span class="line">            neighbors_free = self.FindNeighbors(</span><br><span class="line">                qnew, vertices, self.parent_radius)</span><br><span class="line"></span><br><span class="line">            <span class="string">'''</span></span><br><span class="line"><span class="string">            neighbors = list(filter(lambda qnode: self.Distance(</span></span><br><span class="line"><span class="string">                qnode.pos, qnew.pos) &lt; self.parent_radius, vertices))</span></span><br><span class="line"><span class="string">            neighbors_free = []</span></span><br><span class="line"><span class="string">            for parent in neighbors:</span></span><br><span class="line"><span class="string">                if self.CollsionFree(parent, qnew, self.grid_size):</span></span><br><span class="line"><span class="string">                    neighbors_free.append(parent)</span></span><br><span class="line"><span class="string">            '''</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 重新选择父节点：</span></span><br><span class="line">            <span class="comment"># 计算路径代价Cost(qstart, neighbors_free, qnew),</span></span><br><span class="line">            <span class="comment"># 选择最短路径的潜在父节点作为qnew的新父节点qnew_parent，并将新边加入到树中</span></span><br><span class="line">            len_qnew_path, qnew_parent = self.RewireNewParent(</span><br><span class="line">                qnew, vertices, neighbors_free)</span><br><span class="line"></span><br><span class="line">            <span class="string">'''</span></span><br><span class="line"><span class="string">            len_qnew_path = float('inf')</span></span><br><span class="line"><span class="string">            qnew_parent = None</span></span><br><span class="line"><span class="string">            for parent in neighbors_free:</span></span><br><span class="line"><span class="string">                parent_path = self.FindPathByParentPointer(parent)</span></span><br><span class="line"><span class="string">                len_parent_path = self.CalculatePathLength(parent_path)</span></span><br><span class="line"><span class="string">                tmp_len_path = len_parent_path + \</span></span><br><span class="line"><span class="string">                    self.Distance(qnew.pos, parent.pos)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                if tmp_len_path &lt; len_qnew_path:</span></span><br><span class="line"><span class="string">                    len_qnew_path = tmp_len_path</span></span><br><span class="line"><span class="string">                    qnew_parent = parent</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            self.AddVertices(qnew, vertices)</span></span><br><span class="line"><span class="string">            self.AddEdges(qnew_parent, qnew)</span></span><br><span class="line"><span class="string">            self.DrawEdges(self.src_map, qnew_parent, qnew)</span></span><br><span class="line"><span class="string">            '''</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 重新布线：</span></span><br><span class="line">            <span class="comment"># 计算neighbors_free中除qnew_parent外的路径代价Cost(qstart, qnew, neighbors_free),</span></span><br><span class="line">            <span class="comment"># 选择最短路径的节点qnew_children，设置其父节点为qnew，并将新边加入到树中</span></span><br><span class="line">            <span class="keyword">if</span> qnew_parent:</span><br><span class="line">                neighbors_free.remove(qnew_parent)</span><br><span class="line">            self.RewireNewChild(qnew, len_qnew_path, neighbors_free)</span><br><span class="line">            <span class="string">'''</span></span><br><span class="line"><span class="string">            qnew_children = None</span></span><br><span class="line"><span class="string">            for child in neighbors_free:</span></span><br><span class="line"><span class="string">                tmp_len_path = len_qnew_path + \</span></span><br><span class="line"><span class="string">                    self.Distance(qnew.pos, child.pos)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                if self.CollsionFree(child, qnew, self.grid_size):</span></span><br><span class="line"><span class="string">                    child_path = self.FindPathByParentPointer(child)</span></span><br><span class="line"><span class="string">                    if tmp_len_path &lt; self.CalculatePathLength(child_path):</span></span><br><span class="line"><span class="string">                        qnew_children = child</span></span><br><span class="line"><span class="string">                        self.AddEdges(qnew, qnew_children)</span></span><br><span class="line"><span class="string">                        self.DrawEdges(self.src_map, qnew,</span></span><br><span class="line"><span class="string">                                       qnew_children)</span></span><br><span class="line"><span class="string">            '''</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 检查两棵树是否相连,若相连，则完成路径规划</span></span><br><span class="line">            <span class="keyword">if</span> self.IsArrival(qnew, self.qgoal, self.step_size):</span><br><span class="line">                print(<span class="string">"Found"</span>)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 如果两棵树连上了，说明找到路径了，把最后一个节点添加到树中。</span></span><br><span class="line">                self.AddVertices(self.qgoal, vertices)</span><br><span class="line">                self.AddEdges(qnew, self.qgoal)</span><br><span class="line">                self.DrawEdges(self.src_map, qnew, self.qgoal)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 构建路径</span></span><br><span class="line">                path = self.FindPath(vertices)</span><br><span class="line">                self.DrawPath(self.src_map, path)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 圆滑路径</span></span><br><span class="line">                smooth_path = self.SmoothPath(path, self.grid_size)</span><br><span class="line">                self.DrawPath(self.src_map, smooth_path)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">"NotFound"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>[1]: Karaman S, Frazzoli E. Sampling-based algorithms for optimal motion planning[J]. The international journal of robotics research, 2011, 30(7): 846-894.<br>[2]: Choset. Principles of Robot Motion: Theory, Algorithms, and Implementations[J]. Proceedings of the Society for Experimental Biology &amp; Medicine Society for Experimental Biology &amp; Medicine, 2005, 147(1):512-512.</p>
]]></content>
      <categories>
        <category>路径规划</category>
      </categories>
      <tags>
        <tag>路径规划</tag>
        <tag>motion planning</tag>
        <tag>RRT*</tag>
      </tags>
  </entry>
  <entry>
    <title>ROS学习-xacro</title>
    <url>/posts/2389657244/</url>
    <content><![CDATA[<p>Xacro(XML Macros)Xacro是一种XML宏语言. 使用xacro, 可以通过使用宏命令构建更精悍短小但又具有更高可读性的XML文件, 这种宏命令可以扩展达到更大的XML表达范围. 此包在处理大型XML文档(如机器人说明)时最为有用. 它在如urdf的包中大量使用. 本文主要来源于<a href="http://wiki.ros.org/xacro" target="_blank" rel="noopener">官方教程</a>. </p>
<a id="more"></a>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><p><a href="#1-%e6%a1%88%e4%be%8b">1. 案例</a><br><a href="#2-%e5%b1%9e%e6%80%a7%e5%92%8c%e5%b1%9e%e6%80%a7%e5%9d%97">2. 属性和属性块</a><br><a href="#3-%e6%95%b0%e5%ad%a6%e8%a1%a8%e8%be%be%e5%bc%8f">3. 数学表达式</a><br><a href="#4-%e6%9d%a1%e4%bb%b6%e5%9d%97">4. 条件块</a><br><a href="#4-%e6%9d%a1%e4%bb%b6%e5%9d%97">5. <code>Rospack</code>命令</a><br><a href="#5-rospack%e5%91%bd%e4%bb%a4">6. 宏命令</a><br><a href="#61-%e9%bb%98%e8%ae%a4%e5%8f%82%e6%95%b0">6.1 默认参数</a><br><a href="#62-%e5%b1%80%e9%83%a8%e5%b1%9e%e6%80%a7">6.2 局部属性</a><br><a href="#7-%e5%8c%85%e5%90%ab%e5%85%b6%e4%bb%96xacro%e6%96%87%e4%bb%b6">7. 包含其他<code>xacro</code>文件</a><br><a href="#8-yaml%e8%af%ad%e8%a8%80%e6%94%af">8. <code>YAML</code>语言支持</a><br><a href="#9-%e7%94%a8cmakeliststxt%e8%bf%9b%e8%a1%8c%e6%9e%84%e5%bb%ba">9. 用<code>CMakeLists.txt</code>进行构建</a><br><a href="#10-%e5%85%83%e7%b4%a0%e4%b8%8e%e5%b1%9e%e6%80%a7">10. 元素和属性</a><br><a href="#11-%e5%a4%84%e7%90%86%e9%a1%ba%e5%ba%8f">11. 处理顺序</a><br><a href="#12-%e5%b7%b2%e5%bc%83%e7%94%a8%e7%9a%84%e8%af%ad%e6%b3%95">12. 已弃用的语法</a></p>
<h1 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h1><p>参考以下的<code>Xacro XML</code>片段: </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xacro:macro</span> <span class="attr">name</span>=<span class="string">"pr2_arm"</span> <span class="attr">params</span>=<span class="string">"suffix parent reflect"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">pr2_upperarm</span> <span class="attr">suffix</span>=<span class="string">"$&#123;suffix&#125;"</span> <span class="attr">reflect</span>=<span class="string">"$&#123;reflect&#125;"</span> <span class="attr">parent</span>=<span class="string">"$&#123;parent&#125;"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">pr2_forearm</span> <span class="attr">suffix</span>=<span class="string">"$&#123;suffix&#125;"</span> <span class="attr">reflect</span>=<span class="string">"$&#123;reflect&#125;"</span> <span class="attr">parent</span>=<span class="string">"elbow_flex_$&#123;suffix&#125;"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xacro:macro</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">xacro:pr2_arm</span> <span class="attr">suffix</span>=<span class="string">"left"</span> <span class="attr">reflect</span>=<span class="string">"1"</span> <span class="attr">parent</span>=<span class="string">"torso"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">xacro:pr2_arm</span> <span class="attr">suffix</span>=<span class="string">"right"</span> <span class="attr">reflect</span>=<span class="string">"-1"</span> <span class="attr">parent</span>=<span class="string">"torso"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面的片段扩展成为下面的样子: </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">pr2_upperarm</span> <span class="attr">suffix</span>=<span class="string">"left"</span> <span class="attr">reflect</span>=<span class="string">"1"</span> <span class="attr">parent</span>=<span class="string">"torso"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">pr2_forearm</span> <span class="attr">suffix</span>=<span class="string">"left"</span> <span class="attr">reflect</span>=<span class="string">"1"</span> <span class="attr">parent</span>=<span class="string">"elbow_flex_left"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">pr2_upperarm</span> <span class="attr">suffix</span>=<span class="string">"right"</span> <span class="attr">reflect</span>=<span class="string">"-1"</span> <span class="attr">parent</span>=<span class="string">"torso"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">pr2_forearm</span> <span class="attr">suffix</span>=<span class="string">"right"</span> <span class="attr">reflect</span>=<span class="string">"-1"</span> <span class="attr">parent</span>=<span class="string">"elbow_flex_right"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果我们还定义了<code>pr2_upperarm</code>和<code>pr2_forearm</code>的宏, 那么这个片段可以扩展以描述整个机器人臂. </p>
<p>本文的其余部分描述了<code>xacro</code>的功能. </p>
<h1 id="属性和属性块"><a href="#属性和属性块" class="headerlink" title="属性和属性块"></a>属性和属性块</h1><p>属性是可以插入到<code>XML</code>文档中的任何位置的值. 属性块是<code>XML</code>的名称片段, 可以插入允许<code>XML</code>的任何位置. 两者都使用属性标签来定义值. 属性标签不能在<code>xacro:macro</code>中声明. 以下示例将显示如何声明和使用属性: </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">"the_radius"</span> <span class="attr">value</span>=<span class="string">"2.1"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">"the_length"</span> <span class="attr">value</span>=<span class="string">"4.5"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">geometry</span> <span class="attr">type</span>=<span class="string">"cylinder"</span> <span class="attr">radius</span>=<span class="string">"$&#123;the_radius&#125;"</span> <span class="attr">length</span>=<span class="string">"$&#123;the_length&#125;"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>通过将名称放在<code>dollared-braces</code> (<strong><code>${}</code></strong>)中, 你可以将两个属性值插入到几何表达式中. 如果你想要一个文本<code>&quot;{&quot;</code>, 你应该将其转义为<code>&quot;$${&quot;</code>.<br>下面是使用属性块的示例: </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">"front_left_origin"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">"0.3 0 0"</span> <span class="attr">rpy</span>=<span class="string">"0 0 0"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xacro:property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">pr2_wheel</span> <span class="attr">name</span>=<span class="string">"front_left_wheel"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">xacro:insert_block</span> <span class="attr">name</span>=<span class="string">"front_left_origin"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">pr2_wheel</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="数学表达式"><a href="#数学表达式" class="headerlink" title="数学表达式"></a>数学表达式</h1><p>在<code>dollared-braces</code> (<strong><code>${}</code></strong>)中, 您还可以编写简单的数学表达式. 目前, 该结构支持基本算术和变量替换. 下面是一个例子: </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">"pi"</span> <span class="attr">value</span>=<span class="string">"3.1415926535897931"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">circle</span> <span class="attr">circumference</span>=<span class="string">"$&#123;2.5 * pi&#125;"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>在<code>Jade</code>版本的<code>ROS</code>中更新的地方:<br>自<code>ROS Jade</code>以来, <code>Xacro</code>使用<code>python</code>来评估包含在<code>dollared-braces</code> (<strong><code>${}</code></strong>)中的表达式. 这允许用户使用更复杂的算术表达式. 此外, 一些基本常数, 例如<code>pi</code>, 已经被预定义过了: </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">"R"</span> <span class="attr">value</span>=<span class="string">"2"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">"alpha"</span> <span class="attr">value</span>=<span class="string">"$&#123;30/180*pi&#125;"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">circle</span> <span class="attr">circumference</span>=<span class="string">"$&#123;2 * pi * R&#125;"</span> <span class="attr">pos</span>=<span class="string">"$&#123;sin(alpha)&#125; $&#123;cos(alpha)&#125;"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="条件块"><a href="#条件块" class="headerlink" title="条件块"></a>条件块</h1><p>在<code>Hydro</code>版本的<code>ROS</code>中更新的地方:<br>自从<code>ROS Hydro</code>以来, <code>Xacro</code>有类似于<code>roslaunch</code>的条件块. 这对于可配置的机器人或加载不同的<code>Gazebo</code>插件等事情很有用. 它遵循以下语法: </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xacro:if</span> <span class="attr">value</span>=<span class="string">"&lt;expression&gt;"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- &lt;... some xml code here ...&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xacro:if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">xacro:unless</span> <span class="attr">value</span>=<span class="string">"&lt;expression&gt;"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- &lt;... some xml code here ...&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xacro:unless</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>表达式需要计算结果为<code>&quot;0&quot;</code>, <code>&quot;1&quot;</code>, <code>&quot;true&quot;</code>或<code>&quot;false&quot;</code>, 否则将抛出错误. </p>
<p>在<code>Jade</code>版本的<code>ROS</code>中更新的地方:<br><code>ROS Jade</code>中更强大的评估功能允许使用更复杂的表达式. 几乎任何<code>python</code>表达式的计算结果都是可行的: </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">"var"</span> <span class="attr">value</span>=<span class="string">"useit"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">xacro:if</span> <span class="attr">value</span>=<span class="string">"$&#123;var == 'useit'&#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">xacro:if</span> <span class="attr">value</span>=<span class="string">"$&#123;var.startswith('use') and var.endswith('it')&#125;"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">"allowed"</span> <span class="attr">value</span>=<span class="string">"[1,2,3]"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">xacro:if</span> <span class="attr">value</span>=<span class="string">"$&#123;1 in allowed&#125;"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="Rospack命令"><a href="#Rospack命令" class="headerlink" title="Rospack命令"></a><code>Rospack</code>命令</h1><p><code>Xacro</code>允许你使用某些<code>rospack</code>命令和<code>dollared-braces</code> (<strong><code>${}</code></strong>). </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">foo</span> <span class="attr">value</span>=<span class="string">"$(find xacro)"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">foo</span> <span class="attr">value</span>=<span class="string">"$(arg myvar)"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>Xacro</code>目前支持使用<code>substitution args</code>的<code>roslaunch</code>支持的所有<code>rospack</code>命令. 参数需要在命令行中使用<code>myvar := true</code>语法指定. </p>
<p>在<code>Indigo</code>版本的<code>ROS</code>中更新的地方:<br>自从<code>ROS Indigo</code>, 它也可以像如下定义默认值: </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xacro:arg</span> <span class="attr">name</span>=<span class="string">"myvar"</span> <span class="attr">default</span>=<span class="string">"false"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>通过这种方式, 你可以像下面这样运行<code>xacro</code>: </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"robot_description"</span> <span class="attr">command</span>=<span class="string">"$(find xacro)/xacro.py $(arg model) myvar:=true"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="宏命令"><a href="#宏命令" class="headerlink" title="宏命令"></a>宏命令</h1><p><code>xacro</code>的主要特性是它对宏的支持. 使用宏标签定义宏, 并指定宏名称和参数列表. 参数列表应以空格分隔. 它们变成<code>macro-local</code>属性. </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xacro:macro</span> <span class="attr">name</span>=<span class="string">"pr2_caster"</span> <span class="attr">params</span>=<span class="string">"suffix *origin **content **anothercontent"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">joint</span> <span class="attr">name</span>=<span class="string">"caster_$&#123;suffix&#125;_joint"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">axis</span> <span class="attr">xyz</span>=<span class="string">"0 0 1"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">joint</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">name</span>=<span class="string">"caster_$&#123;suffix&#125;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:insert_block</span> <span class="attr">name</span>=<span class="string">"origin"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:insert_block</span> <span class="attr">name</span>=<span class="string">"content"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:insert_block</span> <span class="attr">name</span>=<span class="string">"anothercontent"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xacro:macro</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">xacro:pr2_caster</span> <span class="attr">suffix</span>=<span class="string">"front_left"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">pose</span> <span class="attr">xyz</span>=<span class="string">"0 1 0"</span> <span class="attr">rpy</span>=<span class="string">"0 0 0"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">container</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">color</span> <span class="attr">name</span>=<span class="string">"yellow"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mass</span>&gt;</span>0.1<span class="tag">&lt;/<span class="name">mass</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">container</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">another</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">inertial</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">"0 0 0.5"</span> <span class="attr">rpy</span>=<span class="string">"0 0 0"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">mass</span> <span class="attr">value</span>=<span class="string">"1"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">inertia</span> <span class="attr">ixx</span>=<span class="string">"100"</span>  <span class="attr">ixy</span>=<span class="string">"0"</span>  <span class="attr">ixz</span>=<span class="string">"0"</span> <span class="attr">iyy</span>=<span class="string">"100"</span> <span class="attr">iyz</span>=<span class="string">"0"</span> <span class="attr">izz</span>=<span class="string">"100"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">inertial</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">another</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xacro:pr2_caster</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>该示例声明了一个宏<code>&quot;pr2_caster&quot;</code>, 它有两个参数: <code>suffix</code>和<code>origin</code>.  <strong><em>请注意, “origin”已加星标. 这表明origin是一个块参数, 而不是一个简单的文本参数</em></strong>. 看下<code>pr2_caster</code>的使用. <code>suffix</code>属性(<code>property</code>)在<code>pr2_caster</code>标签中定义为属性(<code>attribute</code>), 但没有定义<code>origin</code>属性. 相反, <code>origin</code>指的是第一个元素(<code>&quot;pose&quot;</code>块). <strong><em>双星号版本(<code>&quot;content&quot;</code>, <code>&quot;anothercontent&quot;</code>)允许插入在随后可用的元素(在上面的示例中分别是<code>&quot;container&quot;</code>, <code>&quot;another&quot;</code>)中传递的任意数量的元素</em></strong>. 此示例扩展为以下内容: </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">joint</span> <span class="attr">name</span>=<span class="string">"caster_front_left_joint"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">axis</span> <span class="attr">xyz</span>=<span class="string">"0 0 1"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">joint</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">name</span>=<span class="string">"caster_front_left"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">pose</span> <span class="attr">xyz</span>=<span class="string">"0 1 0"</span> <span class="attr">rpy</span>=<span class="string">"0 0 0"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">color</span> <span class="attr">name</span>=<span class="string">"yellow"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mass</span>&gt;</span>0.1<span class="tag">&lt;/<span class="name">mass</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">inertial</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">"0 0 0.5"</span> <span class="attr">rpy</span>=<span class="string">"0 0 0"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mass</span> <span class="attr">value</span>=<span class="string">"1"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">inertia</span> <span class="attr">ixx</span>=<span class="string">"100"</span>  <span class="attr">ixy</span>=<span class="string">"0"</span>  <span class="attr">ixz</span>=<span class="string">"0"</span> <span class="attr">iyy</span>=<span class="string">"100"</span> <span class="attr">iyz</span>=<span class="string">"0"</span> <span class="attr">izz</span>=<span class="string">"100"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">inertial</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>多个块参数将按指定的顺序处理: </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xacro:macro</span> <span class="attr">name</span>=<span class="string">"reorder"</span> <span class="attr">params</span>=<span class="string">"*first *second"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">xacro:insert_block</span> <span class="attr">name</span>=<span class="string">"second"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">xacro:insert_block</span> <span class="attr">name</span>=<span class="string">"first"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xacro:macro</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">reorder</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">first</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">second</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">reorder</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>宏可能包含其他宏. 外部宏将首先展开, 然后内部宏将展开. 例如: </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">xacro:macro</span> <span class="attr">name</span>=<span class="string">"foo"</span> <span class="attr">params</span>=<span class="string">"x"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">in_foo</span> <span class="attr">the_x</span>=<span class="string">"$&#123;x&#125;"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">xacro:macro</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">xacro:macro</span> <span class="attr">name</span>=<span class="string">"bar"</span> <span class="attr">params</span>=<span class="string">"y"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">in_bar</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">xacro:foo</span> <span class="attr">x</span>=<span class="string">"$&#123;y&#125;"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">in_bar</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">xacro:macro</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">xacro:bar</span> <span class="attr">y</span>=<span class="string">"12"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>变成: </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">in_bar</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">in_foo</span> <span class="attr">the_x</span>=<span class="string">"12.0"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">in_bar</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><p><code>Indigo</code>中更新<br>宏参数可以有默认值: </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xacro:macro</span> <span class="attr">name</span>=<span class="string">"foo"</span> <span class="attr">params</span>=<span class="string">"x:=$&#123;x&#125; y:=$&#123;2*y&#125; z:=0"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果默认值包含评估表达式, 则将在实例化时评估它们. </p>
<p><code>Jade</code>中更新<br>通常, 您需要将外部变量传递到本地宏参数(如上面的<code>x</code>). 要简化此任务, 可以使用<code>^</code>语法: </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xacro:macro</span> <span class="attr">name</span>=<span class="string">"foo"</span> <span class="attr">params</span>=<span class="string">"p1 p2:=expr_a p3:=^ p4:=^|expr_b"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>插入符号<code>^</code>表示使用外部<code>scope</code>属性(具有相同名称). 管道<code>|</code>表示如果属性未在外部范围中定义, 则使用给定的回退. </p>
<h2 id="局部属性"><a href="#局部属性" class="headerlink" title="局部属性"></a>局部属性</h2><p><code>Jade</code>中更新<br>在宏中定义的属性和宏对于该宏来说是局部的, 即在外部不可见. 使用可选属性<code>scope =&quot;parent | global&quot;</code>, 属性定义可以导出到宏的父作用域(或全局作用域). </p>
<h1 id="包含其他xacro文件"><a href="#包含其他xacro文件" class="headerlink" title="包含其他xacro文件"></a>包含其他<code>xacro</code>文件</h1><p>您可以使用<code>xacro: include</code>标签来包含其他<code>xacro</code>文件: </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xacro:include</span> <span class="attr">filename</span>=<span class="string">"$(find package)/other_file.xacro"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">xacro:include</span> <span class="attr">filename</span>=<span class="string">"other_file.xacro"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">xacro:include</span> <span class="attr">filename</span>=<span class="string">"$(cwd)/other_file.xacro"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>文件<code>&quot;other_file.xacro&quot;</code>将被<code>xacro</code>包含和扩展. <code>Jade</code>中的新功能: 相对文件名相对于当前处理的文件进行解释. <strong>注意: 当在宏中包含文件时, 包含处理不是宏定义, 而是宏调用文件</strong>!  <code>$(cwd)</code>显式的允许访问当前工作目录中的文件.<br>为了避免各种包含文件的属性和宏之间的名称冲突, 可以为包含的文件指定命名空间 - 提供属性<code>ns</code>: </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xacro:include</span> <span class="attr">filename</span>=<span class="string">"other_file.xacro"</span> <span class="attr">ns</span>=<span class="string">"namespace"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>访问命名空间宏和属性是通过预先命名空间来实现的, 用点分隔: </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">$&#123;namespace.property&#125;</span><br></pre></td></tr></table></figure>
<h1 id="YAML语言支"><a href="#YAML语言支" class="headerlink" title="YAML语言支"></a><code>YAML</code>语言支</h1><p><code>Jade</code>中的新功能<br>属性可以是用<code>python</code>语法声明的字典或列表, 如下所示: </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">"props"</span> <span class="attr">value</span>=<span class="string">"$&#123;dict(a=1, b=2, c=3)&#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">"numbers"</span> <span class="attr">value</span>=<span class="string">"$&#123;[1,2,3,4]&#125;"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>或者从<code>YAML</code>文件中加载, 如下: </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">"props"</span> <span class="attr">value</span>=<span class="string">"$&#123;load_yaml('props.yaml')&#125;"</span>/</span></span><br></pre></td></tr></table></figure>
<p>注意, 通过<code>evaluation brackets ${}</code>区分评价和纯文本定义. 校准数据是从YAML加载的理想候选. </p>
<h1 id="用CMakeLists-txt进行构建"><a href="#用CMakeLists-txt进行构建" class="headerlink" title="用CMakeLists.txt进行构建"></a>用<code>CMakeLists.txt</code>进行构建</h1><p>以下代码段显示如何在程序包的申明期间使用<code>xacro</code>: </p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Generate .world files from .world.xacro files</span></span><br><span class="line"><span class="keyword">find_package</span>(xacro REQUIRED)</span><br><span class="line"><span class="comment"># You can also add xacro to the list of catkin packages:</span></span><br><span class="line"><span class="comment">#   find_package(catkin REQUIRED COMPONENTS ... xacro)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Xacro files</span></span><br><span class="line"><span class="keyword">file</span>(GLOB xacro_files <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/worlds/*.world.xacro)</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span>(it <span class="variable">$&#123;xacro_files&#125;</span>)</span><br><span class="line">  <span class="comment"># remove .xacro extension</span></span><br><span class="line">  <span class="keyword">string</span>(REGEX MATCH <span class="string">"(.*)[.]xacro$"</span> unused <span class="variable">$&#123;it&#125;</span>)</span><br><span class="line">  <span class="keyword">set</span>(output_filename <span class="variable">$&#123;CMAKE_MATCH_1&#125;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># create a rule to generate $&#123;output_filename&#125; from &#123;it&#125;</span></span><br><span class="line">  xacro_add_xacro_file(<span class="variable">$&#123;it&#125;</span> <span class="variable">$&#123;output_filename&#125;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">list</span>(APPEND world_files <span class="variable">$&#123;output_filename&#125;</span>)</span><br><span class="line"><span class="keyword">endforeach</span>(it)</span><br><span class="line"></span><br><span class="line"><span class="comment"># add an abstract target to actually trigger the builds</span></span><br><span class="line"><span class="keyword">add_custom_target</span>(media_files ALL DEPENDS <span class="variable">$&#123;world_files&#125;</span>)</span><br></pre></td></tr></table></figure>
<p><code>Jade</code>中的新功能:<br>虽然这个<code>cmake</code>代码提供了对目标名称和构建顺序的完全控制, 但还有一个更简便的宏:   </p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">file</span>(GLOB xacro_files worlds/*.world.xacro)</span><br><span class="line">xacro_add_files(<span class="variable">$&#123;xacro_files&#125;</span> <span class="keyword">TARGET</span> media_files)</span><br></pre></td></tr></table></figure>
<h1 id="元素与属性"><a href="#元素与属性" class="headerlink" title="元素与属性"></a>元素与属性</h1><p><code>Jade</code>中的新功能:<br>要使用动态定义的名称添加元素或属性, 可以使用特殊的<code>xacro</code>标签</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xacro:element</span> <span class="attr">xacro:name</span>=<span class="string">"$&#123;element_name&#125;"</span> [<span class="attr">other</span> <span class="attr">attributes</span>]&gt;</span></span><br><span class="line"> [content]</span><br><span class="line"><span class="tag">&lt;/<span class="name">xacro:element</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">xacro:attribute</span> <span class="attr">name</span>=<span class="string">"$&#123;attribute_name&#125;"</span> <span class="attr">value</span>=<span class="string">"$&#123;attribute_value&#125;"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="处理顺序"><a href="#处理顺序" class="headerlink" title="处理顺序"></a>处理顺序</h1><p><code>Classicly Xacro</code>首先加载所有包含项, 然后处理所有属性和宏定义, 最后实例化宏并计算表达式. 因此, <strong>后期定义的属性或宏定义将覆盖先前的定义</strong>. 此外, 条件标签, <code>&lt;if&gt;</code>和<code>&lt;unless&gt;</code>, 对宏或属性定义以及包含的其他文件没有影响. </p>
<p><code>Jade</code>中的新功能:<br>自<code>ROS Jade</code>以来, <code>Xacro</code>提供了命令行选项<code>–-inorder</code>, 允许以读取的顺序来处理整个文档. 因此, 将使用属性或宏的最新定义. 这是一个更直观的评估过程, 提供了一些不错的新功能: </p>
<ul>
<li>如果<code>&lt;include&gt;</code>标签分别放置在宏内或条件标签中, 则可以推迟或完全禁止包含文件. </li>
<li>包含文件名可以通过属性或宏参数指定. </li>
<li>通过更改全局范围的属性, 如果在宏中使用这些属性, 则宏的实例化可以产生不同的结果. </li>
<li>属性定义可以是有条件的. </li>
<li>宏可以在局部范围内定义属性, 而不会影响外部. </li>
</ul>
<p>因为<code>–-inorder</code>处理更强大, 在未来<code>Jade</code>以后的版本, 新的处理风格将成为默认风格, 所以你应该检查你的<code>xacro</code>文件的兼容性. 通常, 两种加工方式应该给出相同的结果. 你可以很容易地像下面这样检查: </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rosrun xacro xacro file.xacro &gt; /tmp/old.xml</span><br><span class="line">rosrun xacro xacro --inorder file.xacro &gt; /tmp/new.xml</span><br><span class="line">diff /tmp/old.xml /tmp/new.xml</span><br></pre></td></tr></table></figure>
<p>如果结果显示出任何差异, 你应检查并调整您的xacro文件. 常见的原因是校准数据后期加载了(作为属性). 在这种情况下, 只需将加载行为向前移动, 即在使用之前进行校准数据的加载. 为了方便搜索错误放置的属性定义, 可以使用选项<code>-–check--order</code>运行<code>xacro</code>. 如果任何有问题的属性, 它们将在<code>stderr</code>上列出: </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Document is incompatible to --inorder processing.</span><br><span class="line">The following properties were redefined after usage:</span><br><span class="line">foo redefined <span class="keyword">in</span> issues.xacro</span><br></pre></td></tr></table></figure>
<p>使用命令行选项<code>-vv</code>或<code>-vvv</code>, 可以增加详细程度级别以记录属性的所有定义. </p>
<h1 id="已弃用的语法"><a href="#已弃用的语法" class="headerlink" title="已弃用的语法"></a>已弃用的语法</h1><p><code>Jade</code>中的新功能:<br>虽然在以前的版本中, 没有命名空间前缀的<code>xacro</code>标签能够被接受并使用, 但是这种草率的语法是我们应当强烈反对的, 因为它阻止在最终的<code>XML</code>中使用这些标签. 从<code>Jade</code>开始, 这种语法已被弃用, 你应该相应地更新你的文件. 以下脚本将为您更新文件: </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find . -iname <span class="string">"*.xacro"</span> | xargs sed -i <span class="string">'s#&lt;\([/]\?\)\(if\|unless\|include\|arg\|property\|macro\|insert_block\)#&lt;\1xacro:\2#g'</span></span><br></pre></td></tr></table></figure>
<hr>
<p>参考链接: </p>
<ul>
<li><a href="http://wiki.ros.org/xacro" target="_blank" rel="noopener">http://wiki.ros.org/xacro</a></li>
<li><a href="https://blog.csdn.net/chishuideyu/article/details/53695392" target="_blank" rel="noopener">https://blog.csdn.net/chishuideyu/article/details/53695392</a></li>
</ul>
]]></content>
      <categories>
        <category>ROS学习</category>
      </categories>
      <tags>
        <tag>ROS</tag>
        <tag>xacro</tag>
      </tags>
  </entry>
  <entry>
    <title>ROS学习-roslaunch_xml</title>
    <url>/posts/73359715/</url>
    <content><![CDATA[<p>这个页面描述了用于<code>roslaunch</code>的<code>.launch</code>文件的<code>XML</code>格式. 有关<code>roslaunch</code>的背景、功能和相关工具, 请先访问<code>roslaunch</code>页面. </p>
<a id="more"></a>
<p><a href="#%e6%96%87%e4%bb%b6%e8%a7%a3%e6%9e%90%e9%a1%ba%e5%ba%8f">文件解析顺序</a><br><a href="#%e7%bd%ae%e6%8d%a2%e5%8f%82%e6%95%b0">置换参数</a>  </p>
<ul>
<li><a href="#env-environmentvariable">env ENVIRONMENT_VARIABLE</a>  </li>
<li><a href="#optenv-environmentvariable%e5%92%8coptenv-environmentvariable-defaultvalue">optenv ENVIRONMENT_VARIABLE / optenv ENVIRONMENT_VARIABLE default_value</a>  </li>
<li><a href="#find-pkg">find pkg</a>  </li>
<li><a href="#anon-name">anon name</a>  </li>
<li><a href="#arg-variblename">arg varible_name</a>  </li>
<li><a href="#eval-expression-new-in-kinetic">eval expression</a>  </li>
</ul>
<p><a href="#3-if-%e5%92%8c-unless-%e5%b1%9e%e6%80%a7">IF 和 UNLESS 属性</a></p>
<p><a href="#%e5%8f%82%e8%80%83%e6%a0%87%e7%ad%be">参考标签</a>  </p>
<ul>
<li><a href="#launch">launch</a>  </li>
<li><a href="#node">node</a></li>
<li><a href="#param">param</a></li>
<li><a href="#rosparam">rosparam</a> </li>
<li><a href="#remap">remap</a></li>
<li><a href="#machine">machine</a></li>
<li><a href="#include">include</a>  </li>
<li><a href="#env">env</a>  </li>
<li><a href="#test">test</a></li>
<li><a href="#arg">arg</a></li>
<li><a href="#group">group</a></li>
</ul>
<p><a href="#launch%e6%96%87%e4%bb%b6%e7%9a%84%e4%be%8b%e5%ad%90">launch文件的例子</a>  </p>
<ul>
<li><a href="#%e4%b8%80%e4%b8%aa%e7%ae%80%e5%8d%95%e7%9a%84%e4%be%8b%e5%ad%90">一个简单的例子</a></li>
<li><a href="#%e4%b8%80%e4%b8%aa%e5%a4%8d%e6%9d%82%e4%b8%80%e7%82%b9%e7%9a%84%e4%be%8b%e5%ad%90">一个复杂一点的例子</a></li>
<li><a href="#%e8%ae%be%e7%bd%ae%e5%8f%82%e6%95%b0">设置参数</a></li>
</ul>
<h2 id="文件解析顺序"><a href="#文件解析顺序" class="headerlink" title="文件解析顺序"></a>文件解析顺序</h2><p><code>roslaunch</code> 以单程的方式解析XML格式文件, <code>include</code> 是以深度优先的方式解析内容, 而标签<code>Tag</code>以串行的方式处理, 所以一个参数的最后一次设置被认定为有效值. 也就是说在<code>. launch</code>文件中同样的设置可能存在多处, 比如在开头定义了一个变量, 遵循着尽量节省空间的想法, 在后面的定义中又对这个变量进行了重新赋值, 以便重新利用, 在这种情况下, 在整个<code>launch</code>文件解析完成后, 最终进行的那次设置是有效的, 但也并不保证一定有效, 不排除在其它的文件中对变量进行了重命名, 所以推荐使用<code>$(arg)/&lt;arg&gt;</code>的方式进行覆写. </p>
<h2 id="置换参数"><a href="#置换参数" class="headerlink" title="置换参数"></a>置换参数</h2><p><code>roslaunch</code>标签属性可以使用置换参数, <code>roslaunch</code>将在启动节点之前解析这些置换参数. 目前支持的置换参数是：</p>
<h3 id="env-ENVIRONMENT-VARIABLE"><a href="#env-ENVIRONMENT-VARIABLE" class="headerlink" title="$(env ENVIRONMENT_VARIABLE)"></a><code>$(env ENVIRONMENT_VARIABLE)</code></h3><p>其中的<script type="math/tex">`是一个置换处理标志, 类似`shell`中的`</script>. 从当前环境变量替换变量的值. 如果没有设置环境变量, 启动将失败. 该值不能被<code>&lt;env&gt;</code>标签覆盖. —就是说用环境变量<code>ENVIRONMENT_VARIABLE</code>设置的值来替换目标值. 例子：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"variable_name"</span> <span class="attr">value</span>=<span class="string">"$(env NUM_CPUS)"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>param</code>是<code>launch</code>文件参数定义的标签, <code>name</code>属性表示定义的变量名称, <code>value</code>属性表示对定义变量进行赋值或替代. 类似于<code>variable_name=$(env NUM_CPUS)</code>. 如果没有设置环境变量<code>NUM_CPUS</code>, <code>roslaunch</code>启动时将报错. </p>
<h3 id="optenv-ENVIRONMENT-VARIABLE-和-optenv-ENVIRONMENT-VARIABLE-default-value"><a href="#optenv-ENVIRONMENT-VARIABLE-和-optenv-ENVIRONMENT-VARIABLE-default-value" class="headerlink" title="$(optenv ENVIRONMENT_VARIABLE)和$(optenv ENVIRONMENT_VARIABLE default_value)"></a><code>$(optenv ENVIRONMENT_VARIABLE)</code>和<code>$(optenv ENVIRONMENT_VARIABLE default_value)</code></h3><p>和上条的区别在于, <code>optenv</code>表示这是一个可选的环境变量(<code>optional environment</code>). 假如没有设置环境变量<code>ENVIRONMENT_VARIABLE</code>, 若提供了<code>default_value</code>值, 则, 则用<code>default_value</code>替代目标变量, 若没有提供该值, 则用空字符串表示(<code>roslaunch</code>启动时, 不会报错). <code>default_value</code>的值可以是包含被空格分隔的多字符. </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 若设置了环境变量 NUM_CPUS, 则 foo = $NUM_CPUS, 否则 foo = "1". 如果没有默认值 1, 那么 foo = "". --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"foo"</span> <span class="attr">value</span>=<span class="string">"$(optenv NUM_CPUS 1)"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 若设置了环境变量 CONFIG_PATH, 则 foo = $CONFIG_PATH, 否则 foo = "/home/marvin/ros_workspace". --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"foo"</span> <span class="attr">value</span>=<span class="string">"$(optenv CONFIG_PATH /home/marvin/ros_workspace)"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 若设置了环境变量 VARIABLE, 则 foo = $VARIABLE, 否则 foo = "ros rocks". 变量可以包含空格字符串. --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"foo"</span> <span class="attr">value</span>=<span class="string">"$(optenv VARIABLE ros rocks)"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="find-pkg"><a href="#find-pkg" class="headerlink" title="$(find pkg)"></a><code>$(find pkg)</code></h3><p>查找包路径.  例如<code>$(find rospy)/manifest.xml</code>指定包相对路径。包目录的完整文件路径将被内联替换。强烈建议使用包相对路径，因为硬编码路径会限制启动配置的可移植性。前斜杠和后斜杠将按惯例被解析为本地文件系统。</p>
<h3 id="anon-name"><a href="#anon-name" class="headerlink" title="$(anon name)"></a><code>$(anon name)</code></h3><p>产生基于名称的匿名ID, 主要用于节点名称属性中创建匿名节点, 并检查是否有相同的匿名名字, 因为ROS中名字作为标识符要求具有唯一性. 其中的anon是anonymous的简写. 例如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">"$(anon talk_01)"</span> <span class="attr">pkg</span>=<span class="string">"rospy_tutorials"</span> <span class="attr">type</span>=<span class="string">"talker.py"</span> /&gt;</span>   </span><br><span class="line"><span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">"$(anon talk_01)"</span> <span class="attr">pkg</span>=<span class="string">"rospy_tutorials"</span> <span class="attr">type</span>=<span class="string">"talker.py"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>则会产生错误, 因为系统检测到了两个节点具有相同的匿名名字. </p>
<h3 id="arg-varible-name"><a href="#arg-varible-name" class="headerlink" title="$(arg varible_name)"></a><code>$(arg varible_name)</code></h3><p>解析由<code>&lt;arg&gt;</code>标签指定的变量值. 必须在声明<code>arg</code>的同一启动文件中有对应的<code>&lt;arg&gt;</code>标签。 例如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"foo"</span> <span class="attr">value</span>=<span class="string">"$(arg my_foo)"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>将<code>my_foo</code>的值赋给参数<code>foo</code>. 这样在解析<code>my_foo</code>的值的时候才能正常进行. 就如同你在表达式中用一个变量进行计算, 你必须在计算之前就已经定义过这个变量才可以. 再如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">"add_two_ints_server"</span> <span class="attr">pkg</span>=<span class="string">"beginner_tutorials"</span> <span class="attr">type</span>=<span class="string">"add_two_ints_server"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">"add_two_ints_client"</span> <span class="attr">pkg</span>=<span class="string">"beginner_tutorials"</span> <span class="attr">type</span>=<span class="string">"add_two_ints_client"</span> <span class="attr">args</span>=<span class="string">"$(arg a) $(arg b)"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>其中的<code>$(arg a)</code>和<code>$(arg b)</code>则是对节点所需要的变量进行声明, 这样你在对节点进行参数传递的时候就可以用以下代码进行：<br><code>roslaunch beginner_tutorials launch_file.launch a:=1 b:=5</code></p>
<h3 id="eval-lt-expression-gt-New-in-Kinetic"><a href="#eval-lt-expression-gt-New-in-Kinetic" class="headerlink" title="$(eval &lt;expression&gt;) New in Kinetic"></a><code>$(eval &lt;expression&gt;)</code> <strong>New in Kinetic</strong></h3><p>允许计算任意复杂的<code>python</code>表达式. 例如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"circumference"</span> <span class="attr">value</span>=<span class="string">"$(eval 2. * 3. 1415 * arg('radius'))"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>会根据给定的<code>radius</code>进行计算后将结果赋给<code>circumference</code>. 作为限制, <code>$(eval)</code>的作用范围要跨越表示整个表达式的字符串, 如果在其中插入其它属性是不可行的. 例如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"a_name"</span> <span class="attr">value</span>=<span class="string">"$(arg r_dis) $(eval 6*7) bar"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>是不可行的. 为了弥补这个限制，所有的替换命令都可以作为函数在eval中使用:   </p>
<blockquote>
<p><code>&quot;$(eval arg(&#39;sth&#39;) + env(&#39;PATH&#39;) + &#39;bar&#39; + find(&#39;pkg&#39;))&quot;</code>  </p>
</blockquote>
<p>为了方便起见，参数也是隐式解析的，即以下两个表达式是相同的:  </p>
<blockquote>
<p><code>&quot;$(eval arg(&#39;foo&#39;))&quot;</code><br><code>&quot;$(eval foo)&quot;</code></p>
</blockquote>
<h2 id="IF-和-UNLESS-属性"><a href="#IF-和-UNLESS-属性" class="headerlink" title="IF 和 UNLESS 属性"></a><code>IF</code> 和 <code>UNLESS</code> 属性</h2><p>所有的标签都支持<code>if</code>和<code>unless</code>属性, 此类属性是基于计算的值包含或是排除一个标签的内容. </p>
<blockquote>
<p><code>if = value (optional)</code><br>如果value的值为真则包含标签及内容. </p>
<p><code>unless = value (optional)</code><br>如果值为假, 则包括此内容. </p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">group</span> <span class="attr">if</span>=<span class="string">"$(arg foo)"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- stuff that will only be evaluated if foo is true --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">group</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"foo"</span> <span class="attr">value</span>=<span class="string">"bar"</span> <span class="attr">unless</span>=<span class="string">"$(arg foo)"</span> /&gt;</span>  </span><br><span class="line"><span class="comment">&lt;!-- This param won't be set when "unless" condition is met --&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="参考标签"><a href="#参考标签" class="headerlink" title="参考标签"></a>参考标签</h2><h3 id="lt-launch-gt"><a href="#lt-launch-gt" class="headerlink" title="&lt;launch&gt;"></a><code>&lt;launch&gt;</code></h3><blockquote>
<p><code>&lt;launch&gt;</code>标签为所有roslaunch文件的根标签, 可以将其理解为所有其它标签的容器. 以下为<code>&lt;launch&gt;</code>标签与其它标签的关系：</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">remap</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">machine</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rosparam</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">env</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">test</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">arg</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">group</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="lt-node-gt"><a href="#lt-node-gt" class="headerlink" title="&lt;node&gt;"></a><code>&lt;node&gt;</code></h3><p>用来启动节点, 但不保证节点的启动顺序. </p>
<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">pkg="mypackage"</span><br><span class="line"><span class="comment">&lt;!--指定所用的包--&gt;</span></span><br><span class="line"></span><br><span class="line">type="nodetype"</span><br><span class="line"><span class="comment">&lt;!--指定对应的可执行程序的名字--&gt;</span></span><br><span class="line"></span><br><span class="line">name="nodename"</span><br><span class="line"><span class="comment">&lt;!--指定节点名称, 但不能在这里加入命名空间名称--&gt;</span></span><br><span class="line"></span><br><span class="line">args="arg1 arg2 arg3"</span><br><span class="line"><span class="comment">&lt;!--声明或传递参数(optional)--&gt;</span></span><br><span class="line"></span><br><span class="line">machine="machine-name"</span><br><span class="line"><span class="comment">&lt;!--在指定的机器上启动节点(optional)--&gt;</span></span><br><span class="line"></span><br><span class="line">respawn="true"</span><br><span class="line"><span class="comment">&lt;!--如果节点失败则重新启动(optional)--&gt;</span></span><br><span class="line"></span><br><span class="line">respawn_delay="30" </span><br><span class="line"><span class="comment">&lt;!--如果上rospawn属性为真, 则等待一定的时间之后重新启动节点(optional, New in indigo)--&gt;</span></span><br><span class="line"></span><br><span class="line">required="true"</span><br><span class="line"><span class="comment">&lt;!--将节点定义为必需节点, 如果本节点失效, 则关闭整个文件(optional)--&gt;</span></span><br><span class="line"></span><br><span class="line">ns="nnss"</span><br><span class="line"><span class="comment">&lt;!--在一个命名空间中启动节点(optional)--&gt;</span></span><br><span class="line"></span><br><span class="line">clear_params="true|false"</span><br><span class="line"><span class="comment">&lt;!--在节点启动之前是否清空所在命名空间中的变量(optional)--&gt;</span></span><br><span class="line"></span><br><span class="line">output="log|screen"</span><br><span class="line"><span class="comment">&lt;!--指定输出的对象(optional)--&gt;</span></span><br><span class="line"></span><br><span class="line">cwd="ROS_HOME|node"</span><br><span class="line"><span class="comment">&lt;!--指定node则节点工作路径与其可执行程序路径相同(optional)--&gt;</span></span><br><span class="line"></span><br><span class="line">launch-prefix="prefix arguments"</span><br><span class="line"><span class="comment">&lt;!--预先处理指令或参数(optional, 支持多种工具)--&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="元素"><a href="#元素" class="headerlink" title="元素"></a>元素</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">node</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">env</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">remap</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rosparam</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">node</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="lt-param-gt"><a href="#lt-param-gt" class="headerlink" title="&lt;param&gt;"></a><code>&lt;param&gt;</code></h3><p>用于在参数服务器中定义参数. 其属性参数如下所示：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">name="namespace/name"</span><br><span class="line"><span class="comment">&lt;!-- 参数名称. 在这个名称定义中是可以使用命名空间的, 而在node的名称定义中不能使用命名空间, 这个是有区别的. 但是应该避免指定全局的名称.  --&gt;</span></span><br><span class="line"></span><br><span class="line">value="value"</span><br><span class="line"><span class="comment">&lt;!-- 定义参数的值, 如果这一属性忽略掉了, 但必须指定 binfile, textfile or command.  --&gt;</span></span><br><span class="line"></span><br><span class="line">type="str|int|double|bool|yaml"</span><br><span class="line"><span class="comment">&lt;!-- 指定参数的类型(optional), 如果不指定则会自动识别类型, 规则如下：</span></span><br><span class="line"><span class="comment">1. 有“. ”的认为是浮点数, 没有的则认为是整型. </span></span><br><span class="line"><span class="comment">2. ”true” 和 “false” 被认为是逻辑变量 (not case-sensitive). </span></span><br><span class="line"><span class="comment">3. 其它的所有都为string型.  --&gt;</span></span><br><span class="line"></span><br><span class="line">textfile="$(find pkg-name)/path/file.txt"</span><br><span class="line"><span class="comment">&lt;!-- 文件的内容被存储为string类型用以替代目标变量(optional). 该文件必须是本地可访问的, 但是强烈建议使用包相对路径$(find)/file.txt的语法来指定位置。  --&gt;</span></span><br><span class="line"></span><br><span class="line">binfile="$(find pkg-name)/path/file"</span><br><span class="line"><span class="comment">&lt;!-- 内容将被存储为 base64-encoded XML-RPC 二进制对象用以替代目标变量(optional). 同上建议相对路径指定位置 --&gt;</span></span><br><span class="line"></span><br><span class="line">command="$(find pkg-name)/exe '$(find pkg-name)/arg. txt'"(optional)</span><br><span class="line"><span class="comment">&lt;!-- 执行某项命令, 命令的输出将被存储为一个string类型以替代目标变量. 文件的路径变量需要用单引号包括.  --&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在参数服务器中定义名称为：publish_frequency, 类型为：double, 值为：10.0 的变量.  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"publish_frequency"</span> <span class="attr">type</span>=<span class="string">"double"</span> <span class="attr">value</span>=<span class="string">"10.0"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 如果是加载 YAML 文件可以用以下代码，其中的 file 属性要指定路径和文件名.  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">rosparam</span> <span class="attr">command</span>=<span class="string">"load"</span> <span class="attr">file</span>=<span class="string">"FILENAME"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="lt-rosparam-gt"><a href="#lt-rosparam-gt" class="headerlink" title="&lt;rosparam&gt;"></a><code>&lt;rosparam&gt;</code></h3><p>支持从<code>YAML</code>文件读取与卸载参数.</p>
<h4 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- rosparam的命令, 可以指定 加载|卸载|删除 对应的参数.  --&gt;</span></span><br><span class="line">command="load|dump|delete" (optional, default=load)</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 指定文件所要求的路径.  --&gt;</span></span><br><span class="line">file="$(find pkg-name)/path/my. yaml" (load or dump commands)</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 参数名称 --&gt;</span></span><br><span class="line">param="param-name"</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 设定参数给指定的命名空间（设定参数的作用域） --&gt;</span></span><br><span class="line">ns="namespace" (optional)</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 是否运允许使用YAML文件中置换参数 --&gt;</span></span><br><span class="line">subst_value=true|false (optional)</span><br></pre></td></tr></table></figure>
<h4 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 加载.yaml文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">rosparam</span> <span class="attr">command</span>=<span class="string">"load"</span> <span class="attr">file</span>=<span class="string">"$(find rosparam)/example.yaml"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 卸载.yaml文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">rosparam</span> <span class="attr">command</span>=<span class="string">"delete"</span> <span class="attr">param</span>=<span class="string">"my/param"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 定义一个变量 a_list, 而变量的值即为标签之间的所有内容, 即 a_list = [1, 2, 3, 4, 5] --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">rosparam</span> <span class="attr">param</span>=<span class="string">"a_list"</span>&gt;</span>[1, 2, 3, 4]<span class="tag">&lt;/<span class="name">rosparam</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">rosparam</span>&gt;</span></span><br><span class="line">  a: 1</span><br><span class="line">  b: 2</span><br><span class="line"><span class="tag">&lt;/<span class="name">rosparam</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 参数置换允许您使用 roslaunch args 来表示一个 YAML 字符串的全部或部分 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 如果subst_value为false, 表示不允许使用替代标签, 则输出的blacklist只是一个字符串$(arg whitelist); 但如果为true则表示允许使用替代标签, 则blacklist输出的值为[3, 2].  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">"whitelist"</span> <span class="attr">default</span>=<span class="string">"[3, 2]"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">rosparam</span> <span class="attr">param</span>=<span class="string">"whitelist"</span> <span class="attr">subst_value</span>=<span class="string">"True"</span>&gt;</span>$(arg whitelist)<span class="tag">&lt;/<span class="name">rosparam</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 它们对于在yaml字符串中嵌入$(find…)和其他替换模式也很有用。 --&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="lt-remap-gt"><a href="#lt-remap-gt" class="headerlink" title="&lt;remap&gt;"></a><code>&lt;remap&gt;</code></h3><p>用来通过名称进行参数之间的映射. 其属性如下：</p>
<h4 id="属性-2"><a href="#属性-2" class="headerlink" title="属性"></a>属性</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">from="original-name"</span><br><span class="line"><span class="comment">&lt;!-- 指定节点原来要监听的话题的名称.  --&gt;</span></span><br><span class="line"></span><br><span class="line">to="new-name"</span><br><span class="line"><span class="comment">&lt;!-- 指定节点实际要监听的话题的名称.  --&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">remap</span> <span class="attr">from</span>=<span class="string">"chatter"</span> <span class="attr">to</span>=<span class="string">"hello"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 此行代码表明要将原来应监听chatter话题的节点改到监听hello话题.  --&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="lt-machine-gt"><a href="#lt-machine-gt" class="headerlink" title="&lt;machine&gt;"></a><code>&lt;machine&gt;</code></h3><p><code>&lt;machine&gt;</code>标签声明一台可以运行<code>ROS</code>节点的机器。如果在本地启动所有节点，则不需要此标签。它主要用于声明远程机器的<code>SSH</code>和<code>ROS</code>环境变量设置，不过您也可以使用它来声明关于本地机器的信息。</p>
<h4 id="属性-3"><a href="#属性-3" class="headerlink" title="属性"></a>属性</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">name="machine-name"</span><br><span class="line"><span class="comment">&lt;!-- 要分配给机器的名称。这对应于&lt;node&gt;标记的machine属性的名称。 --&gt;</span></span><br><span class="line"></span><br><span class="line">address="blah.willowgarage.com"</span><br><span class="line"><span class="comment">&lt;!-- 机器的远程地址或主机名 --&gt;</span></span><br><span class="line"></span><br><span class="line">env-loader="/opt/ros/fuerte/env.sh" </span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- New in Fuerte. 指定远程计算机上的环境文件。环境文件必须是一个设置了所有需要环境变量的shell脚本，并提供参数执行exec --&gt;</span></span><br><span class="line"></span><br><span class="line">default="true|false|never" (optional)</span><br><span class="line"><span class="comment">&lt;!-- 将此机器设置为节点的默认分配机器。默认设置只适用于后续在同一范围内定义的节点。注意:如果没有默认机器，则使用本地机器。可以通过设置default="never"来阻止机器被选中，在这种情况下，只能显式地分配机器。 --&gt;</span></span><br><span class="line"></span><br><span class="line">user="username" (optional)</span><br><span class="line"><span class="comment">&lt;!-- 登录机器的ssh用户名, 如果不需要可以忽略 --&gt;</span></span><br><span class="line"></span><br><span class="line">password="passwhat"(strongly discouraged)</span><br><span class="line"><span class="comment">&lt;!-- ssh登录密码。强烈建议您配置SSH密钥和SSH代理，这样您就可以使用证书登录了 --&gt;</span></span><br><span class="line"></span><br><span class="line">timeout="10.0" (optional)</span><br><span class="line"><span class="comment">&lt;!-- 登录超时检测时间，默认设置为10秒。虽然您可以使用此设置来允许较慢的连接，但需要更改此参数通常是您的整个ROS图将出现通信问题的症状（While you can use this setting to allow for slower connections, needing to change this parameter is generally a symptom that your overall ROS graph will have communication issues.） --&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="例子-3"><a href="#例子-3" class="headerlink" title="例子"></a>例子</h4><p>下面的示例显示如何配置节点“footalker”来运行另一台机器。它使用Fuerte附带的默认的env-loader文件。注：<strong><code>Basic (ROS Fuerte and later) using env-loader</code></strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">machine</span> <span class="attr">name</span>=<span class="string">"foo"</span> <span class="attr">address</span>=<span class="string">"foo-address"</span> <span class="attr">env-loader</span>=<span class="string">"/opt/ros/fuerte/env.sh"</span> <span class="attr">user</span>=<span class="string">"someone"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">machine</span>=<span class="string">"foo"</span> <span class="attr">name</span>=<span class="string">"footalker"</span> <span class="attr">pkg</span>=<span class="string">"test_ros"</span> <span class="attr">type</span>=<span class="string">"talker.py"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>下面是一个ev -loader脚本示例。如果你想使用不同的环境配置, 将/opt/ros/fuerte/setup.sh替换为另外的安装文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line">./opt/ros/fuerte/setup.sh</span><br><span class="line"><span class="built_in">exec</span> <span class="string">"<span class="variable">$@</span>"</span></span><br></pre></td></tr></table></figure>
<p>此外，如果要从<code>rosws</code>工作空间中加载源：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> /home/username/path/to/workspace/setup.bash</span><br><span class="line"><span class="built_in">exec</span> <span class="string">"<span class="variable">$@</span>"</span></span><br></pre></td></tr></table></figure>
<h3 id="lt-include-gt"><a href="#lt-include-gt" class="headerlink" title="&lt;include&gt;"></a><code>&lt;include&gt;</code></h3><p><code>&lt;include&gt;</code>标记允许您将另一个<code>roslaunch XML</code>文件导入当前文件。它将被导入到当前的文档范围，包括<code>&lt;group&gt;</code>和<code>&lt;remap&gt;</code>标签。除了<code>&lt;master&gt;</code>标记外，<code>include</code>文件中的所有内容都将被导入。<code>&lt;master&gt;</code>标签仅在顶级文件中被遵守。</p>
<h4 id="属性-4"><a href="#属性-4" class="headerlink" title="属性"></a>属性</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">file="$(find pkg-name)/path/filename.xml"</span><br><span class="line"><span class="comment">&lt;!-- 指定要包含的文件路径.  --&gt;</span></span><br><span class="line"></span><br><span class="line">ns="namespace_name" (optional)</span><br><span class="line"><span class="comment">&lt;!-- 指定要导入文件的命名空间.  --&gt;</span></span><br><span class="line"></span><br><span class="line">clear_params="true|false" (optional Default: false)</span><br><span class="line"><span class="comment">&lt;!-- 在文件加载之前删除&lt;include&gt;的命名空间中的所有参数, 缺省为false, 此参数要谨慎使用, 用之前要核对好命名空间名称.  --&gt;</span></span><br><span class="line"></span><br><span class="line">pass_all_args="true|false" (optional Default: false) </span><br><span class="line"><span class="comment">&lt;!-- 如果为true，所有当前上下文的args将被加入到在处理&lt;include&gt;文件时创建的子上下文中.  --&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="元素："><a href="#元素：" class="headerlink" title="元素："></a>元素：</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">include</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">env</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="lt-env-gt"><a href="#lt-env-gt" class="headerlink" title="&lt;env&gt;"></a><code>&lt;env&gt;</code></h3><p>此标签用来设置将要启动的节点的环境变量, 其可以在<code>&lt;launch&gt;</code>, <code>&lt;include&gt;</code>, <code>&lt;node&gt;</code>和<code>&lt;machine&gt;</code>标签中使用. 当在<code>&lt;launch&gt;</code>中使用时, <code>&lt;env&gt;</code>标签作用于其后声明的所有节点. 但是用此标签声明的环境变量对于<code>$(env …)</code>不可见, 所以并不能用<code>$(env …)</code>对其它变量的值进行置换, 所以<code>&lt;env&gt;</code>标签不能用来参数化launch文件.</p>
<h4 id="属性-5"><a href="#属性-5" class="headerlink" title="属性"></a>属性</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">name="environment-variable-name"</span><br><span class="line"><span class="comment">&lt;!-- 此属性用来设置环境变量名称.  --&gt;</span></span><br><span class="line"></span><br><span class="line">value="environment-variable-value"</span><br><span class="line"><span class="comment">&lt;!-- 此属性用来设置环境变量值.  --&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="lt-test-gt"><a href="#lt-test-gt" class="headerlink" title="&lt;test&gt;"></a><code>&lt;test&gt;</code></h3><p><code>&lt;test&gt;</code>标签在语法上类似于<code>&lt;node&gt;</code>标签, 都是指定一个<code>ROS</code>节点运行, 但是<code>&lt;test&gt;</code>标签表明当前要运行的节点是一个测试节点. </p>
<p><code>&lt;test&gt;</code>与<code>&lt;node&gt;</code>具有大部分相同的属性, 但以下内容是不同的：  </p>
<ul>
<li>没有respawn属性 (测试节点必须要被终止, 所以它们没有重启属性)</li>
<li>没有输出属性, 因为测试节点有其输出记录机制. </li>
<li>Machine属性被忽略. </li>
</ul>
<h4 id="属性-6"><a href="#属性-6" class="headerlink" title="属性"></a>属性</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">pkg="mypackage"</span><br><span class="line"><span class="comment">&lt;!-- 这一属性是必需的属性, 指定节点的包名称.  --&gt;</span></span><br><span class="line"></span><br><span class="line">test-name="test_name"</span><br><span class="line"><span class="comment">&lt;!-- 必须的属性, 指定测试节点的名称.  --&gt;</span></span><br><span class="line"></span><br><span class="line">type="nodetype"</span><br><span class="line"><span class="comment">&lt;!-- 必须的属性, 指定测试节点所对应的可执行程序名称.  --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 标签可选择的属性如下： --&gt;</span></span><br><span class="line">name="nodename"</span><br><span class="line"><span class="comment">&lt;!-- 节点名称. PS:名称中不能包含命名空间, 如果要指定要使用ns属性, 如果此属性未指定, 则test-name将被作为节点名称.  --&gt;</span></span><br><span class="line"></span><br><span class="line">args="arg1 arg2 arg3"</span><br><span class="line"><span class="comment">&lt;!-- 用测试节点传递参数.  --&gt;</span></span><br><span class="line"></span><br><span class="line">clear_params="true|false"</span><br><span class="line"><span class="comment">&lt;!-- 如果是true, 则在启动之前清空当前节点私有命名空间中的全部参数.  --&gt;</span></span><br><span class="line"></span><br><span class="line">cwd="ROS_HOME|node"</span><br><span class="line"><span class="comment">&lt;!-- 指定工作路径. 如果是node则节点的工作目录与节点的可执行程序目录相同.  --&gt;</span></span><br><span class="line"></span><br><span class="line">launch-prefix="prefix arguments"</span><br><span class="line"><span class="comment">&lt;!-- 节点启动之前的预置参数或命令.  --&gt;</span></span><br><span class="line"></span><br><span class="line">ns="namespace_name"</span><br><span class="line"><span class="comment">&lt;!-- 在指定的命名空间中启动节点.  --&gt;</span></span><br><span class="line"></span><br><span class="line">retry="0"</span><br><span class="line"><span class="comment">&lt;!-- 用于有时可能失效的随机过程, 设置重新尝试的次数.  --&gt;</span></span><br><span class="line"></span><br><span class="line">time-limit="60. 0"</span><br><span class="line"><span class="comment">&lt;!-- 认定节点启动失败之前要经历的时间, 缺省为60s.  --&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="例子-4"><a href="#例子-4" class="headerlink" title="例子"></a>例子</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">test</span> <span class="attr">test-name</span>=<span class="string">"test"</span> <span class="attr">pkg</span>=<span class="string">"mypkg"</span> <span class="attr">type</span>=<span class="string">"test. py"</span> <span class="attr">time-limit</span>=<span class="string">"10. 0"</span> <span class="attr">args</span>=<span class="string">"--test1 --test2"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 上行代码指定要测试的节点的名称, 包名称, 可执行程序名称, 测试时间跨度和要传递的参数 --&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="元素-1"><a href="#元素-1" class="headerlink" title="元素"></a>元素</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">test</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">env</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">remap</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rosparam</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">test</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="lt-arg-gt"><a href="#lt-arg-gt" class="headerlink" title="&lt;arg&gt;"></a><code>&lt;arg&gt;</code></h3><p><code>&lt;arg&gt;</code>标签允许通过命令行、<code>&lt;include&gt;</code>标签或者更上层的文件传递指定的值，用来创建可以重用或者可配置的的<code>launch</code>文件. 但<code>&lt;arg&gt;</code>标签是非全局的, 一个声明只针对一个<code>launch</code>文件, 如同局部变量一样。如果要在一个包含文件<code>include file</code>中使用, 则必须要显式的值传递. </p>
<p><code>&lt;arg&gt;</code>可以通过以下三种方式使用:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">"foo"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 声明了一个foo变量。foo必须通过命令行传递或通过&lt;include&gt;标签进行传递.  --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">"foo"</span> <span class="attr">default</span>=<span class="string">"1"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 声明变量foo, 并赋予一个缺省值1. foo可以通过命令行覆写或&lt;include&gt;标签进行值传递使用.  --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">"foo"</span> <span class="attr">value</span>=<span class="string">"bar"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 声明了一个值为bar的常量foo。foo的值不能被覆写。此用法支持启动文件的内部参数化，而无需在更高级别暴露该参数。 --&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="属性-7"><a href="#属性-7" class="headerlink" title="属性"></a>属性</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">name="arg_name"</span><br><span class="line"><span class="comment">&lt;!-- 指定变量名.  --&gt;</span></span><br><span class="line"></span><br><span class="line">default="default value" (optional)</span><br><span class="line"><span class="comment">&lt;!-- 指定变量缺省值, 不能与value属性一起使用.  --&gt;</span></span><br><span class="line"></span><br><span class="line">value="value" (optional)</span><br><span class="line"><span class="comment">&lt;!-- 指定变量值, 不能与default属性一起使用.  --&gt;</span></span><br><span class="line"></span><br><span class="line">doc="description for this arg" (optional) New in Indigo</span><br><span class="line"><span class="comment">&lt;!-- 变量描述.  --&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="例子-5"><a href="#例子-5" class="headerlink" title="例子"></a>例子</h4><ul>
<li>传递一个参数到包含文件中  </li>
</ul>
<p><code>my_file.launch</code>:<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">include</span> <span class="attr">file</span>=<span class="string">"included.launch"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- all vars that included.launch requires must be set --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">"hoge"</span> <span class="attr">value</span>=<span class="string">"fuga"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p><code>included.launch</code>:<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- declare arg to be passed in --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">"hoge"</span> /&gt;</span> </span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- read value of arg --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"param"</span> <span class="attr">value</span>=<span class="string">"$(arg hoge)"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>则当运行<code>my_file.launch</code>文件时, <code>hoge</code>参数会从<code>my_file.launch</code>的<code>&lt;include&gt;</code>标签中传递进入<code>included.launch</code>文件中, 产生一个变量名为<code>param</code>, 值为<code>fuga</code>的变量. 但是由于<code>&lt;arg&gt;</code>定义的为一个文件内部的局部变量(类似于类内的私有变量), 无法从更高一级或外部进行访问, 即不能通过命令行进行赋值, 所以, 当运行：  </p>
<blockquote>
<p><code>roslaunch %YOUR_ROS_PKG% my_file.launch hoge:=my_value</code>  </p>
</blockquote>
<p>时, <code>hoge</code>的值还是原来设定的<code>fuga</code>值, 而不管你在局部的<code>&lt;arg&gt;</code>属性中是用<code>value</code>属性还是<code>default</code>属性. 如果想用自己的定义值在命令行中进行覆盖, 则<code>&lt;arg&gt;</code>标签要使用更高一层级的<code>default</code>属性指定<code>my_file.launch</code>如下所示：<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 即定义一个更高一层次的&lt;arg&gt;标签来执行值传递, 从更高一层级传递到局部再传递到included.launch文件中.  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">"temp"</span>  <span class="attr">default</span>=<span class="string">"fuga"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">file</span>=<span class="string">"$(find your_pkg)/launch/included.launch"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">"param"</span> <span class="attr">value</span>=<span class="string">"$(arg temp)"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>通过命令行传递变量<br><code>roslaunch</code>使用与<code>ROS</code>映射参数相同的语法来指定<code>arg</code>值</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ roslaunch my_file.launch hoge:=my_value  (.launch file is available at the current dir)</span><br><span class="line"></span><br><span class="line">$ roslaunch %YOUR_ROS_PKG% my_file.launch hoge:=my_value</span><br></pre></td></tr></table></figure>
<h3 id="lt-group-gt"><a href="#lt-group-gt" class="headerlink" title="&lt;group&gt;"></a><code>&lt;group&gt;</code></h3><p>可以对一组节点进行设置, 并且可以通过ns属性将一组节点放到一个隔离开的命名空间中. </p>
<h4 id="属性-8"><a href="#属性-8" class="headerlink" title="属性"></a>属性</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">ns="namespace" (optional)</span><br><span class="line"><span class="comment">&lt;!-- 将一组节点指定到一个特定的命名空间中, 命名空间可以是全局的或是局部的, 但并有推荐使用全局的命名空间.  --&gt;</span></span><br><span class="line"></span><br><span class="line">clear_params="true|false" (optional)</span><br><span class="line">在节点启动之前清空<span class="tag">&lt;<span class="name">group</span>&gt;</span>命名空间中的所有参数, 谨慎使用. </span><br><span class="line"><span class="comment">&lt;!-- 内部可使用的标签如下所示： --&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="元素-2"><a href="#元素-2" class="headerlink" title="元素"></a>元素</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">group</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">remap</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">machine</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rosparam</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">env</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">test</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">group</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="launch文件的例子"><a href="#launch文件的例子" class="headerlink" title="launch文件的例子"></a>launch文件的例子</h2><h3 id="一个简单的例子："><a href="#一个简单的例子：" class="headerlink" title="一个简单的例子："></a>一个简单的例子：</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">"talker"</span> <span class="attr">pkg</span>=<span class="string">"rospy_tutorials"</span> <span class="attr">type</span>=<span class="string">"talker"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 在本地使用当前ros环境启动rospy_tutorials包中的可执行程序为talker的节点, 节点名称定义为talker.  --&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="一个复杂一点的例子："><a href="#一个复杂一点的例子：" class="headerlink" title="一个复杂一点的例子："></a>一个复杂一点的例子：</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">machine</span> <span class="attr">name</span>=<span class="string">"local_alt"</span> <span class="attr">address</span>=<span class="string">"localhost"</span> <span class="attr">default</span>=<span class="string">"true"</span> <span class="attr">ros-root</span>=<span class="string">"/u/user/ros/ros/"</span> <span class="attr">ros-package-path</span>=<span class="string">"/u/user/ros/ros-pkg"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 本地的机器已经进行了缺省定义, 这个标签的作用是用指定的ROS_ROOT和ROS_PACKAGE_PATH值对其重新赋值--&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">"listener-1"</span> <span class="attr">pkg</span>=<span class="string">"rospy_tutorials"</span> <span class="attr">type</span>=<span class="string">"listener"</span> /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 启动一个收听节点 --&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">"listener-2"</span> <span class="attr">pkg</span>=<span class="string">"rospy_tutorials"</span> <span class="attr">type</span>=<span class="string">"listener"</span> <span class="attr">args</span>=<span class="string">"-foo arg2"</span> /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 向监听节点中传递参数 --&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">"listener-3"</span> <span class="attr">pkg</span>=<span class="string">"rospy_tutorials"</span> <span class="attr">type</span>=<span class="string">"listener"</span> <span class="attr">respawn</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 一个可以重新启动的节点 --&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">ns</span>=<span class="string">"wg1"</span> <span class="attr">name</span>=<span class="string">"listener-wg1"</span> <span class="attr">pkg</span>=<span class="string">"rospy_tutorials"</span> <span class="attr">type</span>=<span class="string">"listener"</span> <span class="attr">respawn</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 在 'wg1' 命名空间中启动一个节点 --&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">group</span> <span class="attr">ns</span>=<span class="string">"wg2"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 在 'wg2' 命名空间中启动一组节点 --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">remap</span> <span class="attr">from</span>=<span class="string">"chatter"</span> <span class="attr">to</span>=<span class="string">"hello"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- remap在group范围内作用于在其后声明的所有节点 --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">"rospy_tutorials"</span> <span class="attr">type</span>=<span class="string">"listener"</span> <span class="attr">name</span>=<span class="string">"listener"</span> <span class="attr">args</span>=<span class="string">"--test"</span> <span class="attr">respawn</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">"rospy_tutorials"</span> <span class="attr">type</span>=<span class="string">"talker"</span> <span class="attr">name</span>=<span class="string">"talker"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"talker_1_param"</span> <span class="attr">value</span>=<span class="string">"a value"</span> /&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 设置局部变量 --&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">remap</span> <span class="attr">from</span>=<span class="string">"chatter"</span> <span class="attr">to</span>=<span class="string">"hello-1"</span>/&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 节点可以有其自己私有的remap指令 --&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">env</span> <span class="attr">name</span>=<span class="string">"ENV_EXAMPLE"</span> <span class="attr">value</span>=<span class="string">"some value"</span> /&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 为节点设置环境变量 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">node</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">group</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="设置参数"><a href="#设置参数" class="headerlink" title="设置参数"></a>设置参数</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"somestring1"</span> <span class="attr">value</span>=<span class="string">"bar"</span> /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 值类型为string类型 --&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"somestring2"</span> <span class="attr">value</span>=<span class="string">"10"</span> <span class="attr">type</span>=<span class="string">"str"</span> /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 强制使用string类型而不是整型定义参数 --&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"someinteger1"</span> <span class="attr">value</span>=<span class="string">"1"</span> <span class="attr">type</span>=<span class="string">"int"</span> /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 指定为整型 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"someinteger2"</span> <span class="attr">value</span>=<span class="string">"2"</span> /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 自动识别为整型 --&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"somefloat1"</span> <span class="attr">value</span>=<span class="string">"3. 14159"</span> <span class="attr">type</span>=<span class="string">"double"</span> /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 指定为浮点型数据 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"somefloat2"</span> <span class="attr">value</span>=<span class="string">"3. 0"</span> /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 自动识别为浮点型数据 --&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"wg/childparam"</span> <span class="attr">value</span>=<span class="string">"a child namespace parameter"</span> /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 在子命名空间中设置参数 --&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"configfile"</span> <span class="attr">textfile</span>=<span class="string">"$(find roslaunch)/example. xml"</span> /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 向参数服务器中加载文本文件内容 --&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"binaryfile"</span> <span class="attr">binfile</span>=<span class="string">"$(find roslaunch)/example. xml"</span> /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 向参数服务器中加载二进制文件内容 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure>
<hr>
<p>参考链接：</p>
<ul>
<li><a href="http://wiki.ros.org/roslaunch/XML" target="_blank" rel="noopener">http://wiki.ros.org/roslaunch/XML</a></li>
<li><a href="https://blog.csdn.net/u012424737/article/details/78854536" target="_blank" rel="noopener">https://blog.csdn.net/u012424737/article/details/78854536</a></li>
<li><a href="https://blog.csdn.net/weixin_41995979/article/details/81784987" target="_blank" rel="noopener">https://blog.csdn.net/weixin_41995979/article/details/81784987</a></li>
</ul>
]]></content>
      <categories>
        <category>ROS学习</category>
      </categories>
      <tags>
        <tag>ROS</tag>
        <tag>roslaunch</tag>
      </tags>
  </entry>
  <entry>
    <title>ROS学习-controller_manager</title>
    <url>/posts/1366633795/</url>
    <content><![CDATA[<p><code>controller_manager</code>提供硬实时兼容的环来控制的机械手,由一个<code>hardware_interface::RobotHW</code>实例代表(参见<code>hardware_interface</code>包).该<code>controller_manager</code>提供了加载,卸载,启动和停止控制器的基本结构.</p>
<a id="more"></a>
<p>当加载一个控制器时,<code>controller_manager</code>将使用控制器名作为所有控制器特定参数的<code>root</code>,最重要的是,<code>type</code>用于标识要加载哪个插件.</p>
<h1 id="控制器运行的工具-Tools-for-running-controllers"><a href="#控制器运行的工具-Tools-for-running-controllers" class="headerlink" title="控制器运行的工具(Tools for running controllers)"></a>控制器运行的工具(<code>Tools for running controllers</code>)</h1><p>控制器管理器提供的与控制器进行交互的基本结构.根据控制器从启动文件,命令行,或者<code>ROS</code>节点运行,控制管理器提供不同的工具来运行控制器.    </p>
<p><a href="http://wiki.ros.org/controller_manager?action=AttachFile&amp;do=get&amp;target=controller+state.png">controller_manager</a></p>
<h1 id="命令行工具-Command-line-tools"><a href="#命令行工具-Command-line-tools" class="headerlink" title="命令行工具(Command-line tools)"></a>命令行工具(<code>Command-line tools</code>)</h1><h2 id="控制管理器-controller-manager"><a href="#控制管理器-controller-manager" class="headerlink" title="控制管理器(controller_manager)"></a>控制管理器(<code>controller_manager</code>)</h2><p>使用<code>controller_manager</code>工具与从命令行运行的控制器交互.要与特定的控制器进行交互,可以使用:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ rosrun controller_manager controller_manager &lt;<span class="built_in">command</span>&gt; &lt;controller_name&gt;</span><br></pre></td></tr></table></figure>
<p>以下命令可用:<br>|               |                                       |<br>| :—————— | :—————————————————— |<br>| <strong><code>load</code></strong>:   | 加载控制器 (construct and initialize) |<br>| <strong><code>unload</code></strong>: | 卸载控制器 (destruct)                 |<br>| <strong><code>start</code></strong>:  | 启动控制器                            |<br>| <strong><code>stop</code></strong>:   | 结束控制器                            |<br>| <strong><code>spawn</code></strong>:  | 加载并启动控制器                      |<br>| <strong><code>kill</code></strong>:   | 停止并卸载控制器                      |</p>
<p>想获得控制器状态, 用:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ rosrun controller_manager controller_manager &lt;<span class="built_in">command</span>&gt;</span><br></pre></td></tr></table></figure>
<p>以下命令可用:<br>|                                   |                                                                                                               |<br>| :———————————————— | :—————————————————————————————————————————————————————— |<br>| <strong><code>list</code></strong>:                       | 根据执行顺序,列出所有控制器,并给出每个控制器的状态                                                            |<br>| <strong><code>list-types</code></strong>:                 | 列出所有控制器管理知道的控制器类型.如果控制器不在此列表中,将无法加载并启动.                                   |<br>| <strong><code>list-joints</code></strong>:                | 列出所有控制器管理使用的的关节和驱动器的名称.                                                                 |<br>| <strong><code>reload-libraries</code></strong>:           | 重新加载所有可作为插件的控制器库.当我们正在开发控制器时,可以方便的测试控制器代码,而 不用每次都重新启动机器人. |<br>| <strong><code>reload-libraries --restore</code></strong>: | 重新加载所有可作为插件的的控制器库,并把所有控制器恢复到初始状态.                                              |<br>|                                   |                                                                                                               |</p>
<h2 id="加载并启动控制器-spawner"><a href="#加载并启动控制器-spawner" class="headerlink" title="加载并启动控制器(spawner)"></a>加载并启动控制器(<code>spawner</code>)</h2><p>为了立刻自动加载并启动一系列控制器以及立刻停止并卸载这些控制器,使用<code>spawner</code>工具:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ rosrun controller_manager spawner [--stopped] name1 name2 name3</span><br></pre></td></tr></table></figure>
<p>当运行<code>spawner</code>时,列表中控制器将被载入和启动(除非指定<code>--stopped</code>). 当控制器已开启(<code>controllers are up</code>),<code>spawner</code>将保持运行.当你杀死<code>spawner</code>进程(<code>CTRL-C</code>),会自动停止并卸载所有它最开始启动的控制器.</p>
<h2 id="卸载控制器-unspawner"><a href="#卸载控制器-unspawner" class="headerlink" title="卸载控制器(unspawner)"></a>卸载控制器(<code>unspawner</code>)</h2><p>想要自动停止一组控制器,然后重新启动,可使用<code>unspawner</code>工具:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ rosrun controller_manager unspawner name1 name2 name3</span><br></pre></td></tr></table></figure>
<p>列表中的控制器将被停止,但没有卸载.一旦<code>spawner</code>关闭,该控制器将重新启动.</p>
<h2 id="控制器组-controller-group"><a href="#控制器组-controller-group" class="headerlink" title="控制器组(controller_group)"></a>控制器组(<code>controller_group</code>)</h2><p><code>controller_group</code>允许开发者在运行时切换控制器,但是出于一些特殊意图,当你想从一组控制器切换到另一组时,这就不是很方便.<code>controller_group</code>脚本对于那些在<code>ROS parameter controller_groups</code>已经定义的分组的切换就很容易实现.它知道所有包含的控制器,当它切换控制器组时,控制器需要被停止或者被启动.所以,不同的控制器组可以共享某些控制器.</p>
<p><code>controller_groups</code>的一个例子:  </p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">controller_groups:</span></span><br><span class="line">  <span class="attr">production:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">prod_controller_1</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">prod_controller_2</span></span><br><span class="line">  <span class="attr">development:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">devel_controller_1</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">devel_controller_2</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">shared_controller_3</span></span><br><span class="line">  <span class="attr">diagnostics:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">diag_controller_1</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">diag_controller_2</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">shared_controller_3</span></span><br></pre></td></tr></table></figure>
<p>启动<code>controller_groups</code>的脚本:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ rosrun controller_manager controller_group &lt;<span class="built_in">command</span>&gt; &lt;args&gt;</span><br></pre></td></tr></table></figure>
<p>以下命令可用:<br>|                       |                                                                                                                          |<br>| :—————————— | :———————————————————————————————————————————————————————————- |<br>| <strong><code>list</code></strong>:           | 列出所有能在<code>controler_groups</code>参数中找到的组定义                                                                         |<br>| <strong><code>spawn &lt;group&gt;</code></strong>:  | 载入和启动所有包含在名称为<code>&lt;group&gt;</code>组内的所有控制器,通常在<code>ROS launch</code>文件中使用                                         |<br>| <strong><code>switch &lt;group&gt;</code></strong>: | 切换到<code>&lt;group&gt;</code>组.这意味着将停止其他组内正在运行的控制器,但是定在在本组内的不会被停止,然后启动在本组内的未运行的控制器器 |<br>|                       |                                                                                                                          |</p>
<h1 id="创建启动文件-Creating-launch-files"><a href="#创建启动文件-Creating-launch-files" class="headerlink" title="创建启动文件(Creating launch files)"></a>创建启动文件(<code>Creating launch files</code>)</h1><p>我们可以运行<code>controller_manager</code>,从启动文件(<code>launch file</code>)内启动控制器.然而,即使启动文件被撤下,控制器仍会保持.而<code>spawner</code>工具会从启动文件中自动加载,启动,停止和卸载控制器.当启动<code>spawner</code>工具时,它会加载并启动控制器.当你停止<code>spawner</code>(当启动文件被撤下),它将停止并卸载控制器.启动文件可能如下:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">"controller_manager"</span> <span class="attr">type</span>=<span class="string">"spawner"</span> <span class="attr">args</span>=<span class="string">"controller_name1 controller_name2"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>或者,只是想加载控制器,但是还没有启动:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">"controller_manager"</span> <span class="attr">type</span>=<span class="string">"spawner"</span> <span class="attr">args</span>=<span class="string">"--stopped controller_name1 controller_name2"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="图形工具-Graphical-tools"><a href="#图形工具-Graphical-tools" class="headerlink" title="图形工具(Graphical tools)"></a>图形工具(Graphical tools)</h1><p><code>rqt_controller_manager</code>是一个<code>rqt</code>插件,该插件以图形化方式加载,卸载,启动和停止控制器;同时用来显示加载的控制器的信息.</p>
<p>它可以从<code>rqt</code>的<code>Plugin</code>菜单中启动,或者通过命令行单独执行:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rosrun rqt_controller_manager rqt_controller_manager</span><br></pre></td></tr></table></figure>
<h1 id="ROS应用程序接口-ROS-API"><a href="#ROS应用程序接口-ROS-API" class="headerlink" title="ROS应用程序接口(ROS API)"></a><code>ROS</code>应用程序接口(<code>ROS API</code>)</h1><p>为了与另一个<code>ROS</code>节点的控制器交互,控制管理器提供了五种服务调用:</p>
<h2 id="控制管理器-controller-manager-1"><a href="#控制管理器-controller-manager-1" class="headerlink" title="控制管理器(controller_manager)"></a>控制管理器(<code>controller_manager</code>)</h2><h3 id="服务-Services"><a href="#服务-Services" class="headerlink" title="服务(Services)"></a>服务(Services)</h3><p><code>controller_manager/load_controller (controller_manager_msgs/LoadController)</code></p>
<blockquote>
<p>服务请求包含了要加载的控制器的名字,响应包含了一个表示成功或失败的布尔值.</p>
</blockquote>
<p><code>controller_manager/unload_controller (controller_manager_msgs/UnloadController)</code></p>
<blockquote>
<p>服务请求中包含要卸载的控制器的名称,响应包含了一个表示成功或失败的布尔值.控制器只能在当其处于停止状态的时候被卸载.</p>
</blockquote>
<p><code>controller_manager/switch_controller (controller_manager_msgs/SwitchController)</code></p>
<blockquote>
<p>服务请求包含了要开始的控制器的名称列表,要停止的控制器名称列表和一个表明规范性 (<code>strictness: BEST_EFFORT or STRICT</code>)的整型值(<code>int</code>).<code>STRICT</code>表示如果出现任何错误(无效的控制器名称,控制器启动失败,<code>etc</code>),控制器的切换(<code>switching</code>)将会失败并导致空操作(<code>no-op</code>).<code>BEST_EFFORT</code>表示,即使控制器出现了一些问题,该服务仍然会尝试启动/停止余下的控制器.服务响应包含了一个表示成功或失败的布尔值.如果只是停止或者只是启动控制器,控制器启动或停止的列表可能为空.</p>
</blockquote>
<p><code>controller_manager/list_controllers (controller_manager_msgs/ListControllers)</code></p>
<blockquote>
<p>该服务返回所有当前加载的控制器.响应包括以下信息:控制器的名称,状态(运行或停止),类型,硬件接口,和占用的资源.</p>
</blockquote>
<p><code>controller_manager/list_controller_types (controller_manager_msgs/ListControllerTypes)</code></p>
<blockquote>
<p>该服务返回<code>controller_manager</code>已知的所有控制器类型.只有已知的控制器类型可以构建.</p>
</blockquote>
<p><code>controller_manager/reload_controller_libraries (controller_manager_msgs/ReloadControllerLibraries)</code></p>
<blockquote>
<p>服务重新加载所有可作为插件的控制器库.当我们正在开发控制器时,无需每次重新启动机器人 就可以方便的测试控制器代码.此服务只在控制器没有加载情况下工作.</p>
</blockquote>
<p>Translated by Ms Wang 2014-8-19</p>
<p>Wiki: controller_manager (last edited 2014-03-10 15:22:46 by AdolfoRodriguez)</p>
<hr>
<p>参考来源:  </p>
<ul>
<li><a href="http://wiki.ros.org/cn/controller_manager" target="_blank" rel="noopener">http://wiki.ros.org/cn/controller_manager</a></li>
<li><a href="http://wiki.ros.org/controller_manager?distro=kenetic" target="_blank" rel="noopener">http://wiki.ros.org/controller_manager?distro=kenetic</a></li>
</ul>
]]></content>
      <categories>
        <category>ROS学习</category>
      </categories>
      <tags>
        <tag>ROS</tag>
        <tag>controller_manager</tag>
      </tags>
  </entry>
  <entry>
    <title>ROS学习-ur5机器人的gazebo仿真以及controller的使用</title>
    <url>/posts/1500545740/</url>
    <content><![CDATA[<p>这篇文章主要介绍了如何在<code>gazebo</code>中对<code>ur5</code>进行仿真和<code>controller</code>的使用，包括<code>controller_manager</code>的使用和控制器<code>command</code>的主题数据发布。</p>
<a id="more"></a>
<ul>
<li><p>ur机器人的下载编译可以参考官方的帮助文档，下载源码，然后<code>catkin_make</code>，然后<code>source devel/setup.bash</code>载入资源文件。</p>
</li>
<li><p>在<code>gazebo</code>中启动 <code>ur5</code> 模型，终端输入：</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">roslaunch ur_gazebo ur5.launch limited:=<span class="literal">true</span></span><br></pre></td></tr></table></figure>
<ul>
<li>ur5模型的参数服务器中包含两个控制器, <code>position_controllers/JointTrajectoryController</code>和<code>position_controllers/JointGroupPositionController</code>这里先用位置控制模式<code>JointGroupPositionController</code>，就是单独控制关节轴，这样我们可以直观看到关节轴响应了下发的位置指令。</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">arm_controller:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">position_controllers/JointTrajectoryController</span></span><br><span class="line">  <span class="attr">joints:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">shoulder_pan_joint</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">shoulder_lift_joint</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">elbow_joint</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">wrist_1_joint</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">wrist_2_joint</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">wrist_3_joint</span></span><br><span class="line">  <span class="attr">constraints:</span></span><br><span class="line">      <span class="attr">goal_time:</span> <span class="number">0.6</span></span><br><span class="line">      <span class="attr">stopped_velocity_tolerance:</span> <span class="number">0.05</span></span><br><span class="line">      <span class="attr">shoulder_pan_joint:</span> <span class="string">&#123;trajectory:</span> <span class="number">0.1</span><span class="string">,</span> <span class="attr">goal:</span> <span class="number">0.1</span><span class="string">&#125;</span></span><br><span class="line">      <span class="attr">shoulder_lift_joint:</span> <span class="string">&#123;trajectory:</span> <span class="number">0.1</span><span class="string">,</span> <span class="attr">goal:</span> <span class="number">0.1</span><span class="string">&#125;</span></span><br><span class="line">      <span class="attr">elbow_joint:</span> <span class="string">&#123;trajectory:</span> <span class="number">0.1</span><span class="string">,</span> <span class="attr">goal:</span> <span class="number">0.1</span><span class="string">&#125;</span></span><br><span class="line">      <span class="attr">wrist_1_joint:</span> <span class="string">&#123;trajectory:</span> <span class="number">0.1</span><span class="string">,</span> <span class="attr">goal:</span> <span class="number">0.1</span><span class="string">&#125;</span></span><br><span class="line">      <span class="attr">wrist_2_joint:</span> <span class="string">&#123;trajectory:</span> <span class="number">0.1</span><span class="string">,</span> <span class="attr">goal:</span> <span class="number">0.1</span><span class="string">&#125;</span></span><br><span class="line">      <span class="attr">wrist_3_joint:</span> <span class="string">&#123;trajectory:</span> <span class="number">0.1</span><span class="string">,</span> <span class="attr">goal:</span> <span class="number">0.1</span><span class="string">&#125;</span></span><br><span class="line">  <span class="attr">stop_trajectory_duration:</span> <span class="number">0.5</span></span><br><span class="line">  <span class="attr">state_publish_rate:</span>  <span class="number">25</span></span><br><span class="line">  <span class="attr">action_monitor_rate:</span> <span class="number">10</span></span><br><span class="line"><span class="attr">joint_group_position_controller:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">position_controllers/JointGroupPositionController</span></span><br><span class="line">  <span class="attr">joints:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">shoulder_pan_joint</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">shoulder_lift_joint</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">elbow_joint</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">wrist_1_joint</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">wrist_2_joint</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">wrist_3_joint</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>ur5的<code>launch</code>文件中，默认启动的控制器是关节轨迹控制，所以这里涉及到如何切换控制器的操作，详细内容可以参考<code>controller_manager</code>这篇文章。一下给出实际的操作。</p>
</li>
<li><p>首先查看已载入的控制器：可以看到ur内部载入了两个控制器，就是在参数文件中显示的两个，<code>arm_controller</code>和<code>joint_group_position_controller</code>。</p>
</li>
</ul>
<blockquote>
<p><code>rosrun controller_manager controller_manager list</code></p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">arm_controller - hardware_interface::PositionJointInterface ( stopped )</span><br><span class="line">joint_state_controller - hardware_interface::JointStateInterface ( running )</span><br><span class="line">joint_group_position_controller - hardware_interface::PositionJointInterface ( running )</span><br></pre></td></tr></table></figure>
<ul>
<li>暂停<code>arm_controller</code>，执行成功后会显示成功执行信息：</li>
</ul>
<blockquote>
<p><code>rosrun controller_manager controller_manager stop arm_controller</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Stopped [<span class="string">'arm_controller'</span>] successfully</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li>启动<code>joint_group_position_controller</code>，同样也有执行成功与否的信息输出：</li>
</ul>
<blockquote>
<p><code>rosrun controller_manager controller_manager start joint_group_position_controller</code></p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Started [<span class="string">'joint_group_position_controller'</span>] successfully</span><br></pre></td></tr></table></figure>
<ul>
<li><code>controller_manager</code>的详细指令如下：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ rosrun controller_manager controller_manager &lt;<span class="built_in">command</span>&gt; &lt;controller_name&gt;</span><br></pre></td></tr></table></figure>
<p>以下<code>command</code>可用:<br>|               |                                       |<br>| :—————— | :—————————————————— |<br>| <strong><code>load</code></strong>:   | 加载控制器 (construct and initialize) |<br>| <strong><code>unload</code></strong>: | 卸载控制器 (destruct)                 |<br>| <strong><code>start</code></strong>:  | 启动控制器                            |<br>| <strong><code>stop</code></strong>:   | 结束控制器                            |<br>| <strong><code>spawn</code></strong>:  | 加载并启动控制器                      |<br>| <strong><code>kill</code></strong>:   | 停止并卸载控制器                      |<br>|               |                                       |</p>
<ul>
<li><p>开始输入关节位置控制指令</p>
</li>
<li><p>这里可以先查看一下关节位置指令的数据结构</p>
</li>
<li><p>输入: </p>
</li>
</ul>
<blockquote>
<p><code>rostopic list</code>  </p>
</blockquote>
<ul>
<li>可以看到有控制器的一个主题: </li>
</ul>
<blockquote>
<p><code>/joint_group_position_controller/command</code></p>
</blockquote>
<ul>
<li>查看主题信息：该<code>topic</code>的<code>type</code>是<code>std_msgs/Float64MultiArray</code>。因此我们<code>pub</code>这个<code>topic</code>时就需要发送这个数据结构。</li>
</ul>
<blockquote>
<p><code>rostopic info /joint_group_position_controller/command</code></p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Type: std_msgs/Float64MultiArray</span><br><span class="line"></span><br><span class="line">Publishers: None</span><br><span class="line"></span><br><span class="line">Subscribers: </span><br><span class="line"> * /rostopic_120258_1572071888740 (http://localhost:42655/)</span><br><span class="line"> * /gazebo (http://localhost:35425/)</span><br></pre></td></tr></table></figure>
<ul>
<li>发布主题。因为这里<code>Float64MultiArray</code>是一个数组，如果是单个数据类型，那在数据结构后面直接跟具体的数据即可。如果是数组，那需要以<code>python list</code>的方式发送。这里<code>-r 50</code>表示这个<code>topic</code>的发布速率是<code>50hz</code>。然后就可以在<code>gazebo</code>中看到机器人五轴转了一个角度。</li>
</ul>
<blockquote>
<p><code>rostopic pub -r 50 /joint_group_position_controller/command std_msgs/Float64MultiArray &#39;{data: [0,0,0,0,10,30]}&#39;</code></p>
</blockquote>
<ul>
<li>同时可以打开另一个终端，看到发布的<code>topic</code>的详细信息</li>
</ul>
<blockquote>
<p><code>rostopic echo /joint_group_position_controller/command</code></p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">layout: </span><br><span class="line">  dim: []</span><br><span class="line">  data_offset: 0</span><br><span class="line">data: [0.0, 0.0, 0.0, 0.0, 10.0, 30.0]</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ROS学习</category>
      </categories>
      <tags>
        <tag>ROS</tag>
        <tag>gazebo</tag>
        <tag>controller-manager</tag>
        <tag>ur5</tag>
      </tags>
  </entry>
</search>
