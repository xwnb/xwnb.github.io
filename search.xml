<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>SEI CERT C++ Coding Standard 学习及翻译计划</title>
    <url>/posts/3114312552/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><!-- build time:Sat Nov 13 2021 15:45:21 GMT+0000 (Coordinated Universal Time) --><h2 id="稍微说说"><a class="header-anchor" href="#稍微说说">¶</a>稍微说说</h2><p>最近在网上浏览到卡内基梅隆大学 (CMU) 软件工程研究所 (SEI) 发布的安全编码规范。<code>SEI CERT</code> 的规则都是为了确保 C/C++ 编程开发软件系统的安全性、可靠性和稳固性，比如消除一些未定义行为或者可利用漏洞。大致浏览了一下，很多规则相对比较基础，有些规则相对比较隐晦，示例代码很丰富简洁明了，文后还有一些实际漏洞的案例介绍等。规范的内容组织得也非常清晰，一方面是学习一下安全编码，另一方面也作为平时积累和查漏补缺的过程。</p><p>在此，记录一下自己对这份规范的蹩脚翻译，保留了原文英文，以备后用。顺便也提升一下阅读英文技术手册的能力，为了打工恰饭。</p><a id="more"></a><h3 id="更新目录"><a class="header-anchor" href="#更新目录">¶</a>更新目录</h3><ul class="contains-task-list"><li class="task-list-item"><p><input class="task-list-item-checkbox" disabled type="checkbox"> <a href="https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=88046322" target="_blank" rel="noopener">Rule 01. Declarations and Initialization (DCL)</a> 声明和初始化 (DCL)</p></li><li class="task-list-item"><p><input class="task-list-item-checkbox" disabled type="checkbox"> <a href="https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=88046335" target="_blank" rel="noopener">Rule 02. Expressions (EXP)</a> 表达式 (EXP)</p></li><li class="task-list-item"><p><input class="task-list-item-checkbox" disabled type="checkbox"> <a href="https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=88046333" target="_blank" rel="noopener">Rule 03. Integers (INT)</a> 整型 (INT)</p></li><li class="task-list-item"><p><input class="task-list-item-checkbox" checked disabled type="checkbox"> <a href="https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=88046331" target="_blank" rel="noopener">Rule 04. Containers (CTR)</a> 容器 (CTR) —— <em><strong>2020.06.24 完成</strong></em></p><ul class="contains-task-list"><li class="task-list-item"><p><input class="task-list-item-checkbox" checked disabled type="checkbox"> <a href="2020-06-25-CTR50-CPP-%E4%BF%9D%E8%AF%81%E5%AE%B9%E5%99%A8%E7%B4%A2%E5%BC%95%E5%92%8C%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%9C%A8%E6%9C%89%E6%95%88%E8%8C%83%E5%9B%B4%E5%86%85.md">CTR50-CPP. 保证容器索引和迭代器在有效范围内</a></p></li><li class="task-list-item"><p><input class="task-list-item-checkbox" checked disabled type="checkbox"> <a href="2020-06-25-CTR51-CPP-%E4%BD%BF%E7%94%A8%E6%9C%89%E6%95%88%E7%9A%84%E5%BC%95%E7%94%A8%EF%BC%8C%E6%8C%87%E9%92%88%EF%BC%8C%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%9D%A5%E5%BC%95%E7%94%A8%E5%AE%B9%E5%99%A8%E7%9A%84%E5%85%83%E7%B4%A0.md">CTR51-CPP. 使用有效的引用，指针，迭代器来引用容器的元素</a></p></li><li class="task-list-item"><p><input class="task-list-item-checkbox" checked disabled type="checkbox"> <a href="2020-06-25-CTR52-CPP-%E7%A1%AE%E4%BF%9D%E5%BA%93%E5%87%BD%E6%95%B0%E4%B8%8D%E8%A6%81%E6%BA%A2%E5%87%BA.md">CTR52-CPP. 确保库函数不要溢出</a></p></li><li class="task-list-item"><p><input class="task-list-item-checkbox" checked disabled type="checkbox"> <a href="2020-06-25-CTR53-CPP-%E4%BD%BF%E7%94%A8%E6%9C%89%E6%95%88%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8%E8%8C%83%E5%9B%B4.md">CTR53-CPP. 使用有效的迭代器范围</a></p></li><li class="task-list-item"><p><input class="task-list-item-checkbox" checked disabled type="checkbox"> <a href="2020-06-25-CTR54-CPP-%E4%B8%8D%E8%A6%81%E7%9B%B8%E5%87%8F%E4%B8%8D%E6%98%AF%E6%8C%87%E5%90%91%E5%90%8C%E4%B8%80%E4%B8%AA%E5%AE%B9%E5%99%A8%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8">CTR54-CPP. 不要相减不是指向同一个容器的迭代器</a></p></li><li class="task-list-item"><p><input class="task-list-item-checkbox" checked disabled type="checkbox"> <a href="2020-06-25-CTR55-CPP-%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8%E5%AF%B9%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%BD%BF%E7%94%A8%E5%8A%A0%E6%B3%95%E8%BF%90%E7%AE%97%E5%A6%82%E6%9E%9C%E7%BB%93%E6%9E%9C%E4%BC%9A%E6%BA%A2%E5%87%BA">CTR55-CPP. 不要使用对迭代器使用加法运算如果结果会溢出</a></p></li><li class="task-list-item"><p><input class="task-list-item-checkbox" checked disabled type="checkbox"> <a href="2020-06-25-CTR56-CPP-%E4%B8%8D%E8%A6%81%E5%9C%A8%E5%A4%9A%E6%80%81%E5%AF%B9%E8%B1%A1%E4%B8%8A%E4%BD%BF%E7%94%A8%E6%8C%87%E9%92%88%E8%BF%90%E7%AE%97">CTR56-CPP. 不要在多态对象上使用指针运算</a></p></li><li class="task-list-item"><p><input class="task-list-item-checkbox" checked disabled type="checkbox"> <a href="2020-06-25-CTR57-CPP-%E6%8F%90%E4%BE%9B%E4%B8%80%E4%B8%AA%E6%9C%89%E6%95%88%E6%8E%92%E5%BA%8F%E7%9A%84%E8%B0%93%E8%AF%8D">CTR57-CPP. 提供一个有效排序的谓词</a></p></li><li class="task-list-item"><p><input class="task-list-item-checkbox" checked disabled type="checkbox"> <a href="2020-06-25-CTR58-CPP-%E8%B0%93%E8%AF%8D%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E4%B8%8D%E5%BA%94%E8%AF%A5%E6%98%AF-mutable">CTR58-CPP. 谓词函数对象不应该是 mutable</a></p></li></ul></li><li class="task-list-item"><p><input class="task-list-item-checkbox" disabled type="checkbox"> <a href="https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=88046330" target="_blank" rel="noopener">Rule 05. Characters and Strings (STR)</a> 字符和字符串 (STR)</p></li><li class="task-list-item"><p><input class="task-list-item-checkbox" disabled type="checkbox"> <a href="https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=88046329" target="_blank" rel="noopener">Rule 06. Memory Management (MEM)</a> 内存分配 (MEM)</p></li><li class="task-list-item"><p><input class="task-list-item-checkbox" disabled type="checkbox"> <a href="https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=88046328" target="_blank" rel="noopener">Rule 07. Input Output (FIO)</a> 输入输出 (FIO)</p></li><li class="task-list-item"><p><input class="task-list-item-checkbox" disabled type="checkbox"> <a href="https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=88046339" target="_blank" rel="noopener">Rule 08. Exceptions and Error Handling (ERR)</a> 异常及错误处理 (ERR)</p></li><li class="task-list-item"><p><input class="task-list-item-checkbox" disabled type="checkbox"> <a href="https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=88046338" target="_blank" rel="noopener">Rule 09. Object Oriented Programming (OOP)</a> 面向对象编程 (OOP)</p></li><li class="task-list-item"><p><input class="task-list-item-checkbox" disabled type="checkbox"> <a href="https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=88046460" target="_blank" rel="noopener">Rule 10. Concurrency (CON)</a> 并发 (CON)</p></li><li class="task-list-item"><p><input class="task-list-item-checkbox" disabled type="checkbox"> <a href="https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=88046336" target="_blank" rel="noopener">Rule 49. Miscellaneous (MSC)</a> 杂项 (MSC)</p></li></ul><h2 id="关于-SEI-CERT-规范"><a class="header-anchor" href="#关于-SEI-CERT-规范">¶</a>关于 <code>SEI CERT</code> 规范</h2><p><code>SEI CERT</code> 的规则都是为了确保 C/C++ 编程开发软件系统的安全性、可靠性和稳固性，比如消除一些未定义行为或者可利用漏洞。</p><p>C 和 C++ 各一份。他们同时还有其他语言的，比如 <code>Java</code> 、<code>Android</code>、<code>Perl</code> 的代码规范。这里主要自己写 C/C++，所以只关注这两份。相关信息可以移步到研究所维护的公开 <a href="https://wiki.sei.cmu.edu/confluence/" target="_blank" rel="noopener">wiki 主页</a>。他们也会定期发布出版物，C/C++ 就是下面这两本，最新的都是 2016 v1 版本，官方主页有有下载通道。</p><ul><li><code>SEI CERT C Coding Standard: Rules for Developing Safe, Reliable, and Secure Systems</code></li><li><code>SEI CERT C++ Coding Standard: Rules for Developing Safe, Reliable, and Secure Systems</code></li></ul><p>关于安全编码规范，目前全球比较受认可的还有汽车工业软件可靠性协会的 MISRA C 和 MISRA C++，前者最新为 2012 版，后者最新为 2008 版。相对来说 <code>SEI CERT C</code> 和 <code>SEI CERT C++</code> 主页维护还很活跃,一直在更新。</p><p><a href="https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=88046682" target="_blank" rel="noopener">SEI CERT C++ Coding Standard</a> 中总共有 <code>11</code> 条规则，每条规则分别由标题、描述、不合规代码示例、合规方案、风险评估及其他一些实际案例、参考文献等组成。这 <code>11</code> 条规则分别是：</p><ul><li><a href="https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=88046322" target="_blank" rel="noopener">Rule 01. Declarations and Initialization (DCL)</a> 声明和初始化 (DCL)</li><li><a href="https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=88046335" target="_blank" rel="noopener">Rule 02. Expressions (EXP)</a> 表达式 (EXP)</li><li><a href="https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=88046333" target="_blank" rel="noopener">Rule 03. Integers (INT)</a> 整型 (INT)</li><li><a href="https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=88046331" target="_blank" rel="noopener">Rule 04. Containers (CTR)</a> 容器 (CTR)</li><li><a href="https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=88046330" target="_blank" rel="noopener">Rule 05. Characters and Strings (STR)</a> 字符和字符串 (STR)</li><li><a href="https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=88046329" target="_blank" rel="noopener">Rule 06. Memory Management (MEM)</a> 内存分配 (MEM)</li><li><a href="https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=88046328" target="_blank" rel="noopener">Rule 07. Input Output (FIO)</a> 输入输出 (FIO)</li><li><a href="https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=88046339" target="_blank" rel="noopener">Rule 08. Exceptions and Error Handling (ERR)</a> 异常及错误处理 (ERR)</li><li><a href="https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=88046338" target="_blank" rel="noopener">Rule 09. Object Oriented Programming (OOP)</a> 面向对象编程 (OOP)</li><li><a href="https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=88046460" target="_blank" rel="noopener">Rule 10. Concurrency (CON)</a> 并发 (CON)</li><li><a href="https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=88046336" target="_blank" rel="noopener">Rule 49. Miscellaneous (MSC)</a> 杂项 (MSC)</li></ul><p>关于这份规范的其他信息在主页也都已列出，其中<a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/How+this+Coding+Standard+Is+Organized" target="_blank" rel="noopener">How this Coding Standard Is Organized</a>的需要看一下，能够知道编码标准如何组织的，有助于阅读。</p><ul><li><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/Usage" target="_blank" rel="noopener">Usage</a></li><li><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/Tool+Selection+and+Validation" target="_blank" rel="noopener">Tool Selection and Validation</a></li><li><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/System+Qualities" target="_blank" rel="noopener">System Qualities</a></li><li><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/Scope" target="_blank" rel="noopener">Scope</a></li><li><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/Rules+Versus+Recommendations" target="_blank" rel="noopener">Rules Versus Recommendations</a></li><li><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/Relation+to+the+CERT+C+Coding+Standard" target="_blank" rel="noopener">Relation to the CERT C Coding Standard</a></li><li><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/Introduction" target="_blank" rel="noopener">Introduction</a></li><li><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/How+this+Coding+Standard+Is+Organized" target="_blank" rel="noopener">How this Coding Standard Is Organized</a></li><li><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/Government+Regulations" target="_blank" rel="noopener">Government Regulations</a></li><li><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/Development+Process" target="_blank" rel="noopener">Development Process</a></li><li><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/Conformance+Testing" target="_blank" rel="noopener">Conformance Testing</a></li><li><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/Automatically+Generated+Code" target="_blank" rel="noopener">Automatically Generated Code</a></li><li><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/Automated+Detection" target="_blank" rel="noopener">Automated Detection</a></li><li><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/Audience" target="_blank" rel="noopener">Audience</a></li><li><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/Acknowledgments" target="_blank" rel="noopener">Acknowledgments</a></li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>SEI CERT C++</category>
      </categories>
      <tags>
        <tag>SEI CERT C++</tag>
        <tag>编码规范</tag>
        <tag>翻译</tag>
      </tags>
  </entry>
  <entry>
    <title>MEM51-CPP. 正确地释放动态分配的资源</title>
    <url>/posts/2185119777/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><!-- build time:Sat Nov 13 2021 15:45:21 GMT+0000 (Coordinated Universal Time) --><p>原文链接：</p><p><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/MEM51-CPP.+Properly+deallocate+dynamically+allocated+resources" target="_blank" rel="noopener">MEM51-CPP. Properly deallocate dynamically allocated resources</a></p><a id="more"></a><hr><p>C 语言提供了几种分配内存的方式，例如 <code>std::malloc()</code>, <code>std::calloc()</code>, 和 <code>std::realloc()</code> 。这些也可以被 C++ 使用。然而，对于释放内存而言，C 语言只定义了一种简单的方式：<code>std::free()</code> 。关于 C 分配和释放内存要求的条款，见 <a href="https://wiki.sei.cmu.edu/confluence/display/c/MEM31-C.+Free+dynamically+allocated+memory+when+no+longer+needed" target="_blank" rel="noopener">MEM31-C. Free dynamically allocated memory when no longer needed</a> 和 <a href="https://wiki.sei.cmu.edu/confluence/display/c/MEM34-C.+Only+free+memory+allocated+dynamically" target="_blank" rel="noopener">MEM34-C. Only free memory allocated dynamically</a></p><p>C++ 语言提供了额外的集中分配内存的方式，例如运算符 <code>new</code>, <code>new []</code> 和 placement <code>new</code> ，还有<a href="http://www.cplusplus.com/reference/memory/allocator/" target="_blank" rel="noopener">分配器对象（allocator objects）</a> 。不像 C，C++ 提供了多种释放动态内存的方法，例如运算符 <code>delete</code> ，<code>delete []()</code> 和分配器对象上的释放函数(deallocation functions)。</p><p>除了 <code>nullptr</code> ，不要对其他对象调用释放函数，或者下述相应分配函数返回的指针。</p><table><thead><tr><th style="text-align:left">分配器</th><th style="text-align:left">释放器</th></tr></thead><tbody><tr><td style="text-align:left">global<code>operator new()/new</code></td><td style="text-align:left">global<code>operator delete</code>()<code>/delete</code></td></tr><tr><td style="text-align:left">global<code>operator new[]()/new[]</code></td><td style="text-align:left">global<code>operator delete[]()/delete[]</code></td></tr><tr><td style="text-align:left">class-specific<code>operator new()/new</code></td><td style="text-align:left"><code>class-specific operator delete</code>()<code>/delete</code></td></tr><tr><td style="text-align:left"><code>class-specific operator new[]()/new[]</code></td><td style="text-align:left"><code>class-specific operator delete[]()/delete[]</code></td></tr><tr><td style="text-align:left">placement <code>operator new</code>()</td><td style="text-align:left">N/A</td></tr><tr><td style="text-align:left"><code>allocator&lt;T&gt;::allocate()</code></td><td style="text-align:left"><code>allocator&lt;T&gt;::deallocate()</code></td></tr><tr><td style="text-align:left"><code>std::malloc()</code>, <code>std::calloc()</code>, <code>std::realloc()</code></td><td style="text-align:left"><code>std::free()</code></td></tr><tr><td style="text-align:left"><code>std::get_temporary_buffer()</code></td><td style="text-align:left"><code>std::return_temporary_buffer()</code></td></tr></tbody></table><p>向不正确的释放函数传递一个指针将导致 <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-undefinedbehavior" target="_blank" rel="noopener">未定义行为</a>.</p><p>C++ 标准, [expr.delete], 段落 2 [<a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-ISO/IEC14882-2014" target="_blank" rel="noopener">ISO/IEC 14882-2014</a>], 部分叙述如下:</p><blockquote><p>首选 (<em>delete object</em>)，<code>delete</code> 操作数可能是一个空指针值，一个由前述 <em>new-表达式</em> 创建的指向非数组对象的指针，或者指向一个表示类似 (Clause 10) 的基类对象的子对象 (1.8) 指针。如果不是，该行为是未定义的。其次 (delete array)，<code>delete</code> 操作数可能是一个空指针值或者由先前数组 <em>new-表达式</em> 创建的指针。否则，该行为是未定义的。</p></blockquote><p>释放一个非动态分配（包括由 placement <code>new()</code> 产生的非动态指针的指针）是未定义行为，因为该指针并不是从分配函数中获取的。释放一个已经传入过释放函数中的指针是未定义的，因为指针已经不再指向之前已动态分配过的内存。</p><p>当像 <code>new</code> 操作符被调用时，这导致同名的可重载的操作符被调用，比如 <code>operator new()</code> 。这些可重载的函数也可能被直接调用，但是和对应操作符有相同的限制。这就是说，调用 <code>operator delete()</code> ，并传入一个指针参数和对该指针调用 <code>delete</code> 操作符限制是一样的。进一步说，重载版本受作用域限制。因此，调用一个类型指定操作符来分配一个对象，但通过全局操作符来释放这个对象，这是可能的（但不允许）。</p><p>除了 <code>new</code> 和 <code>delete</code> 操作符，当使用其他内存管理函数，见 <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/MEM53-CPP.+Explicitly+construct+and+destruct+objects+when+manually+managing+object+lifetime" target="_blank" rel="noopener">MEM53-CPP. Explicitly construct and destruct objects when manually managing object lifetime</a> 获取关于对象生命周期管理信息。</p><h2 id="不合规代码示例-placement-new"><a class="header-anchor" href="#不合规代码示例-placement-new">¶</a>不合规代码示例 (placement <code>new()</code>)</h2><p>在这个不合规的代码示例中，局部变量 <code>space</code> 被当作表达式传入 placement <code>new</code> 操作符中。调用返回的指针接着被传入到 <code>::operator delete()</code> ，由于 <code>::operator delete()</code> 试图去释放并不是由 <code>::operator new()</code> 返回的指针，导致了 <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-undefinedbehavior" target="_blank" rel="noopener">未定义行为</a> 。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">  S() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"S::S()"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line">  ~S() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"S::~S()"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">alignas</span>(struct S) <span class="keyword">char</span> space[<span class="keyword">sizeof</span>(struct S)];</span><br><span class="line">  S *s1 = <span class="keyword">new</span> (&amp;space) S;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">delete</span> s1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="合规方案-placement-new"><a class="header-anchor" href="#合规方案-placement-new">¶</a>合规方案 (placement <code>new()</code>)</h2><p>这个合规方案移除了对 <code>::operator delete()的</code>调用，而用显式地调用 <code>s1</code> 的析构函数来替代。这是为数不多的几次需要确保显式调用析构函数。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">  S() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"S::S()"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line">  ~S() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"S::~S()"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">alignas</span>(struct S) <span class="keyword">char</span> space[<span class="keyword">sizeof</span>(struct S)];</span><br><span class="line">  S *s1 = <span class="keyword">new</span> (&amp;space) S;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"> </span><br><span class="line">  s1-&gt;~S();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="不合规代码示例-Uninitialized-delete"><a class="header-anchor" href="#不合规代码示例-Uninitialized-delete">¶</a>不合规代码示例 (Uninitialized <code>delete</code>)</h2><p>在这个不合规代码例子中，在同一个 <code>try</code> 块内试图进行两次内存分配。如果某一个失败了，那么 <code>catch</code> 块试图释放已经被分配的资源。然而，由于指针值并没有初始化为已知的值，<code>i1</code> 内存分配错误可能造成传入 <code>::operator delete()</code> 的值 (<code>i2</code>中的)并不是之前调用 <code>::operator new()</code> 所返回的，导致 <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-undefinedbehavior" target="_blank" rel="noopener">未定义行为</a>。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;new&gt;</span></span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> *i1, *i2;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    i1 = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">    i2 = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (<span class="built_in">std</span>::bad_alloc &amp;) &#123;</span><br><span class="line">    <span class="keyword">delete</span> i1;</span><br><span class="line">    <span class="keyword">delete</span> i2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="合规方案-Uninitialized-delete"><a class="header-anchor" href="#合规方案-Uninitialized-delete">¶</a>合规方案 (Uninitialized <code>delete</code>)</h2><p>这个兼容方案将两个指针均初始化为 <code>nullptr</code> ，可以被合法传入 <code>::operator delete().</code></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;new&gt;</span></span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> *i1 = <span class="literal">nullptr</span>, *i2 = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    i1 = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">    i2 = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (<span class="built_in">std</span>::bad_alloc &amp;) &#123;</span><br><span class="line">    <span class="keyword">delete</span> i1;</span><br><span class="line">    <span class="keyword">delete</span> i2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="不合规代码示例-Double-Free"><a class="header-anchor" href="#不合规代码示例-Double-Free">¶</a>不合规代码示例 (Double-Free)</h2><p>一旦指针被传入到正确的释放函数中，该指针值将不可用。当并未在调用后续分配函数返回时重新赋值，该指针第二次传入释放函数，造成试图释放未动态分配的内存。管理着堆的潜在数据结构（注：该指针指向的已经被释放的内存堆）某种程度上会造成崩毁——会在程序中引入安全 <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-vulnerability" target="_blank" rel="noopener">漏洞 (vulnerabilities)</a>。 这种类型的问题被称为 <em>二次释放漏洞 (double-free vulnerabilities)</em> 。实践中，二次释放漏洞可能会 <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-exploit" target="_blank" rel="noopener">利用</a> 执行任意代码。</p><p>在这个不合规的代码例子中，类 <code>C</code> 拥有一个 <code>P *</code> 的所有权——后续会在类的析构函数中释放。C++ 标准，[class.copy]，段落 7 [<a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-ISO/IEC14882-2014" target="_blank" rel="noopener">ISO/IEC 14882-2014</a>], 陈述如下:</p><blockquote><p>如果在类的定义未显式声明一个拷贝构造函数，将会隐式声明一个拷贝构造函数。如果类的定义声明了一个移动构造函数或者移动赋值运算，被隐式声明的拷贝构造函数将被定义为 deleted；否则，其（注：被隐式声明的拷贝构造函数）将被定义为 default (8.4)。如果该类包含一个用户自定义的拷贝赋值运算或者析构函数，后者要被弃用（注：用户需要显式自定义拷贝构造函数）。</p><p>If the class definition does not explicitly declare a copy constructor, one is declared implicitly. If the class definition declares a move constructor or move assignment operator, the implicitly declared copy constructor is defined as deleted; otherwise, it is defined as defaulted (8.4). The latter case is deprecated if the class has a user-declared copy assignment operator or a user-declared destructor.</p></blockquote><p><code>C</code> 尽管存在用户定义的析构函数，但是含有一个隐式的默认拷贝构造函数，并且这个默认的拷贝构造函数将拷贝存储在 <code>p</code> 中的指针值，这将导致二次释放：第一次释放发生在当 <code>g()</code> 退出时，第二次释放发生在当 <code>h()</code> 退出时。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">P</span> &#123;</span>&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> &#123;</span></span><br><span class="line">  P *p;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  C(P *p) : p(p) &#123;&#125;</span><br><span class="line">  ~C() &#123; <span class="keyword">delete</span> p; &#125; </span><br><span class="line">   </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(C c)</span> </span>&#123;</span><br><span class="line">  c.f();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">h</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  P *p = <span class="keyword">new</span> P;</span><br><span class="line">  <span class="function">C <span class="title">c</span><span class="params">(p)</span></span>;</span><br><span class="line">  g(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="合规方案-Double-Free"><a class="header-anchor" href="#合规方案-Double-Free">¶</a>合规方案 (Double-Free)</h2><p>在这个合规方案中，<code>C</code> 的拷贝构造函数和拷贝赋值运算被显式删除。这个删除将会使先前不合规代码示例程序 <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-ill-formed" target="_blank" rel="noopener">不合语法的 (ill-formed)</a> ——由于 <code>g</code> 的定义使用了被删除的拷贝构造函数。因此，<code>g()</code> 被修改为接受其引用参数，消除二次释放。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">P</span> &#123;</span>&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> &#123;</span></span><br><span class="line">  P *p;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  C(P *p) : p(p) &#123;&#125;</span><br><span class="line">  C(<span class="keyword">const</span> C&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  ~C() &#123; <span class="keyword">delete</span> p; &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">void</span> <span class="keyword">operator</span>=(<span class="keyword">const</span> C&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">   </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(C &amp;c)</span> </span>&#123;</span><br><span class="line">  c.f();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">h</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  P *p = <span class="keyword">new</span> P;</span><br><span class="line">  <span class="function">C <span class="title">c</span><span class="params">(p)</span></span>;</span><br><span class="line">  g(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="不合规代码示例-array-new"><a class="header-anchor" href="#不合规代码示例-array-new">¶</a>不合规代码示例 (array <code>new[]</code>)</h2><p>在接下来这个不合规的代码示例中，一个使用数组 <code>new[]</code> 来分配的数组，但是通过 <code>delete</code> 而不是 <code>delete[]</code> 来释放内存，导致 <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-undefinedbehavior" target="_blank" rel="noopener">未定义行为</a>.</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> *<span class="built_in">array</span> = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">delete</span> <span class="built_in">array</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="合规方案-array-new"><a class="header-anchor" href="#合规方案-array-new">¶</a>合规方案 (array <code>new[]</code>)</h2><p>在这个合规方案中，通过调用 <code>delelte[]</code> 替换 <code>delete</code> 来修复，使代码遵循使用正确的配对的内存分配和释放函数</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> *<span class="built_in">array</span> = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">delete</span>[] <span class="built_in">array</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="不合规代码示例-malloc"><a class="header-anchor" href="#不合规代码示例-malloc">¶</a>不合规代码示例 (<code>malloc()</code>)</h2><p>在这个不合规的代码示例中，混用了 <code>malloc()</code> 和 <code>delete</code> 的调用。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> *i = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span> *&gt;(<span class="built_in">std</span>::<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)));</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">delete</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子没有违背 <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/MEM53-CPP.+Explicitly+construct+and+destruct+objects+when+manually+managing+object+lifetime" target="_blank" rel="noopener">MEM53-CPP. Explicitly construct and destruct objects when manually managing object lifetime</a> 因为它遵循 MEM53-CPP-EX1 异常.</p><h2 id="实现细节"><a class="header-anchor" href="#实现细节">¶</a>实现细节</h2><p>有些 <code>::operator new()</code> 的实现会调用 <code>std::malloc()</code> 。在这类实现中， <code>::operator delete()</code> 函数被要求调用 <code>std::free()</code> 去释放指针，并且非合规的代码示例将表现为正确定义的行为。然而，不应该依赖于实现，这里有个 <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-implementation" target="_blank" rel="noopener">实现</a> 的细节，实现没有义务使用潜在的 C 内存管理函数来实现 C++ 内存管理操作。</p><h2 id="合规方案-malloc"><a class="header-anchor" href="#合规方案-malloc">¶</a>合规方案 (<code>malloc()</code>)</h2><p>在这个合规方案中，指针由 <code>std::malloc()</code> 分配，调用 <code>std::free()</code> 来释放，而不是 <code>delete.</code></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> *i = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span> *&gt;(<span class="built_in">std</span>::<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)));</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">free</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="不合规代码示例-new"><a class="header-anchor" href="#不合规代码示例-new">¶</a>不合规代码示例 ( <code>new</code> )</h2><p>这个不合规的代码示例调用 <code>std::free()</code> 来释放通过 <code>new</code> 分配的内存。由此产生了一个 <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-undefinedbehavior" target="_blank" rel="noopener">未定义行为</a> 的副作用——由于使用了不正确的释放函数，该对象的析构函数并不会被调用，通过 <code>std::free()</code> 无法释放对象。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">  ~S();</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  S *s = <span class="keyword">new</span> S();</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">free</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，该代码违背了 <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/MEM53-CPP.+Explicitly+construct+and+destruct+objects+when+manually+managing+object+lifetime" target="_blank" rel="noopener">MEM53-CPP. Explicitly construct and destruct objects when manually managing object lifetime</a>.</p><h2 id="合规方案-new"><a class="header-anchor" href="#合规方案-new">¶</a>合规方案 (<code>new</code>)</h2><p>在这个合规方案中，由 <code>new</code> 分配的指针通过调用 <code>delete</code> 来释放，而不是 <code>std::free()</code> 。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct&#96; &#96;S &#123;&#96;&#96; &#96;&#96;~S();&#96;&#96;&#125;;&#96; &#96;void&#96; &#96;f() &#123;&#96;&#96; &#96;&#96;S *s &#x3D; &#96;&#96;new&#96; &#96;S();&#96;&#96; &#96;&#96;&#x2F;&#x2F; ...&#96;&#96; &#96;&#96;delete&#96; &#96;s;&#96;&#96;&#125;</span><br></pre></td></tr></table></figure><h2 id="不合规代码示例-Class-new"><a class="header-anchor" href="#不合规代码示例-Class-new">¶</a>不合规代码示例 (Class <code>new</code>)</h2><p>在这个不合规代码示例中，<code>operator new()</code> 的类特定(class-specific)的实现重载了全局 <code>new</code> 操作符。当 <code>new</code> 被调用时，类特定的重载版本被选中，因此 <code>S::operator new()</code> 被调用。然而，由于该对象由作用域内的 <code>::delete</code> 操作符销毁，全局的 <code>operator delete()</code> 函数被调用，而不是类他特定的实现的 <code>S::operator delete()</code>，导致 <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-undefinedbehavior" target="_blank" rel="noopener">未定义行为</a>.</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;new&gt;</span></span></span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="built_in">size</span>)</span> <span class="title">noexcept</span><span class="params">(<span class="literal">true</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">malloc</span>(<span class="built_in">size</span>);</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *ptr)</span> <span class="title">noexcept</span><span class="params">(<span class="literal">true</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">free</span>(ptr);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  S *s = <span class="keyword">new</span> S;</span><br><span class="line">  ::<span class="keyword">delete</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="合规方案-class-new"><a class="header-anchor" href="#合规方案-class-new">¶</a>合规方案 (class <code>new</code>)</h2><p>在这个合规方案中，作用域内的 <code>::delete</code> 调用被非域内的 <code>delete</code> 调用所替代, 引起 <code>S::operator delete()</code>被调用。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;new&gt;</span></span></span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="built_in">size</span>)</span> <span class="title">noexcept</span><span class="params">(<span class="literal">true</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">malloc</span>(<span class="built_in">size</span>);</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *ptr)</span> <span class="title">noexcept</span><span class="params">(<span class="literal">true</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">free</span>(ptr);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  S *s = <span class="keyword">new</span> S;</span><br><span class="line">  <span class="keyword">delete</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="不合规代码示例-std-unique-ptr"><a class="header-anchor" href="#不合规代码示例-std-unique-ptr">¶</a>不合规代码示例 (<code>std::unique_ptr</code>)</h2><p>在这个不合规代码示例中，声明了一个 <code>std::unique_ptr</code> 来持有一个对象的指针——但是直接由对象数组来初始化的。当该 <code>std::unique_ptr</code> 被销毁时，默认的删除器调用 <code>delete</code> 而不是 <code>delete[]</code> ，导致了未定义行为。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span>&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;S&gt; s&#123;<span class="keyword">new</span> S[<span class="number">10</span>]&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="合规方案-std-unique-ptr"><a class="header-anchor" href="#合规方案-std-unique-ptr">¶</a>合规方案 (<code>std::unique_ptr</code>)</h2><p>在这个合规方案中，声明了一个 <code>std::unique_ptr</code> 来持有一个对象数组，而不是持有指向一个对象的指针。此外，用 <code>std::make_unique()</code> 来初始化这个智能指针。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span>&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;S[]&gt; s = <span class="built_in">std</span>::make_unique&lt;S[]&gt;(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>std::make_unique()</code> 而不是直接初始化，如果 <code>std::unique_ptr</code> 的结果不是正确类型，将发出诊断 (emit a diagnostic) 。如果它被用在不合规的代码例子中，结果将会是不合规范的程序，而不是未定义行为。最好用 <code>std::make_unique()</code> 来代替其他手动初始化的方式。</p><h2 id="不合规代码示例-std-shared-ptr"><a class="header-anchor" href="#不合规代码示例-std-shared-ptr">¶</a>不合规代码示例 (<code>std::shared_ptr</code>)</h2><p>在这个不合规代码示例中，声明了一个 <code>std::shared_ptr</code> 来持有一个对象的指针——但是直接由对象数组来初始化的。和使用 <code>std::unique_ptr</code> 一样，当该 <code>std::shared_ptr</code> 被销毁时，默认的删除器调用 <code>delete</code> 而不是 <code>delete[]</code> ，导致了未定义行为。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span>&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;S&gt; s&#123;<span class="keyword">new</span> S[<span class="number">10</span>]&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="合规方案-std-shared-ptr"><a class="header-anchor" href="#合规方案-std-shared-ptr">¶</a>合规方案 (<code>std::shared_ptr</code>)</h2><p>不同于 <code>std::unique_ptr</code> 的合规方案，那些调用 <code>std::make_unique()</code> 来创建指向数组的独占指针的地方，调用数组类型的 <code>std::make_shared()</code> 是不合语法规范的。反之，这个合规方案为共享指针类型手动指定了一个自定义的删除器，来保证潜在的数组被正确的删除。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span>&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;S&gt; s&#123;<span class="keyword">new</span> S[<span class="number">10</span>], [](<span class="keyword">const</span> S *ptr) &#123; <span class="keyword">delete</span> [] ptr; &#125;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="风险评估"><a class="header-anchor" href="#风险评估">¶</a>风险评估</h2><p>传递一个从先前并不匹配的分配函数获取的指针值到一个释放函数中会导致 <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-undefinedbehavior" target="_blank" rel="noopener">未定义行为</a>，可以引起可利用的 <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-vulnerability" target="_blank" rel="noopener">漏洞</a>.</p><table><thead><tr><th style="text-align:left">Rule</th><th style="text-align:left">Severity</th><th style="text-align:left">Likelihood</th><th style="text-align:left">Remediation Cost</th><th style="text-align:left">Priority</th><th style="text-align:left">Level</th></tr></thead><tbody><tr><td style="text-align:left">MEM51-CPP</td><td style="text-align:left">High</td><td style="text-align:left">Likely</td><td style="text-align:left">Medium</td><td style="text-align:left"><strong>P18</strong></td><td style="text-align:left"><strong>L1</strong></td></tr></tbody></table><h2 id="Automated-Detection"><a class="header-anchor" href="#Automated-Detection">¶</a>Automated Detection</h2><table><thead><tr><th style="text-align:left">Tool</th><th style="text-align:left">Version</th><th style="text-align:left">Checker</th><th style="text-align:left">Description</th></tr></thead><tbody><tr><td style="text-align:left"><a href="https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=222953724" target="_blank" rel="noopener">Astrée</a></td><td style="text-align:left">20.10</td><td style="text-align:left">**invalid_dynamic_memory_allocation dangling_pointer_use **</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/Axivion+Bauhaus+Suite" target="_blank" rel="noopener">Axivion Bauhaus Suite</a></td><td style="text-align:left">7.2.0</td><td style="text-align:left"><strong>CertC+±MEM51</strong></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/Clang" target="_blank" rel="noopener">Clang</a></td><td style="text-align:left">3.9</td><td style="text-align:left"><code>clang-analyzer-cplusplus.NewDeleteLeaks</code> <code>-Wmismatched-new-deleteclang-analyzer-unix.MismatchedDeallocator</code></td><td style="text-align:left">Checked by <code>clang-tidy</code>, but does not catch all violations of this rule</td></tr><tr><td style="text-align:left"><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/CodeSonar" target="_blank" rel="noopener">CodeSonar</a></td><td style="text-align:left">6.1p0</td><td style="text-align:left">**ALLOC.FNH ALLOC.DF <a href="http://ALLOC.TM" target="_blank" rel="noopener">ALLOC.TM</a> **</td><td style="text-align:left">Free non-heap variable Double free Type mismatch</td></tr><tr><td style="text-align:left"><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/Helix+QAC" target="_blank" rel="noopener">Helix QAC</a></td><td style="text-align:left">2021.2</td><td style="text-align:left"><strong>C<ins>2110, C</ins>2111, C<ins>2112, C</ins>2113, C<ins>2118, C</ins>3337, C<ins>3339, C</ins>4262, C<ins>4263, C</ins>4264</strong></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/Klocwork" target="_blank" rel="noopener">Klocwork</a></td><td style="text-align:left">2021.1</td><td style="text-align:left"><strong><a href="https://support.roguewave.com/documentation/klocwork/en/current/certcandcsecurecodingstandardidsmappedtoklocworkcandccheckers/" target="_blank" rel="noopener">CL.FFM.ASSIGN</a></strong> <strong><a href="https://support.roguewave.com/documentation/klocwork/en/current/certcandcsecurecodingstandardidsmappedtoklocworkcandccheckers/" target="_blank" rel="noopener">CL.FFM.COPY</a></strong> <strong><a href="https://support.roguewave.com/documentation/klocwork/en/current/certcandcsecurecodingstandardidsmappedtoklocworkcandccheckers/" target="_blank" rel="noopener">CL.FMM</a>****<a href="https://support.roguewave.com/documentation/klocwork/en/current/certcandcsecurecodingstandardidsmappedtoklocworkcandccheckers/" target="_blank" rel="noopener">FMM.MIGHT</a></strong> <strong><a href="https://support.roguewave.com/documentation/klocwork/en/current/certcandcsecurecodingstandardidsmappedtoklocworkcandccheckers/" target="_blank" rel="noopener">FMM.MUST</a></strong> <strong><a href="https://support.roguewave.com/documentation/klocwork/en/current/certcandcsecurecodingstandardidsmappedtoklocworkcandccheckers/" target="_blank" rel="noopener">FNH.MIGHT</a></strong> <strong><a href="https://support.roguewave.com/documentation/klocwork/en/current/certcandcsecurecodingstandardidsmappedtoklocworkcandccheckers/" target="_blank" rel="noopener">FNH.MUST</a></strong> <strong><a href="https://support.roguewave.com/documentation/klocwork/en/current/certcandcsecurecodingstandardidsmappedtoklocworkcandccheckers/" target="_blank" rel="noopener">FUM.GEN.MIGHT</a></strong> <strong><a href="https://support.roguewave.com/documentation/klocwork/en/current/certcandcsecurecodingstandardidsmappedtoklocworkcandccheckers/" target="_blank" rel="noopener">FUM.GEN.MUST</a><strong><strong><a href="https://support.roguewave.com/documentation/klocwork/en/current/certcandcsecurecodingstandardidsmappedtoklocworkcandccheckers/" target="_blank" rel="noopener">UNINIT.CTOR.MIGHT</a> <a href="https://support.roguewave.com/documentation/klocwork/en/current/certcandcsecurecodingstandardidsmappedtoklocworkcandccheckers/" target="_blank" rel="noopener">UNINIT.CTOR.MUST</a> <a href="https://support.roguewave.com/documentation/klocwork/en/current/certcandcsecurecodingstandardidsmappedtoklocworkcandccheckers/" target="_blank" rel="noopener">UNINIT.HEAP.MIGHT</a> <a href="https://support.roguewave.com/documentation/klocwork/en/current/certcandcsecurecodingstandardidsmappedtoklocworkcandccheckers/" target="_blank" rel="noopener">UNINIT.HEAP.MUST</a></strong></strong><a href="https://support.roguewave.com/documentation/klocwork/en/current/certcandcsecurecodingstandardidsmappedtoklocworkcandccheckers/" target="_blank" rel="noopener">UNINIT.STACK.ARRAY.MIGHT</a> <strong><strong><a href="https://support.roguewave.com/documentation/klocwork/en/current/certcandcsecurecodingstandardidsmappedtoklocworkcandccheckers/" target="_blank" rel="noopener">UNINIT.STACK.ARRAY.PARTIAL.MUST</a></strong></strong><a href="https://support.roguewave.com/documentation/klocwork/en/current/certcandcsecurecodingstandardidsmappedtoklocworkcandccheckers/" target="_blank" rel="noopener">UNINIT.STACK.ARRAY.MUST</a> <a href="https://support.roguewave.com/documentation/klocwork/en/current/certcandcsecurecodingstandardidsmappedtoklocworkcandccheckers/" target="_blank" rel="noopener">UNINIT.STACK.MIGHT</a> <a href="https://support.roguewave.com/documentation/klocwork/en/current/certcandcsecurecodingstandardidsmappedtoklocworkcandccheckers/" target="_blank" rel="noopener">UNINIT.STACK.MUST</a></strong></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/LDRA" target="_blank" rel="noopener">LDRA tool suite</a></td><td style="text-align:left">9.7.1</td><td style="text-align:left"><strong>232 S, 236 S, 239 S, 407 S, 469 S, 470 S, 483 S, 484 S, 485 S, 64 D, 112 D</strong>** **</td><td style="text-align:left">Partially implemented</td></tr><tr><td style="text-align:left"><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/Parasoft" target="_blank" rel="noopener">Parasoft C/C++test</a></td><td style="text-align:left">2021.1</td><td style="text-align:left"><strong>CERT_CPP-MEM51-a</strong> <strong>CERT_CPP-MEM51-b</strong> <strong>CERT_CPP-MEM51-c</strong> <strong>CERT_CPP-MEM51-d</strong></td><td style="text-align:left">Use the same form in corresponding calls to new/malloc and delete/free Always provide empty brackets ([]) for delete when deallocating arrays Both copy constructor and copy assignment operator should be declared for classes with a nontrivial destructor Properly deallocate dynamically allocated resources</td></tr><tr><td style="text-align:left"><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/Parasoft" target="_blank" rel="noopener">Parasoft Insure++</a></td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left">Runtime detection</td></tr><tr><td style="text-align:left"><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/Polyspace+Bug+Finder" target="_blank" rel="noopener">Polyspace Bug Finder</a></td><td style="text-align:left">R2021b</td><td style="text-align:left"><a href="https://www.mathworks.com/help/bugfinder/ref/certcmem51cpp.html" target="_blank" rel="noopener">CERT C++: MEM51-CPP</a></td><td style="text-align:left">Checks for:Invalid deletion of pointerInvalid free of pointerDeallocation of previously deallocated pointerRule partially covered.</td></tr><tr><td style="text-align:left"><a href="https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=88046345" target="_blank" rel="noopener">PRQA QA-C++</a></td><td style="text-align:left">4.4</td><td style="text-align:left"><strong>2110, 2111, 2112, 2113, 2118*<em>,*</em></strong><strong><em>*3337, 3339*</em>, 4262, 4263, 4264</strong></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/PVS-Studio" target="_blank" rel="noopener">PVS-Studio</a></td><td style="text-align:left">7.15</td><td style="text-align:left"><a href="https://pvs-studio.com/en/docs/warnings/v515/" target="_blank" rel="noopener"><strong>V515</strong></a>, <a href="https://pvs-studio.com/en/docs/warnings/v554/" target="_blank" rel="noopener"><strong>V554</strong></a>, <a href="https://pvs-studio.com/en/docs/warnings/v611/" target="_blank" rel="noopener"><strong>V611</strong></a>, <a href="https://pvs-studio.com/en/docs/warnings/v701/" target="_blank" rel="noopener"><strong>V701</strong></a>, <a href="https://pvs-studio.com/en/docs/warnings/v748/" target="_blank" rel="noopener"><strong>V748</strong></a>, <a href="https://pvs-studio.com/en/docs/warnings/v773/" target="_blank" rel="noopener"><strong>V773</strong></a>, <strong><a href="https://pvs-studio.com/en/docs/warnings/v1066/" target="_blank" rel="noopener">V1066</a></strong></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><a href="https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=88046388" target="_blank" rel="noopener">SonarQube C/C++ Plugin</a></td><td style="text-align:left">4.10</td><td style="text-align:left"><strong><a href="https://www.sonarsource.com/products/codeanalyzers/sonarcfamilyforcpp/rules-cpp.html#RSPEC-1232" target="_blank" rel="noopener">S1232</a></strong></td><td style="text-align:left"></td></tr></tbody></table><h2 id="Related-Vulnerabilities"><a class="header-anchor" href="#Related-Vulnerabilities">¶</a>Related Vulnerabilities</h2><p>Search for <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-vulnerability" target="_blank" rel="noopener">vulnerabilities</a> resulting from the violation of this rule on the <a href="https://www.kb.cert.org/vulnotes/bymetric?searchview&amp;query=FIELD+KEYWORDS+contains+MEM31-CPP" target="_blank" rel="noopener">CERT website</a>.</p><h2 id="Related-Guidelines"><a class="header-anchor" href="#Related-Guidelines">¶</a>Related Guidelines</h2><table><thead><tr><th><a href="https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=88046682" target="_blank" rel="noopener">SEI CERT C++ Coding Standard</a></th><th><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/MEM53-CPP.+Explicitly+construct+and+destruct+objects+when+manually+managing+object+lifetime" target="_blank" rel="noopener">MEM53-CPP. Explicitly construct and destruct objects when manually managing object lifetime</a></th></tr></thead><tbody><tr><td><a href="https://wiki.sei.cmu.edu/confluence/display/c/SEI+CERT+C+Coding+Standard" target="_blank" rel="noopener">SEI CERT C Coding Standard</a></td><td><a href="https://wiki.sei.cmu.edu/confluence/display/c/MEM31-C.+Free+dynamically+allocated+memory+when+no+longer+needed" target="_blank" rel="noopener">MEM31-C. Free dynamically allocated memory when no longer needed </a><a href="https://wiki.sei.cmu.edu/confluence/display/c/MEM34-C.+Only+free+memory+allocated+dynamically" target="_blank" rel="noopener">MEM34-C. Only free memory allocated dynamically</a></td></tr><tr><td><a href="http://cwe.mitre.org/" target="_blank" rel="noopener">MITRE CWE</a></td><td><a href="http://cwe.mitre.org/data/definitions/590.html" target="_blank" rel="noopener">CWE 590</a>, Free of Memory Not on the Heap <a href="http://cwe.mitre.org/data/definitions/415.html" target="_blank" rel="noopener">CWE 415</a>, Double Free <a href="http://cwe.mitre.org/data/definitions/404.html" target="_blank" rel="noopener">CWE 404</a>, Improper Resource Shutdown or Release <a href="http://cwe.mitre.org/data/definitions/762.html" target="_blank" rel="noopener">CWE 762</a>, Mismatched Memory Management Routines</td></tr></tbody></table><h2 id="Bibliography"><a class="header-anchor" href="#Bibliography">¶</a>Bibliography</h2><table><thead><tr><th>[<a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-Dowd07" target="_blank" rel="noopener">Dowd 2007</a>]</th><th>“Attacking <code>delete</code> and <code>delete []</code> in C++”</th></tr></thead><tbody><tr><td>[<a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-Henricson97" target="_blank" rel="noopener">Henricson 1997</a>]</td><td>Rule 8.1, &quot;<code>delete</code> should only be used with <code>new&quot;</code> Rule 8.2, &quot;<code>delete []</code> should only be used with <code>new []&quot;</code></td></tr><tr><td>[<a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-ISO/IEC14882-2014" target="_blank" rel="noopener">ISO/IEC 14882-2014</a>]</td><td>Subclause 5.3.5, “Delete” Subclause 12.8, “Copying and Moving Class Objects” Subclause 18.6.1, “Storage Allocation and Deallocation” Subclause 20.7.11, “Temporary Buffers”</td></tr><tr><td>[<a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-Meyers05" target="_blank" rel="noopener">Meyers 2005</a>]</td><td>Item 16, &quot;Use the Same Form in Corresponding Uses of <code>new</code> and <code>delete</code>&quot;</td></tr><tr><td>[<a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-Seacord2013" target="_blank" rel="noopener">Seacord 2013</a>]</td><td>Chapter 4, “Dynamic Memory Management”</td></tr><tr><td>[<a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-Viega05" target="_blank" rel="noopener">Viega 2005</a>]</td><td>“Doubly Freeing Memory”</td></tr></tbody></table><!-- rebuild by neat -->]]></content>
  </entry>
  <entry>
    <title>MEM50-CPP. 不要访问被释放的内存</title>
    <url>/posts/1419131790/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><!-- build time:Sat Nov 13 2021 15:45:21 GMT+0000 (Coordinated Universal Time) --><p>原文链接：</p><p><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/MEM50-CPP.+Do+not+access+freed+memory" target="_blank" rel="noopener">MEM50-CPP. Do not access freed memory</a></p><a id="more"></a><hr><p>使用已经被指向被内存管理函数释放的指针——包括解引用、作为运算的操作数、类型转换和作为赋值的右值——是 <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-undefinedbehavior" target="_blank" rel="noopener">未定义行为</a> 。指向已经被释放的内存的指针被称为 <em>空悬指针</em> 。访问一个空悬指针会导致可用 <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-vulnerability" target="_blank" rel="noopener">漏洞</a>（exploitable vulnerabilities）。</p><p>何时去重用或者回收被释放的内存却决于内存管理单元。当内存被释放了，所有的指针将成为不合法的，并且它的上下文可能被返回给操作系统、使被释放内存不可访问或者依然完好无损且可访问。结果就是，处于被释放内存区域的数据可能看起来合法但可能已经意外改变了。因此，当内存被释一旦被释放，一定不要从它当中读或写。</p><h2 id="不合规的代码示例-new-and-delete"><a class="header-anchor" href="#不合规的代码示例-new-and-delete">¶</a>不合规的代码示例 (<code>new</code> and <code>delete</code>)</h2><p>这个不合规的代码示例中，已经被释放的 <code>s</code> 被解引用了。如果这次访问导致读后释放（write-after-free），这个 <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-vulnerability" target="_blank" rel="noopener">漏洞(vulnerability)</a> 可被 <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-exploit" target="_blank" rel="noopener">发掘</a> 来用于执行任意带权限的漏洞进程代码。通常，动态内存分配和释放相距甚远，使得这类问题很难被识别和分析。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;new&gt;</span></span></span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> <span class="title">noexcept</span><span class="params">(<span class="literal">false</span>)</span> </span>&#123;</span><br><span class="line">  S *s = <span class="keyword">new</span> S;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">delete</span> s;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  s-&gt;f();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数 <code>g()</code> 被标记为 <code>noexcept(false)</code> 以遵循 <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/MEM52-CPP.+Detect+and+handle+memory+allocation+errors" target="_blank" rel="noopener">MEM52-CPP. Detect and handle memory allocation errors</a>.</p><h2 id="合规方案-new-and-delete"><a class="header-anchor" href="#合规方案-new-and-delete">¶</a>合规方案 (<code>new</code> and <code>delete</code>)</h2><p>在这个合规方案中， 动态分配的内存直到不被使用后才释放。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;new&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> <span class="title">noexcept</span><span class="params">(<span class="literal">false</span>)</span> </span>&#123;</span><br><span class="line">  S *s = <span class="keyword">new</span> S;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  s-&gt;f();</span><br><span class="line">  <span class="keyword">delete</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="合规方案-Automatic-Storage-Duration"><a class="header-anchor" href="#合规方案-Automatic-Storage-Duration">¶</a>合规方案 (Automatic Storage Duration)</h2><p>当有可能时，使用自动存储期 (Automatic Storage Duration) 来代替动态存储期 (dynamic storage duration) 。既然 <code>s</code> 在 <code>g()</code> 范围之外不再被用到，这个合规方案利用自动存储期来限制在 <code>g()</code> 作用范围内的 <code>s</code> 的生命周期。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  S s;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  s.f();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="不合规的代码示例-std-unique-ptr"><a class="header-anchor" href="#不合规的代码示例-std-unique-ptr">¶</a>不合规的代码示例 (<code>std::unique_ptr</code>)</h2><p>在接下来这个不合规的代码示例中， <code>buff</code> 对象的析构函数在隐式地释放了由 <code>buff</code> 对象管理的动态分配的内存之后，这块内存被访问了。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *s = <span class="string">""</span>;</span><br><span class="line">  <span class="keyword">if</span> (argc &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">enum</span> &#123; BufferSize = <span class="number">32</span> &#125;;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      std::unique_ptr&lt;char[]&gt; buff(new char[BufferSize]);</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">memset</span>(buff.<span class="built_in">get</span>(), <span class="number">0</span>, BufferSize);</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      s = <span class="built_in">std</span>::<span class="built_in">strncpy</span>(buff.<span class="built_in">get</span>(), argv[<span class="number">1</span>], BufferSize - <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="built_in">std</span>::bad_alloc &amp;) &#123;</span><br><span class="line">      <span class="comment">// Handle error</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>这段代码总是构造了一个 null 结尾的字符串，即使用了 <code>strncpy()</code> ，因为它把缓冲区的末尾 <code>char</code> 设为 0。</p><h2 id="合规方案-std-unique-ptr"><a class="header-anchor" href="#合规方案-std-unique-ptr">¶</a>合规方案 (<code>std::unique_ptr</code>)</h2><p>在这个合规方案中， <code>buff</code> 的生命周期被延长到了访问被其管理的内存之后。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">char</span>[]&gt; buff;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *s = <span class="string">""</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (argc &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">enum</span> &#123; BufferSize = <span class="number">32</span> &#125;;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      buff.reset(<span class="keyword">new</span> <span class="keyword">char</span>[BufferSize]);</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">memset</span>(buff.get(), <span class="number">0</span>, BufferSize);</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      s = <span class="built_in">std</span>::<span class="built_in">strncpy</span>(buff.get(), argv[<span class="number">1</span>], BufferSize - <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="built_in">std</span>::bad_alloc &amp;) &#123;</span><br><span class="line">      <span class="comment">// Handle error</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="合规方案"><a class="header-anchor" href="#合规方案">¶</a>合规方案</h2><p>在这个合规方案中，使用了一个带由自动存储期的 <code>std::string</code> 类型的变量来代替 <code>std::unique_ptr&lt;char[]&gt;</code> ，这降低了方案的复杂度且提高了安全性。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> str;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (argc &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    str = argv[<span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="不合规的代码示例-std-string-c-str"><a class="header-anchor" href="#不合规的代码示例-std-string-c-str">¶</a>不合规的代码示例 (<code>std::string::c_str()</code>)</h2><p>在这个不合规的代码示例中，在一个临时的 <code>std::string</code> 对象上调用了 <code>std::string::c_str()</code> 。一旦 <code>std::string</code> 对象在赋值运算结束后被销毁，存放结果的指针将指向被释放的内存。当访问了指针指向的元素时，将导致 <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-undefinedbehavior" target="_blank" rel="noopener">未定义行为</a> 。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">str_func</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display_string</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *)</span></span>;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *str = str_func().c_str();</span><br><span class="line">  display_string(str);  <span class="comment">/* Undefined behavior */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码总是构造了一个 null 结尾的字符串，即使用了 <code>strncpy()</code> ，因为它把缓冲区的末尾 <code>char</code> 设为 0。</p><h2 id="合规方案-std-string-c-str"><a class="header-anchor" href="#合规方案-std-string-c-str">¶</a>合规方案 (<code>std::string::c_str()</code>)</h2><p>在这个合规方案中，构造了该字符串的局部拷贝来确保当调用 <code>display_string()</code> 时，字符串 <code>str</code> 将是可用的。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">str_func</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display_string</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> str = str_func();</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *cstr = str.c_str();</span><br><span class="line">  display_string(cstr);  <span class="comment">/* ok */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="不合规的代码示例"><a class="header-anchor" href="#不合规的代码示例">¶</a>不合规的代码示例</h2><p>在这个不合规的代码示例中，试图通过调用 <code>operator new()</code> 来分配零字节的内存。如果该请求成功， <code>operator new()</code> 应返回非空指针值。然而，根据 C++ 标准，[basic.stc.dynamic.allocation], 段落 2 [<a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-ISO/IEC14882-2014" target="_blank" rel="noopener">ISO/IEC 14882-2014</a>], 试图通过这类指针来解引用将导致 <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-undefinedbehavior" target="_blank" rel="noopener">未定义行为</a> 。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;new&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> <span class="title">noexcept</span><span class="params">(<span class="literal">false</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> *ptr = <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span> *&gt;(::<span class="keyword">operator</span> <span class="keyword">new</span>(<span class="number">0</span>));</span><br><span class="line">  *ptr = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  ::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(ptr)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="合规方案-v2"><a class="header-anchor" href="#合规方案-v2">¶</a>合规方案</h2><p>在这个合规方案依赖程序员的意图。如果程序员试图分配单个 <code>unsigned char</code> 对象，这个合规方案将利用 <code>new</code> 来替代直接调用 <code>operator new()</code> ，如该合规方案所示。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> <span class="title">noexcept</span><span class="params">(<span class="literal">false</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> *ptr = <span class="keyword">new</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>;</span><br><span class="line">  *ptr = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">delete</span> ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="合规方案-v3"><a class="header-anchor" href="#合规方案-v3">¶</a>合规方案</h2><p>如果程序员试图分配零字节的内存（大概想得到一个不会被程序中其他指针复用的独有的指针值，除非它被正确释放），然后并不是试图去解引用这个返回的指针，建议的方案而是将 <code>ptr</code> 声明为 <code>void *</code> 类型。根据 <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-conformingprogram" target="_blank" rel="noopener">一致性 (conforming)</a> <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-implementation" target="_blank" rel="noopener">实现 (implementation)</a>.， 它不能被解引用。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> <span class="title">noexcept</span><span class="params">(<span class="literal">false</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> *ptr = <span class="keyword">new</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>;</span><br><span class="line">  *ptr = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">delete</span> ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Risk-Assessment"><a class="header-anchor" href="#Risk-Assessment">¶</a>Risk Assessment</h2><p>读取已经被释放的先前动态分配过的内存将导致 <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-abnormaltermination" target="_blank" rel="noopener">程序异常终止 abnormal program termination</a> 和 <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-denial-of-service" target="_blank" rel="noopener">拒绝服务攻击 denial-of-service attacks</a>. 对已经被释放的内存写入会导致执行提权的任意代码漏洞程序。</p><table><thead><tr><th style="text-align:left">Rule</th><th style="text-align:left">Severity</th><th style="text-align:left">Likelihood</th><th style="text-align:left">Remediation Cost</th><th style="text-align:left">Priority</th><th style="text-align:left">Level</th></tr></thead><tbody><tr><td style="text-align:left">MEM50-CPP</td><td style="text-align:left">High</td><td style="text-align:left">Likely</td><td style="text-align:left">Medium</td><td style="text-align:left"><strong>P18</strong></td><td style="text-align:left"><strong>L1</strong></td></tr></tbody></table><h2 id="Automated-Detection"><a class="header-anchor" href="#Automated-Detection">¶</a>Automated Detection</h2><table><thead><tr><th style="text-align:left">Tool</th><th style="text-align:left">Version</th><th style="text-align:left">Checker</th><th style="text-align:left">Description</th></tr></thead><tbody><tr><td style="text-align:left"><a href="https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=222953724" target="_blank" rel="noopener">Astrée</a></td><td style="text-align:left">20.10</td><td style="text-align:left"><strong>dangling_pointer_use</strong></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/Axivion+Bauhaus+Suite" target="_blank" rel="noopener">Axivion Bauhaus Suite</a></td><td style="text-align:left">7.2.0</td><td style="text-align:left"><strong>CertC+±MEM50</strong></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/Clang" target="_blank" rel="noopener">Clang</a></td><td style="text-align:left">3.9</td><td style="text-align:left"><code>clang-analyzer-cplusplus.NewDeleteclang-analyzer-alpha.security.ArrayBoundV2</code></td><td style="text-align:left">Checked by <code>clang-tidy</code>, but does not catch all violations of this rule.</td></tr><tr><td style="text-align:left"><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/CodeSonar" target="_blank" rel="noopener">CodeSonar</a></td><td style="text-align:left">6.1p0</td><td style="text-align:left"><strong>ALLOC.UAF</strong></td><td style="text-align:left">Use after free</td></tr><tr><td style="text-align:left"><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/Rose" target="_blank" rel="noopener">Compass/ROSE</a></td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><a href="https://wiki.sei.cmu.edu/confluence/display/c/Coverity" target="_blank" rel="noopener">Coverity</a></td><td style="text-align:left">v7.5.0</td><td style="text-align:left"><strong>USE_AFTER_FREE</strong></td><td style="text-align:left">Can detect the specific instances where memory is deallocated more than once or read/written to the target of a freed pointer</td></tr><tr><td style="text-align:left"><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/Helix+QAC" target="_blank" rel="noopener">Helix QAC</a></td><td style="text-align:left">2021.2</td><td style="text-align:left"><strong>C<ins>4303, C</ins>4304</strong></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/Klocwork" target="_blank" rel="noopener">Klocwork</a></td><td style="text-align:left">2021.1</td><td style="text-align:left"><strong><a href="https://support.roguewave.com/documentation/klocwork/en/current/certcandcsecurecodingstandardidsmappedtoklocworkcandccheckers/" target="_blank" rel="noopener">UFM.DEREF.MIGHT</a></strong> <strong><a href="https://support.roguewave.com/documentation/klocwork/en/current/certcandcsecurecodingstandardidsmappedtoklocworkcandccheckers/" target="_blank" rel="noopener">UFM.DEREF.MUST</a></strong> <strong><a href="https://support.roguewave.com/documentation/klocwork/en/current/certcandcsecurecodingstandardidsmappedtoklocworkcandccheckers/" target="_blank" rel="noopener">UFM.FFM.MIGHT</a></strong> <strong><a href="https://support.roguewave.com/documentation/klocwork/en/current/certcandcsecurecodingstandardidsmappedtoklocworkcandccheckers/" target="_blank" rel="noopener">UFM.FFM.MUST</a></strong> <strong><a href="https://support.roguewave.com/documentation/klocwork/en/current/certcandcsecurecodingstandardidsmappedtoklocworkcandccheckers/" target="_blank" rel="noopener">UFM.RETURN.MIGHT</a></strong> <strong><a href="https://support.roguewave.com/documentation/klocwork/en/current/certcandcsecurecodingstandardidsmappedtoklocworkcandccheckers/" target="_blank" rel="noopener">UFM.RETURN.MUST</a></strong> <strong><a href="https://support.roguewave.com/documentation/klocwork/en/current/certcandcsecurecodingstandardidsmappedtoklocworkcandccheckers/" target="_blank" rel="noopener">UFM.USE.MIGHT</a></strong> <strong><a href="https://support.roguewave.com/documentation/klocwork/en/current/certcandcsecurecodingstandardidsmappedtoklocworkcandccheckers/" target="_blank" rel="noopener">UFM.USE.MUST</a></strong></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/LDRA" target="_blank" rel="noopener">LDRA tool suite</a></td><td style="text-align:left">9.7.1</td><td style="text-align:left"><strong>483 S, 484 S</strong>** **</td><td style="text-align:left">Partially implemented</td></tr><tr><td style="text-align:left"><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/Parasoft" target="_blank" rel="noopener">Parasoft C/C++test</a></td><td style="text-align:left">2021.1</td><td style="text-align:left">**CERT_CPP-MEM50-a **</td><td style="text-align:left">Do not use resources that have been freed</td></tr><tr><td style="text-align:left"><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/Parasoft" target="_blank" rel="noopener">Parasoft Insure++</a></td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left">Runtime detection</td></tr><tr><td style="text-align:left"><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/Polyspace+Bug+Finder" target="_blank" rel="noopener">Polyspace Bug Finder</a></td><td style="text-align:left">R2021b</td><td style="text-align:left"><a href="https://www.mathworks.com/help/bugfinder/ref/certcmem50cpp.html" target="_blank" rel="noopener">CERT C++: MEM50-CPP</a></td><td style="text-align:left">Checks for:Pointer access out of boundsDeallocation of previously deallocated pointerUse of previously freed pointerRule partially covered.</td></tr><tr><td style="text-align:left"><a href="https://www.securecoding.cert.org/confluence/pages/viewpage.action?pageId=142409849" target="_blank" rel="noopener">PRQA QA-C++</a></td><td style="text-align:left">4.4</td><td style="text-align:left"><strong>4303, 4304</strong></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/PVS-Studio" target="_blank" rel="noopener">PVS-Studio</a></td><td style="text-align:left">7.15</td><td style="text-align:left"><a href="https://pvs-studio.com/en/docs/warnings/v586/" target="_blank" rel="noopener"><strong>V586</strong></a>, <strong><a href="https://pvs-studio.com/en/docs/warnings/v774/" target="_blank" rel="noopener">V774</a></strong></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/Splint" target="_blank" rel="noopener">Splint</a></td><td style="text-align:left">5.0</td><td style="text-align:left"></td><td style="text-align:left"></td></tr></tbody></table><h2 id="Related-Vulnerabilities"><a class="header-anchor" href="#Related-Vulnerabilities">¶</a>Related Vulnerabilities</h2><p>VU#623332 describes a double-free vulnerability in the MIT Kerberos 5 function <a href="http://web.mit.edu/kerberos/www/advisories/MITKRB5-SA-2005-003-recvauth.txt" target="_blank" rel="noopener">krb5_recvauth()</a> [<a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-VU623332" target="_blank" rel="noopener">VU# 623332</a>].</p><p>Search for other <a href="https://wiki.sei.cmu.edu/confluence/display/c/BB.+Definitions#BB.Definitions-vulnerability" target="_blank" rel="noopener">vulnerabilities</a> resulting from the violation of this rule on the <a href="https://www.kb.cert.org/vulnotes/bymetric?searchview&amp;query=FIELD+KEYWORDS+contains+MEM30-CPP" target="_blank" rel="noopener">CERT website</a>.</p><h2 id="Related-Guidelines"><a class="header-anchor" href="#Related-Guidelines">¶</a>Related Guidelines</h2><table><thead><tr><th><a href="https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=88046682" target="_blank" rel="noopener">SEI CERT C++ Coding Standard</a></th><th><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/EXP54-CPP.+Do+not+access+an+object+outside+of+its+lifetime" target="_blank" rel="noopener">EXP54-CPP. Do not access an object outside of its lifetime</a><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/MEM52-CPP.+Detect+and+handle+memory+allocation+errors" target="_blank" rel="noopener">MEM52-CPP. Detect and handle memory allocation errors</a></th></tr></thead><tbody><tr><td><a href="https://wiki.sei.cmu.edu/confluence/display/c/SEI+CERT+C+Coding+Standard" target="_blank" rel="noopener">SEI CERT C Coding Standard</a></td><td><a href="https://wiki.sei.cmu.edu/confluence/display/c/MEM30-C.+Do+not+access+freed+memory" target="_blank" rel="noopener">MEM30-C. Do not access freed memory</a></td></tr><tr><td><a href="http://cwe.mitre.org/" target="_blank" rel="noopener">MITRE CWE</a></td><td><a href="http://cwe.mitre.org/data/definitions/415.html" target="_blank" rel="noopener">CWE-415</a>, Double Free <a href="http://cwe.mitre.org/data/definitions/416.html" target="_blank" rel="noopener">CWE-416</a>, Use After Free</td></tr></tbody></table><h2 id="Bibliography"><a class="header-anchor" href="#Bibliography">¶</a>Bibliography</h2><table><thead><tr><th>[<a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-ISO/IEC14882-2014" target="_blank" rel="noopener">ISO/IEC 14882-2014</a>]</th><th>Subclause 3.7.4.1, “Allocation Functions” Subclause 3.7.4.2, “Deallocation Functions”</th></tr></thead><tbody><tr><td>[<a href="https://wiki.sei.cmu.edu/confluence/display/c/AA.+Bibliography#AA.Bibliography-Seacord2013" target="_blank" rel="noopener">Seacord 2013b</a>]</td><td>Chapter 4, “Dynamic Memory Management”</td></tr></tbody></table><!-- rebuild by neat -->]]></content>
      <categories>
        <category>SEI CERT C++</category>
      </categories>
      <tags>
        <tag>SEI CERT C++</tag>
        <tag>编码规范</tag>
        <tag>翻译</tag>
        <tag>Memory Management</tag>
      </tags>
  </entry>
  <entry>
    <title>FIO50-CPP. 在没有获取文件定位调用前，不要从一个文件流交替地读写</title>
    <url>/posts/3587208904/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><!-- build time:Sat Nov 13 2021 15:45:21 GMT+0000 (Coordinated Universal Time) --><p>原文链接：</p><p><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/FIO50-CPP.+Do+not+alternately+input+and+output+from+a+file+stream+without+an+intervening+positioning+call" target="_blank" rel="noopener">FIO50-CPP. Do not alternately input and output from a file stream without an intervening positioning call</a></p><a id="more"></a><hr><p>C++ 标准，[filebuf]，段落 2 [<a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-ISO/IEC14882-2014" target="_blank" rel="noopener">ISO/IEC 14882-2014</a>]，叙述如下：</p><blockquote><p>受类 <code>basic_filebuf&lt;charT, traits&gt;</code> 的对象控制的读写限制和 C 标准库 <code>FILES</code> 是一样</p></blockquote><p>C 标准，分条款 7.19.5.3，段落 6 [<a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-ISO-IEC9899-1999" target="_blank" rel="noopener">ISO/IEC 9899:1999</a>]，当需要对一个打开的文件流同时读写时，遵循以下限制：</p><blockquote><p>当一个文件正被以更新的模式打开时……，相关数据流可能同时执行输入和输出操作。然而，当没有 <code>fflush</code> 函数或获取文件位置函数（<code>fseek</code>，<code>fsetpos</code>，<code>rewind</code>）的介入调用（intervening call），输出不应该直接接着输入，除非输入操作遇到了文件结束符。</p></blockquote><p>所以，下述情景可能导致 <a href="https://wiki.sei.cmu.edu/confluence/display/c/BB.+Definitions#BB.Definitions-undefinedbehavior" target="_blank" rel="noopener">未定义行为</a>：</p><ul><li><p>如果文件并不处于结束符，那么在输出到数据流操作后紧接着从该数据流输入，而没有 <code>std::basic_filebuf&lt;T&gt;::seekoff()</code> 的介入调用</p></li><li><p>如果文件并不处于结束符，那么在从数据流输入后紧接着输出到该数据流，而没有 <code>std::basic_filebuf&lt;T&gt;::seekoff()</code> 的介入调用</p></li></ul><p>除 <code>std::basic_filebuf&lt;T&gt;::seekoff()</code> 之外，没有其他函数能保证行为和调用 C 标准库的文件定位函数一致，或 <code>std::fflush()</code>。</p><p>对一个文件流调用 <code>std::basic_ostream&lt;T&gt;::seekp()</code> 或 <code>std::basic_istream&lt;T&gt;::seekg()</code> 最终还是会调用到 <code>std::basic_filebuf&lt;T&gt;::seekoff()</code> . 考虑到 <code>std::basic_iostream&lt;T&gt;</code> 同时从继承于 <code>std::basic_ostream&lt;T&gt;</code> 和 <code>std::basic_istream&lt;T&gt;</code>, 并且 <code>std::fstream</code> 继承于 <code>std::basic_iostream</code>, 用来保证文件流在被后续 I/O 操作前处于合法状态的任何函数调用都是可接受的。</p><h2 id="不合规的代码示例"><a class="header-anchor" href="#不合规的代码示例">¶</a>不合规的代码示例</h2><p>这个不合规的例子在文件末尾附加了数据，然后从同一个文件里读取。然而，由于在格式化输出和输入调用之间没有介入位置的调用，该行为是 <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-undefinedbehavior" target="_blank" rel="noopener">未定义</a> 的。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;fileName)</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::fstream <span class="title">file</span><span class="params">(fileName)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (!file.is_open()) &#123;</span><br><span class="line">    <span class="comment">// Handle error</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  file &lt;&lt; <span class="string">"Output some data"</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> str;</span><br><span class="line">  file &gt;&gt; str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="合规方案"><a class="header-anchor" href="#合规方案">¶</a>合规方案</h2><p>在这个合规方案中， <code>std::basic_istream&lt;T&gt;::seekg()</code> 函数在输入和输出之间被调用，消除了 <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-undefinedbehavior" target="_blank" rel="noopener">未定义行为</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;fileName)</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::fstream <span class="title">file</span><span class="params">(fileName)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (!file.is_open()) &#123;</span><br><span class="line">    <span class="comment">// Handle error</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  file &lt;&lt; <span class="string">"Output some data"</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> str;</span><br><span class="line">  file.seekg(<span class="number">0</span>, <span class="built_in">std</span>::ios::beg);</span><br><span class="line">  file &gt;&gt; str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Risk-Assessment"><a class="header-anchor" href="#Risk-Assessment">¶</a>Risk Assessment</h2><p>Alternately inputting and outputting from a stream without an intervening flush or positioning call is <a href="https://wiki.sei.cmu.edu/confluence/display/c/BB.+Definitions#BB.Definitions-undefinedbehavior" target="_blank" rel="noopener">undefined behavior</a>.</p><table><thead><tr><th style="text-align:left">Rule</th><th style="text-align:left">Severity</th><th style="text-align:left">Likelihood</th><th style="text-align:left">Remediation Cost</th><th style="text-align:left">Priority</th><th style="text-align:left">Level</th></tr></thead><tbody><tr><td style="text-align:left">FIO50-CPP</td><td style="text-align:left">Low</td><td style="text-align:left">Likely</td><td style="text-align:left">Medium</td><td style="text-align:left"><strong>P6</strong></td><td style="text-align:left"><strong>L2</strong></td></tr></tbody></table><h3 id="Automated-Detection"><a class="header-anchor" href="#Automated-Detection">¶</a>Automated Detection</h3><table><thead><tr><th style="text-align:left">Tool</th><th style="text-align:left">Version</th><th style="text-align:left">Checker</th><th style="text-align:left">Description</th></tr></thead><tbody><tr><td style="text-align:left"><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/Axivion+Bauhaus+Suite" target="_blank" rel="noopener">Axivion Bauhaus Suite</a></td><td style="text-align:left">7.2.0</td><td style="text-align:left"><strong>CertC+±FIO50</strong></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/Helix+QAC" target="_blank" rel="noopener">Helix QAC</a></td><td style="text-align:left">2021.2</td><td style="text-align:left"><strong>C<ins>4711, C</ins>4712, C++4713</strong></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/Parasoft" target="_blank" rel="noopener">Parasoft C/C++test</a></td><td style="text-align:left">2021.1</td><td style="text-align:left"><strong>CERT_CPP-FIO50-a</strong></td><td style="text-align:left">Do not alternately input and output from a stream without an intervening flush or positioning call</td></tr><tr><td style="text-align:left"><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/Polyspace+Bug+Finder" target="_blank" rel="noopener">Polyspace Bug Finder</a></td><td style="text-align:left">R2021b</td><td style="text-align:left"><a href="https://www.mathworks.com/help/bugfinder/ref/certcfio50cpp.html" target="_blank" rel="noopener">CERT C++: FIO50-CPP</a></td><td style="text-align:left">Checks for alternating input and output from a stream without flush or positioning call (rule fully covered)</td></tr></tbody></table><h3 id="Related-Vulnerabilities"><a class="header-anchor" href="#Related-Vulnerabilities">¶</a>Related Vulnerabilities</h3><p>Search for <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-vulnerabilit" target="_blank" rel="noopener">vulnerabilities</a> resulting from the violation of this rule on the <a href="https://www.kb.cert.org/vulnotes/bymetric?searchview&amp;query=FIELD+KEYWORDS+contains+FIO39-CPP" target="_blank" rel="noopener">CERT website</a>.</p><h2 id="Related-Guidelines"><a class="header-anchor" href="#Related-Guidelines">¶</a>Related Guidelines</h2><p><em>This rule supplements</em> <em><a href="https://wiki.sei.cmu.edu/confluence/display/c/FIO39-C.+Do+not+alternately+input+and+output+from+a+stream+without+an+intervening+flush+or+positioning+call" target="_blank" rel="noopener">FIO39-C. Do not alternately input and output from a stream without an intervening flush or positioning call</a>.</em></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>SEI CERT C++</category>
      </categories>
      <tags>
        <tag>SEI CERT C++</tag>
        <tag>编码规范</tag>
        <tag>翻译</tag>
        <tag>Input Output</tag>
      </tags>
  </entry>
  <entry>
    <title>CTR58-CPP. 谓词函数对象不应该是 mutable </title>
    <url>/posts/505389678/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><!-- build time:Sat Nov 13 2021 15:45:21 GMT+0000 (Coordinated Universal Time) --><p>原文链接：</p><p><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/CTR58-CPP.+Predicate+function+objects+should+not+be+mutable" target="_blank" rel="noopener">CTR58-CPP. Predicate function objects should not be mutable</a></p><p><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/CTR58-CPP.+Predicate+function+objects+should+not+be+mutable" target="_blank" rel="noopener">https://wiki.sei.cmu.edu/confluence/display/cplusplus/CTR58-CPP.+Predicate+function+objects+should+not+be+mutable</a></p><a id="more"></a><hr><p><s>This has nothing to do with CTR as a group, and everything to do with the algorithmic requirements of the STL. However, I cannot think of a better place for this rule to live (aside from MSC, and I think CTR is an improvement). If we wind up with an STL category, this should probably go there.</s></p><p>C++ 标准库实现了众多接收谓词函数对象的通用算法。C++ 标准, [algorithms.general], paragraph 10 [<a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-ISO/IEC14882-2014" target="_blank" rel="noopener">ISO/IEC 14882-2014</a>], 表述如下：</p><p>The C++ standard library implements numerous common algorithms that accept a predicate function object. The C++ Standard, [algorithms.general], paragraph 10 [<a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-ISO/IEC14882-2014" target="_blank" rel="noopener">ISO/IEC 14882-2014</a>], states the following:</p><blockquote><p>[<em>Note:</em> Unless otherwise specified, algorithms that take function objects as arguments are permitted to copy those function objects freely. Programmers for whom object identity is important should consider using a wrapper class that points to a noncopied implementation object such as <code>reference_wrapper&lt;T&gt;</code>, or some equivalent solution. — <em>end note</em>]</p></blockquote><p>因为这是一个算法是否拷贝谓词函数的 <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-implementation-definedbehavior" target="_blank" rel="noopener">implementation-defined</a> ，所以任何这类对象必须符合以下二者之一：</p><ul><li>实现一个不改变与函数对象标识相关的状态的函数调用操作，例如非静态数据成员或者被捕获的值</li><li>将谓词函数对象包装在一个 <code>std::reference_wrapper&lt;T&gt;</code> (或者等价方案)</li></ul><p>标记该函数调用操作为 <code>const</code> 是有益的，但不是充分的，因为 <code>mutable</code> 存储类型标识符的数据成员可能依然会在一个 <code>const</code> 成员函数中被修改。</p><p>Because it is <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-implementation-definedbehavior" target="_blank" rel="noopener">implementation-defined</a> whether an algorithm copies a predicate function object, any such object must either</p><ul><li>implement a function call operator that does not mutate state related to the function object’s identity, such as nonstatic data members or captured values, or</li><li>wrap the predicate function object in a <code>std::reference_wrapper&lt;T&gt;</code> (or an equivalent solution).</li></ul><p>Marking the function call operator as <code>const</code> is beneficial, but insufficient, because data members with the <code>mutable</code> storage class specifier may still be modified within a <code>const</code> member function.</p><h2 id="不合规的代码示例-仿函数-Noncompliant-Code-Example-Functor"><a class="header-anchor" href="#不合规的代码示例-仿函数-Noncompliant-Code-Example-Functor">¶</a>不合规的代码示例 (仿函数) Noncompliant Code Example (Functor)</h2><p>这个不合规的代码示例试图使用一个在第三次调用时返回 <code>true</code> 的谓词来移除一个容器中的第三项。</p><p>This noncompliant code example attempts to remove the third item in a container using a predicate that returns <code>true</code> only on its third invocation.</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MutablePredicate</span> :</span> <span class="keyword">public</span> <span class="built_in">std</span>::unary_function&lt;<span class="keyword">int</span>, <span class="keyword">bool</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">size_t</span> timesCalled;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  MutablePredicate() : timesCalled(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ++timesCalled == <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_container</span><span class="params">(Iter b, Iter e)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Contains: "</span>;</span><br><span class="line">  <span class="built_in">std</span>::copy(b, e, <span class="built_in">std</span>::ostream_iterator&lt;<span class="keyword">decltype</span>(*b)&gt;(<span class="built_in">std</span>::<span class="built_in">cout</span>, <span class="string">" "</span>));</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line">  print_container(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">  v.erase(<span class="built_in">std</span>::remove_if(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), MutablePredicate()), v.<span class="built_in">end</span>());</span><br><span class="line">  print_container(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而，<code>std::remove_if()</code> 被允许构造和使用其谓词函数额外的拷贝。任何这种额外的拷贝可能导致意外的输出。</p><p>However, <code>std::remove_if()</code> is permitted to construct and use extra copies of its predicate function. Any such extra copies may result in unexpected output.</p><h3 id="实现细节-Implementation-Details"><a class="header-anchor" href="#实现细节-Implementation-Details">¶</a>实现细节 Implementation Details</h3><p>使用 <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-gcc" target="_blank" rel="noopener">gcc</a> 4.8.1 和 <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-libstdcxx" target="_blank" rel="noopener">libstdc++</a> ，这个程序产生了下述结果。</p><p>This program produces the following results using <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-gcc" target="_blank" rel="noopener">gcc</a> 4.8.1 with <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-libstdcxx" target="_blank" rel="noopener">libstdc++</a>.</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Contains: 0 1 2 3 4 5 6 7 8 9</span><br><span class="line">Contains: 0 1 3 4 6 7 8 9</span><br></pre></td></tr></table></figure><p>这个结果的产生由于 <code>std::remove_if</code> 在调用前，拷贝了两份谓词函数。第一份拷贝被用来确定第一个元素在序列中的位置，谓词返回的是 <code>true</code>。 随后的拷贝被用来移除序列中的其他元素。这个结果造成第三个元素 (<code>2</code>) 和第六个元素 (<code>5</code>) 被移除；两个不同的谓词函数被使用。</p><p>This result arises because <code>std::remove_if</code> makes two copies of the predicate before invoking it. The first copy is used to determine the location of the first element in the sequence for which the predicate returns <code>true</code>. The subsequent copy is used for removing other elements in the sequence. This results in the third element (<code>2</code>) and sixth element (<code>5</code>) being removed; two distinct predicate functions are used.</p><h2 id="不合规的代码示例-仿函数-Noncompliant-Code-Example-Lambda"><a class="header-anchor" href="#不合规的代码示例-仿函数-Noncompliant-Code-Example-Lambda">¶</a>不合规的代码示例 (仿函数) Noncompliant Code Example (Lambda)</h2><p>和仿函数不合规代码示例类似，这个不合规代码示例试图使用一个在其第三次调用时返回 <code>true</code> 的谓词 lambda 函数来移除第三项。和仿函数一样，这个 lambda 携带有局部状态信息，试图在其调用操作中修改。</p><p>Similar to the functor noncompliant code example, this noncompliant code example attempts to remove the third item in a container using a predicate lambda function that returns <code>true</code> only on its third invocation. As with the functor, this lambda carries local state information, which it attempts to mutate within its function call operator.</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_container</span><span class="params">(Iter b, Iter e)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Contains: "</span>;</span><br><span class="line">  <span class="built_in">std</span>::copy(b, e, <span class="built_in">std</span>::ostream_iterator&lt;<span class="keyword">decltype</span>(*b)&gt;(<span class="built_in">std</span>::<span class="built_in">cout</span>, <span class="string">" "</span>));</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line">  print_container(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> timesCalled = <span class="number">0</span>;</span><br><span class="line">  v.erase(<span class="built_in">std</span>::remove_if(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), [timesCalled](<span class="keyword">const</span> <span class="keyword">int</span> &amp;) <span class="keyword">mutable</span> &#123; <span class="keyword">return</span> ++timesCalled == <span class="number">3</span>; &#125;), v.<span class="built_in">end</span>());</span><br><span class="line">  print_container(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="合规方案-std-reference-wrapper-Compliant-Solution-std-reference-wrapper"><a class="header-anchor" href="#合规方案-std-reference-wrapper-Compliant-Solution-std-reference-wrapper">¶</a>合规方案 (<code>std::reference_wrapper</code>) Compliant Solution (<code>std::reference_wrapper</code>)</h2><p>这个合规方案将谓词包裹在 <code>std::reference_wrapper&lt;T&gt;</code> 对象中，确保包裹对象的拷贝全都引用相同的基础谓词对象。</p><p>This compliant solution wraps the predicate in a <code>std::reference_wrapper&lt;T&gt;</code> object, ensuring that copies of the wrapper object all refer to the same underlying predicate object.</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MutablePredicate</span> :</span> <span class="keyword">public</span> <span class="built_in">std</span>::unary_function&lt;<span class="keyword">int</span>, <span class="keyword">bool</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">size_t</span> timesCalled;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  MutablePredicate() : timesCalled(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ++timesCalled == <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_container</span><span class="params">(Iter b, Iter e)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Contains: "</span>;</span><br><span class="line">  <span class="built_in">std</span>::copy(b, e, <span class="built_in">std</span>::ostream_iterator&lt;<span class="keyword">decltype</span>(*b)&gt;(<span class="built_in">std</span>::<span class="built_in">cout</span>, <span class="string">" "</span>));</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line">  print_container(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">  MutablePredicate mp;</span><br><span class="line">  v.erase(<span class="built_in">std</span>::remove_if(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">std</span>::ref(mp)), v.<span class="built_in">end</span>());</span><br><span class="line">  print_container(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述合规方案演示了在仿函数对象上使用的引用包裹器，但同样地可用于有状态的 lambda。这个代码产生了期望的结果，只有第三个元素被移除。</p><p>The above compliant solution demonstrates using a reference wrapper over a functor object but can similarly be used with a stateful lambda. The code produces the expected results, where only the third element is removed.</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Contains: 0 1 2 3 4 5 6 7 8 9</span><br><span class="line">Contains: 0 1 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure><h2 id="合规方案-迭代器运算-Compliant-Solution-Iterator-Arithmetic"><a class="header-anchor" href="#合规方案-迭代器运算-Compliant-Solution-Iterator-Arithmetic">¶</a>合规方案 (迭代器运算) Compliant Solution (Iterator Arithmetic)</h2><p>移除一个容器中的特定元素不需要谓词函数，但是可以简单地用 <code>std::vector::erase()</code> 来替换，像这个合规方案。</p><p>Removing a specific element of a container does not require a predicate function but can instead simply use <code>std::vector::erase()</code>, as in this compliant solution.</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_container</span><span class="params">(Iter B, Iter E)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Contains: "</span>;</span><br><span class="line">  <span class="built_in">std</span>::copy(B, E, <span class="built_in">std</span>::ostream_iterator&lt;<span class="keyword">decltype</span>(*B)&gt;(<span class="built_in">std</span>::<span class="built_in">cout</span>, <span class="string">" "</span>));</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line">  print_container(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">  v.erase(v.<span class="built_in">begin</span>() + <span class="number">3</span>);</span><br><span class="line">  print_container(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="风险评估-Risk-Assessment"><a class="header-anchor" href="#风险评估-Risk-Assessment">¶</a>风险评估 Risk Assessment</h2><p>使用包含状态地谓词函数对象会产生意外的值。</p><p>Using a predicate function object that contains state can produce unexpected values.</p><table><thead><tr><th style="text-align:left">Rule</th><th style="text-align:left">Severity</th><th style="text-align:left">Likelihood</th><th style="text-align:left">Remediation Cost</th><th style="text-align:left">Priority</th><th style="text-align:left">Level</th></tr></thead><tbody><tr><td style="text-align:left">CTR58-CPP</td><td style="text-align:left">Low</td><td style="text-align:left">Likely</td><td style="text-align:left">High</td><td style="text-align:left"><strong>P3</strong></td><td style="text-align:left"><strong>L3</strong></td></tr></tbody></table><h2 id="Automated-Detection"><a class="header-anchor" href="#Automated-Detection">¶</a>Automated Detection</h2><table><thead><tr><th style="text-align:left">Tool</th><th style="text-align:left">Version</th><th style="text-align:left">Checker</th><th style="text-align:left">Description</th></tr></thead><tbody><tr><td style="text-align:left"><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/Parasoft" target="_blank" rel="noopener">Parasoft C/C++test</a></td><td style="text-align:left"><img data-src="https://wiki.sei.cmu.edu/confluence/plugins/servlet/confluence/placeholder/macro?definition=e2luY2x1ZGU6UGFyYXNvZnRfVn0&amp;locale=zh_CN&amp;version=2" alt="img"></td><td style="text-align:left"><strong>CERT_CPP-CTR58-a</strong></td><td style="text-align:left">Make predicates const pure functions</td></tr><tr><td style="text-align:left"><a href="https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=88046345" target="_blank" rel="noopener">PRQA QA-C++</a></td><td style="text-align:left"><img data-src="https://wiki.sei.cmu.edu/confluence/plugins/servlet/confluence/placeholder/macro?definition=e2luY2x1ZGU6UFJRQSBRQS1DKytfVn0&amp;locale=zh_CN&amp;version=2" alt="img"></td><td style="text-align:left">**3225, 3226, 3227, 3228, 3229,****3230, 3231, 3232, 3233, 3234**</td><td style="text-align:left"></td></tr></tbody></table><h2 id="Related-Vulnerabilities"><a class="header-anchor" href="#Related-Vulnerabilities">¶</a>Related Vulnerabilities</h2><p>Search for <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-vulnerabi" target="_blank" rel="noopener">vulnerabilities</a> resulting from the violation of this rule on the <a href="https://www.kb.cert.org/vulnotes/bymetric?searchview&amp;query=FIELD+KEYWORDS+contains+CTR44-CPP" target="_blank" rel="noopener">CERT website</a>.</p><h2 id="Bibliography"><a class="header-anchor" href="#Bibliography">¶</a>Bibliography</h2><table><thead><tr><th>[<a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-ISO/IEC14882-2014" target="_blank" rel="noopener">ISO/IEC 14882-2014</a>]</th><th>Subclause 25.1, “General”</th></tr></thead><tbody><tr><td>[<a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-Meyers01" target="_blank" rel="noopener">Meyers 2001</a>]</td><td>Item 39, “Make Predicates Pure Functions”</td></tr></tbody></table><hr><p><a href="https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=88046458" target="_blank" rel="noopener"><img data-src="https://wiki.sei.cmu.edu/confluence/download/attachments/88046682/button_arrow_left.png?version=1&amp;modificationDate=1216910800000&amp;api=v2" alt="SEI CERT C++ Coding Standard &gt; SEI CERT C++ Coding Standard &gt; button_arrow_left.png"></a><a href="https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=88046331" target="_blank" rel="noopener"><img data-src="https://wiki.sei.cmu.edu/confluence/download/attachments/88046682/button_arrow_up.png?version=1&amp;modificationDate=1216910618000&amp;api=v2" alt="SEI CERT C++ Coding Standard &gt; SEI CERT C++ Coding Standard &gt; button_arrow_up.png"></a><a href="https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=88046330" target="_blank" rel="noopener"><img data-src="https://wiki.sei.cmu.edu/confluence/download/attachments/88046682/button_arrow_right.png?version=1&amp;modificationDate=1216910815000&amp;api=v2" alt="SEI CERT C++ Coding Standard &gt; SEI CERT C++ Coding Standard &gt; button_arrow_right.png"></a></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>SEI CERT C++</category>
      </categories>
      <tags>
        <tag>SEI CERT C++</tag>
        <tag>编码规范</tag>
        <tag>翻译</tag>
        <tag>CERT Containers</tag>
      </tags>
  </entry>
  <entry>
    <title>CTR57-CPP. 提供一个有效排序的谓词</title>
    <url>/posts/2368459165/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><!-- build time:Sat Nov 13 2021 15:45:21 GMT+0000 (Coordinated Universal Time) --><p>原文链接：</p><p><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/CTR57-CPP.+Provide+a+valid+ordering+predicate" target="_blank" rel="noopener">CTR57-CPP. Provide a valid ordering predicate</a></p><p><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/CTR57-CPP.+Provide+a+valid+ordering+predicate" target="_blank" rel="noopener">https://wiki.sei.cmu.edu/confluence/display/cplusplus/CTR57-CPP.+Provide+a+valid+ordering+predicate</a></p><a id="more"></a><hr><p>关联容器在他们的键比较谓词上设置了严格的弱排序要求 [<a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-ISO/IEC14882-2014" target="_blank" rel="noopener">ISO/IEC 14882-2014</a>]。一个严格的弱排序具有以下特性：</p><ul><li>对于所有的 <code>x</code>: <code>x &lt; x == false</code> (非自反性)</li><li>对于所有的 <code>x</code>, <code>y</code>: 如果 <code>x &lt; y</code> 那么<code>!(y &lt; x)</code> (不对称性)</li><li>对于所有的 <code>x</code>, <code>y</code>, <code>z</code>: 如果 <code>x &lt; y &amp;&amp; y &lt; z</code> 那么 <code>x &lt; z</code> (传递性)</li></ul><p>提供无效排序的谓词给对关联容器 (e.g., sets, maps, multisets, and multimaps)，或者作为排序算法的比较准测，会导致奇怪的行为或者无线循环 [<a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-Meyers01" target="_blank" rel="noopener">Meyers 01</a>]。当关联容器或者通用标准模板库算法需要一个排序谓词时，谓词必须满足严格的弱排序要求。</p><p>Associative containers place a strict weak ordering requirement on their key comparison predicates [<a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-ISO/IEC14882-2014" target="_blank" rel="noopener">ISO/IEC 14882-2014</a>]. A strict weak ordering has the following properties:</p><ul><li>for all <code>x</code>: <code>x &lt; x == false</code> (irreflexivity)</li><li>for all <code>x</code>, <code>y</code>: if <code>x &lt; y</code> then <code>!(y &lt; x)</code> (asymmetry)</li><li>for all <code>x</code>, <code>y</code>, <code>z</code>: if <code>x &lt; y &amp;&amp; y &lt; z</code>then<code>x &lt; z</code> (transitivity)</li></ul><p>Providing an invalid ordering predicate for an associative container (e.g., sets, maps, multisets, and multimaps), or as a comparison criterion with the sorting algorithms, can result in erratic behavior or infinite loops [<a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-Meyers01" target="_blank" rel="noopener">Meyers 01</a>]. When an ordering predicate is required for an associative container or a generic standard template library algorithm, the predicate must meet the requirements for inducing a strict weak ordering.</p><h2 id="不合规的代码示例-Noncompliant-Code-Example"><a class="header-anchor" href="#不合规的代码示例-Noncompliant-Code-Example">¶</a>不合规的代码示例 Noncompliant Code Example</h2><p>在这个不合规的代码示例中，通过使用不遵循严格弱排序要求的比较器来创建 <code>std::set</code> 对象。特别地，对于相等的值这不会返回 false。因此，遍历来自 <code>std::set::equal_range</code> 返回的结果将造成 <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-unspecifiedbehavior" target="_blank" rel="noopener">unspecified behavior</a>。</p><p>In this noncompliant code example, the <code>std::set</code> object is created with a comparator that does not adhere to the strict weak ordering requirement. Specifically, it fails to return false for equivalent values. As a result, the behavior of iterating over the results from <code>std::set::equal_range</code> results in <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-unspecifiedbehavior" target="_blank" rel="noopener">unspecified behavior</a>.</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::less_equal&lt;<span class="keyword">int</span>&gt;&gt; s&#123;<span class="number">5</span>, <span class="number">10</span>, <span class="number">20</span>&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> r = s.equal_range(<span class="number">10</span>); r.first != r.second; ++r.first) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *r.first &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="合规方案-Compliant-Solution"><a class="header-anchor" href="#合规方案-Compliant-Solution">¶</a>合规方案 Compliant Solution</h2><p>这个合规方案使用 <code>std::set</code> 默认比较器替换提供的不合理的比较器。</p><p>This compliant solution uses the default comparator with <code>std::set</code> instead of providing an invalid one.</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s&#123;<span class="number">5</span>, <span class="number">10</span>, <span class="number">20</span>&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> r = s.equal_range(<span class="number">10</span>); r.first != r.second; ++r.first) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *r.first &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="不合规的代码示例-Noncompliant-Code-Example-v2"><a class="header-anchor" href="#不合规的代码示例-Noncompliant-Code-Example-v2">¶</a>不合规的代码示例 Noncompliant Code Example</h2><p>在这个不合规的代码示例中，被存储在 <code>std::set</code> 的对象有一个重载 <code>operator&lt;</code> 的实现，允许对象通过 <code>std::less</code> 来比较。然而，比较运算没有提供严格的弱排序。特别地，两个 sets，x 和 y，值均为 1， 但是 j 的值不一样，会导致 <code>comp(x, y)</code> 和 <code>comp(y, x)</code> 均返回 false 的场景。不满足非对称要求。</p><p>In this noncompliant code example, the objects stored in the std::set have an overloaded operator&lt; implementation, allowing the objects to be compared with std::less. However, the comparison operation does not provide a strict weak ordering. Specifically, two sets, x and y, whose i values are both 1, but have differing j values can result in a situation where comp(x, y) and comp(y, x) are both false, failing the asymmetry requirements.</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">S</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> i, j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  S(<span class="keyword">int</span> i, <span class="keyword">int</span> j) : i(i), j(j) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> S &amp;lhs, <span class="keyword">const</span> S &amp;rhs) &#123;</span><br><span class="line">    <span class="keyword">return</span> lhs.i &lt; rhs.i &amp;&amp; lhs.j &lt; rhs.j;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">friend</span> <span class="built_in">std</span>::ostream &amp;<span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream &amp;os, <span class="keyword">const</span> S&amp; o) &#123;</span><br><span class="line">    os &lt;&lt; <span class="string">"i: "</span> &lt;&lt; o.i &lt;&lt; <span class="string">", j: "</span> &lt;&lt; o.j;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">set</span>&lt;S&gt; t&#123;S(<span class="number">1</span>, <span class="number">1</span>), S(<span class="number">1</span>, <span class="number">2</span>), S(<span class="number">2</span>, <span class="number">1</span>)&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> v : t) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; v &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="合规方案-Compliant-Solution-v2"><a class="header-anchor" href="#合规方案-Compliant-Solution-v2">¶</a>合规方案 Compliant Solution</h2><p>这个合规方案使用 <code>std::tie()</code> 来实现 <code>operator&lt;</code> 严格的弱排序谓词。</p><p>This compliant solution uses std::tie() to properly implement the strict weak ordering operator&lt; predicate.</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tuple&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">S</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> i, j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  S(<span class="keyword">int</span> i, <span class="keyword">int</span> j) : i(i), j(j) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> S &amp;lhs, <span class="keyword">const</span> S &amp;rhs) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::tie(lhs.i, lhs.j) &lt; <span class="built_in">std</span>::tie(rhs.i, rhs.j);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">friend</span> <span class="built_in">std</span>::ostream &amp;<span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream &amp;os, <span class="keyword">const</span> S&amp; o) &#123;</span><br><span class="line">    os &lt;&lt; <span class="string">"i: "</span> &lt;&lt; o.i &lt;&lt; <span class="string">", j: "</span> &lt;&lt; o.j;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">set</span>&lt;S&gt; t&#123;S(<span class="number">1</span>, <span class="number">1</span>), S(<span class="number">1</span>, <span class="number">2</span>), S(<span class="number">2</span>, <span class="number">1</span>)&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> v : t) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; v &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="风险评估-Risk-Assessment"><a class="header-anchor" href="#风险评估-Risk-Assessment">¶</a>风险评估 Risk Assessment</h2><p>使用一个无效排序规则会导致怪异的行为或无限循环。</p><p>Using an invalid ordering rule can lead to erratic behavior or infinite loops.</p><table><thead><tr><th style="text-align:left">Rule</th><th style="text-align:left">Severity</th><th style="text-align:left">Likelihood</th><th style="text-align:left">Remediation Cost</th><th style="text-align:left">Priority</th><th style="text-align:left">Level</th></tr></thead><tbody><tr><td style="text-align:left">CTR57-CPP</td><td style="text-align:left">Low</td><td style="text-align:left">Probable</td><td style="text-align:left">High</td><td style="text-align:left"><strong>P2</strong></td><td style="text-align:left"><strong>L3</strong></td></tr></tbody></table><h2 id="Automated-Detection"><a class="header-anchor" href="#Automated-Detection">¶</a>Automated Detection</h2><table><thead><tr><th style="text-align:left">Tool</th><th style="text-align:left">Version</th><th style="text-align:left">Checker</th><th style="text-align:left">Description</th></tr></thead><tbody><tr><td style="text-align:left"><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/Parasoft" target="_blank" rel="noopener">Parasoft C/C++test</a></td><td style="text-align:left"><img data-src="https://wiki.sei.cmu.edu/confluence/plugins/servlet/confluence/placeholder/macro?definition=e2luY2x1ZGU6UGFyYXNvZnRfVn0&amp;locale=zh_CN&amp;version=2" alt="img"></td><td style="text-align:left"><strong>CERT_CPP-CTR57-a</strong></td><td style="text-align:left">For associative containers never use comparison function returning true for equal values</td></tr></tbody></table><h2 id="Related-Vulnerabilities"><a class="header-anchor" href="#Related-Vulnerabilities">¶</a>Related Vulnerabilities</h2><p>Search for <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-vul" target="_blank" rel="noopener">vulnerabilities</a> resulting from the violation of this rule on the <a href="https://www.kb.cert.org/vulnotes/bymetric?searchview&amp;query=FIELD+KEYWORDS+contains+CTR40-CPP" target="_blank" rel="noopener">CERT website</a>.</p><h2 id="Related-Guidelines"><a class="header-anchor" href="#Related-Guidelines">¶</a>Related Guidelines</h2><table><thead><tr><th><a href="https://wiki.sei.cmu.edu/confluence/display/java/SEI+CERT+Oracle+Coding+Standard+for+Java" target="_blank" rel="noopener">SEI CERT Oracle Coding Standard for Java</a></th><th><a href="https://wiki.sei.cmu.edu/confluence/display/java/MET10-J.+Follow+the+general+contract+when+implementing+the+compareTo()+method" target="_blank" rel="noopener">MET10-J. Follow the general contract when implementing the compareTo() method</a></th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><h2 id="Bibliography"><a class="header-anchor" href="#Bibliography">¶</a>Bibliography</h2><table><thead><tr><th>[<a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-ISO/IEC14882-2014" target="_blank" rel="noopener">ISO/IEC 14882-2014</a>]</th><th>Subclause 23.2.4, “Associative Containers”</th></tr></thead><tbody><tr><td>[<a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-Meyers01" target="_blank" rel="noopener">Meyers 2001</a>]</td><td>Item 21, “Always Have Comparison Functions Return False for Equal Values”</td></tr><tr><td>[<a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-Sutter04" target="_blank" rel="noopener">Sutter 2004</a>]</td><td>Item 83, “Use a Checked STL Implementation”</td></tr></tbody></table><hr><p><a href="https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=88046755" target="_blank" rel="noopener"><img data-src="https://wiki.sei.cmu.edu/confluence/download/attachments/88046682/button_arrow_left.png?version=1&amp;modificationDate=1216910800000&amp;api=v2" alt="SEI CERT C++ Coding Standard &gt; SEI CERT C++ Coding Standard &gt; button_arrow_left.png"></a><a href="https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=88046331" target="_blank" rel="noopener"><img data-src="https://wiki.sei.cmu.edu/confluence/download/attachments/88046682/button_arrow_up.png?version=1&amp;modificationDate=1216910618000&amp;api=v2" alt="SEI CERT C++ Coding Standard &gt; SEI CERT C++ Coding Standard &gt; button_arrow_up.png"></a><a href="https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=88046679" target="_blank" rel="noopener"><img data-src="https://wiki.sei.cmu.edu/confluence/download/attachments/88046682/button_arrow_right.png?version=1&amp;modificationDate=1216910815000&amp;api=v2" alt="SEI CERT C++ Coding Standard &gt; SEI CERT C++ Coding Standard &gt; button_arrow_right.png"></a></p><p>备注，这里评论区提出了质疑，需要注意的。</p><h4 id="Timmy-Weerwag-发表："><a class="header-anchor" href="#Timmy-Weerwag-发表：">¶</a><a href="https://wiki.sei.cmu.edu/confluence/display/~tweerwag" target="_blank" rel="noopener">Timmy Weerwag</a> 发表：</h4><blockquote><p>The list of requirements at the top do not correctly specify a strict weak ordering. In fact, these only specify a strict partial ordering (note that asymetry is already implied by irreflexivity and transitivity). One also needs transitivity of incomparability.</p><p>The explanation for the second non-compliant example is also wrong. The relation is assymetric but fails the transitivity of incomparability. Consider P = (0, 2), Q = (2, 0) and R = (1, 3). Observe that P and Q are incomparable (neither P &lt; Q nor Q &lt; P), and Q and R are incomparable. However, P &lt; R and hence, P and R are comparable.</p></blockquote><!-- rebuild by neat -->]]></content>
      <categories>
        <category>SEI CERT C++</category>
      </categories>
      <tags>
        <tag>SEI CERT C++</tag>
        <tag>编码规范</tag>
        <tag>翻译</tag>
        <tag>CERT Containers</tag>
      </tags>
  </entry>
  <entry>
    <title>CTR56-CPP. 不要在多态对象上使用指针运算</title>
    <url>/posts/1493253227/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><!-- build time:Sat Nov 13 2021 15:45:21 GMT+0000 (Coordinated Universal Time) --><p>原文链接：</p><p><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/CTR56-CPP.+Do+not+use+pointer+arithmetic+on+polymorphic+objects" target="_blank" rel="noopener">CTR56-CPP. Do not use pointer arithmetic on polymorphic objects</a></p><p><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/CTR56-CPP.+Do+not+use+pointer+arithmetic+on+polymorphic+objects" target="_blank" rel="noopener">https://wiki.sei.cmu.edu/confluence/display/cplusplus/CTR56-CPP.+Do+not+use+pointer+arithmetic+on+polymorphic+objects</a></p><a id="more"></a><hr><p>来自 C++ 标准的 <em>指针运算</em> 的定义，[expr.add], paragraph 7 [<a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-ISO/IEC14882-2014" target="_blank" rel="noopener">ISO/IEC 14882-2014</a>]，陈述如下：</p><p>The definition of <em>pointer arithmetic</em> from the C++ Standard, [expr.add], paragraph 7 [<a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-ISO/IEC14882-2014" target="_blank" rel="noopener">ISO/IEC 14882-2014</a>], states the following:</p><blockquote><p>For addition or subtraction, if the expressions <code>P</code> or <code>Q</code> have type “pointer to <em>cv</em> <code>T</code>”, where <code>T</code> is different from the cv-unqualified array element type, the behavior is undefined. [<em>Note:</em> In particular, a pointer to a base class cannot be used for pointer arithmetic when the array contains objects of a derived class type. —<em>end note</em>]</p></blockquote><p>指针运算不考虑多态对象的大小，试图在多态对象上运用指针运算将导致<a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-undefinedbehavior" target="_blank" rel="noopener">undefined behavior</a>。</p><p>C++ 标准, [expr.sub], paragraph 1 [<a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-ISO/IEC14882-2014" target="_blank" rel="noopener">ISO/IEC 14882-2014</a>], 定义了数组下标操作被视为指针运算。特别地，它陈述如下：</p><p>Pointer arithmetic does not account for polymorphic object sizes, and attempting to perform pointer arithmetic on a polymorphic object value results in <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-undefinedbehavior" target="_blank" rel="noopener">undefined behavior</a>.</p><p>The C++ Standard, [expr.sub], paragraph 1 [<a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-ISO/IEC14882-2014" target="_blank" rel="noopener">ISO/IEC 14882-2014</a>], defines array subscripting as being identical to pointer arithmetic. Specifically, it states the following:</p><blockquote><p>The expression <code>E1[E2]</code> is identical (by definition) to <code>*((E1)+(E2))</code>.</p></blockquote><p>不要使用指针运算，包括数组下标操作或在多态对象上。</p><p>以下代码假定是后续静态对象和类的定义。</p><p>Do not use pointer arithmetic, including array subscripting, on polymorphic objects.</p><p>The following code examples assume the following static variables and class definitions.</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> globI;</span><br><span class="line"><span class="keyword">double</span> globD;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">  S() : i(globI++) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">T</span> :</span> S &#123;</span><br><span class="line">  <span class="keyword">double</span> d;</span><br><span class="line"></span><br><span class="line">  T() : S(), d(globD++) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="不合规的代码示例-指针运算-Noncompliant-Code-Example-Pointer-Arithmetic"><a class="header-anchor" href="#不合规的代码示例-指针运算-Noncompliant-Code-Example-Pointer-Arithmetic">¶</a>不合规的代码示例 (指针运算) Noncompliant Code Example (Pointer Arithmetic)</h2><p>在这个不合规的代码示例中，<code>f()</code> 接受一个 <code>S</code> 对象的数据作为第一个形参。然而，<code>main()</code> 传递了 <code>T</code> 对象的数组作为 <code>f()</code> 的实参，这将造成 <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-undefinedbehavior" target="_blank" rel="noopener">undefined behavior</a> ，因为 <code>for</code> 循环中使用了指针运算。</p><p>In this noncompliant code example, <code>f()</code> accepts an array of <code>S</code> objects as its first parameter. However, <code>main()</code> passes an array of <code>T</code> objects as the first argument to <code>f()</code>, which results in <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-undefinedbehavior" target="_blank" rel="noopener">undefined behavior</a> due to the pointer arithmetic used within the <code>for</code> loop.</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ... definitions for S, T, globI, globD ...</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> S *someSes, <span class="built_in">std</span>::<span class="keyword">size_t</span> count)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> S *<span class="built_in">end</span> = someSes + count; someSes != <span class="built_in">end</span>; ++someSes) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; someSes-&gt;i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  T test[<span class="number">5</span>];</span><br><span class="line">  f(test, <span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="不合规的代码示例-数组下标操作-Noncompliant-Code-Example-Array-Subscripting"><a class="header-anchor" href="#不合规的代码示例-数组下标操作-Noncompliant-Code-Example-Array-Subscripting">¶</a>不合规的代码示例 (数组下标操作) Noncompliant Code Example (Array Subscripting)</h2><p>在这个不合规的代码示例中，<code>for</code> 循环使用了数组下标操作。因为数组下标操作使用了指针运算，这份代码也导致未定义行为。</p><p>In this noncompliant code example, the <code>for</code> loop uses array subscripting. Since array subscripts are computed using pointer arithmetic, this code also results in undefined behavior.</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ... definitions for S, T, globI, globD ...</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> S *someSes, <span class="built_in">std</span>::<span class="keyword">size_t</span> count)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; someSes[i].i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  T test[<span class="number">5</span>];</span><br><span class="line">  f(test, <span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="合规方案-数组-Compliant-Solution-Array"><a class="header-anchor" href="#合规方案-数组-Compliant-Solution-Array">¶</a>合规方案 (数组) Compliant Solution (Array)</h2><p>替换具有对象数组，指针数组解决了不同对象大小不同的问题，如这个合规方案。</p><p>Instead of having an array of objects, an array of pointers solves the problem of the objects being of different sizes, as in this compliant solution.</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ... definitions for S, T, globI, globD ...</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> S * <span class="keyword">const</span> *someSes, <span class="built_in">std</span>::<span class="keyword">size_t</span> count)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> S * <span class="keyword">const</span> *<span class="built_in">end</span> = someSes + count; someSes != <span class="built_in">end</span>; ++someSes) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; (*someSes)-&gt;i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  S *test[] = &#123;<span class="keyword">new</span> T, <span class="keyword">new</span> T, <span class="keyword">new</span> T, <span class="keyword">new</span> T, <span class="keyword">new</span> T&#125;;</span><br><span class="line">  f(test, <span class="number">5</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> v : test) &#123;</span><br><span class="line">    <span class="keyword">delete</span> v;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数组里面的元素不在是多态对象 (而是指向多态对象的指针)。所以这里的指针运算不会有 <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-undefinedbehavior" target="_blank" rel="noopener">undefined behavior</a>。</p><p>The elements in the arrays are no longer polymorphic objects (instead, they are pointers to polymorphic objects), and so there is no <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-undefinedbehavior" target="_blank" rel="noopener">undefined behavior</a> with the pointer arithmetic.</p><h2 id="合规方案-std-vector-Compliant-Solution-std-vector"><a class="header-anchor" href="#合规方案-std-vector-Compliant-Solution-std-vector">¶</a>合规方案 (<code>std::vector</code>) Compliant Solution (<code>std::vector</code>)</h2><p>另外一种方法是使用标准模板库 (STL) 容器来替换数组。并且该方法的 <code>f()</code> 接收迭代器作为形参，如该合规方案。然而，因为 STL 容器需要同构元素，因此容器内依然需要指针。</p><p>Another approach is to use a standard template library (STL) container instead of an array and have <code>f()</code> accept iterators as parameters, as in this compliant solution. However, because STL containers require homogeneous elements, pointers are still required within the container.</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ... definitions for S, T, globI, globD ...</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(Iter i, Iter e)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (; i != e; ++i) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; (*i)-&gt;i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;S *&gt; test&#123;<span class="keyword">new</span> T, <span class="keyword">new</span> T, <span class="keyword">new</span> T, <span class="keyword">new</span> T, <span class="keyword">new</span> T&#125;;</span><br><span class="line">  f(test.cbegin(), test.cend());</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> v : test) &#123;</span><br><span class="line">    <span class="keyword">delete</span> v;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="风险指针-Risk-Assessment"><a class="header-anchor" href="#风险指针-Risk-Assessment">¶</a>风险指针 Risk Assessment</h2><p>使用多态类型地数组会造成内存崩溃，这会导致攻击者能够执行任意代码。</p><p>Using arrays polymorphically can result in memory corruption, which could lead to an attacker being able to execute arbitrary code.</p><table><thead><tr><th style="text-align:left">Rule</th><th style="text-align:left">Severity</th><th style="text-align:left">Likelihood</th><th style="text-align:left">Remediation Cost</th><th style="text-align:left">Priority</th><th style="text-align:left">Level</th></tr></thead><tbody><tr><td style="text-align:left">CTR56-CPP</td><td style="text-align:left">High</td><td style="text-align:left">Likely</td><td style="text-align:left">High</td><td style="text-align:left"><strong>P9</strong></td><td style="text-align:left"><strong>L2</strong></td></tr></tbody></table><h2 id="Automated-Detection"><a class="header-anchor" href="#Automated-Detection">¶</a>Automated Detection</h2><table><thead><tr><th style="text-align:left">Tool</th><th style="text-align:left">Version</th><th style="text-align:left">Checker</th><th style="text-align:left">Description</th></tr></thead><tbody><tr><td style="text-align:left"><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/Axivion+Bauhaus+Suite" target="_blank" rel="noopener">Axivion Bauhaus Suite</a></td><td style="text-align:left"><img data-src="https://wiki.sei.cmu.edu/confluence/plugins/servlet/confluence/placeholder/macro?definition=e2luY2x1ZGU6QXhpdmlvbiBCYXVoYXVzIFN1aXRlX1Z9&amp;locale=zh_CN&amp;version=2" alt="img"></td><td style="text-align:left"><strong>CertC+±CTR56</strong></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/Parasoft" target="_blank" rel="noopener">Parasoft C/C++test</a></td><td style="text-align:left"><img data-src="https://wiki.sei.cmu.edu/confluence/plugins/servlet/confluence/placeholder/macro?definition=e2luY2x1ZGU6UGFyYXNvZnRfVn0&amp;locale=zh_CN&amp;version=2" alt="img"></td><td style="text-align:left"><strong>CERT_CPP-CTR56-a</strong> <strong>CERT_CPP-CTR56-b</strong> <strong>CERT_CPP-CTR56-c</strong></td><td style="text-align:left">Don’t treat arrays polymorphically A pointer to an array of derived class objects should not be converted to a base class pointer Do not treat arrays polymorphically</td></tr><tr><td style="text-align:left"><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/LDRA" target="_blank" rel="noopener">LDRA tool suite</a></td><td style="text-align:left"><img data-src="https://wiki.sei.cmu.edu/confluence/plugins/servlet/confluence/placeholder/macro?definition=e2luY2x1ZGU6TERSQV9WfQ&amp;locale=zh_CN&amp;version=2" alt="img"></td><td style="text-align:left"><strong>567 S**</strong> **</td><td style="text-align:left">Enhanced Enforcement</td></tr><tr><td style="text-align:left"><a href="https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=88046345" target="_blank" rel="noopener">PRQA QA-C++</a></td><td style="text-align:left"><img data-src="https://wiki.sei.cmu.edu/confluence/plugins/servlet/confluence/placeholder/macro?definition=e2luY2x1ZGU6UFJRQSBRQS1DKytfVn0&amp;locale=zh_CN&amp;version=2" alt="img"></td><td style="text-align:left"><strong>3073</strong></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/PVS-Studio" target="_blank" rel="noopener">PVS-Studio</a></td><td style="text-align:left"><img data-src="https://wiki.sei.cmu.edu/confluence/plugins/servlet/confluence/placeholder/macro?definition=e2luY2x1ZGU6UFZTLVN0dWRpb19WfQ&amp;locale=zh_CN&amp;version=2" alt="img"></td><td style="text-align:left"><strong><a href="https://www.viva64.com/en/w/v777/" target="_blank" rel="noopener">V777</a></strong></td><td style="text-align:left"></td></tr></tbody></table><h2 id="Related-Vulnerabilities"><a class="header-anchor" href="#Related-Vulnerabilities">¶</a>Related Vulnerabilities</h2><p>Search for <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-vulnerabil" target="_blank" rel="noopener">vulnerabilities</a> resulting from the violation of this rule on the <a href="https://www.kb.cert.org/vulnotes/bymetric?searchview&amp;query=FIELD+KEYWORDS+contains+CTR39-CPP" target="_blank" rel="noopener">CERT website</a>.</p><h2 id="Related-Guidelines"><a class="header-anchor" href="#Related-Guidelines">¶</a>Related Guidelines</h2><table><thead><tr><th><a href="https://wiki.sei.cmu.edu/confluence/display/c/SEI+CERT+C+Coding+Standard" target="_blank" rel="noopener">SEI CERT C Coding Standard</a></th><th><a href="https://wiki.sei.cmu.edu/confluence/display/c/ARR39-C.+Do+not+add+or+subtract+a+scaled+integer+to+a+pointer" target="_blank" rel="noopener">ARR39-C. Do not add or subtract a scaled integer to a pointer</a></th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><h2 id="Bibliography"><a class="header-anchor" href="#Bibliography">¶</a>Bibliography</h2><table><thead><tr><th>[<a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-ISO/IEC14882-2014" target="_blank" rel="noopener">ISO/IEC 14882-2014</a>]</th><th>Subclause 5.7, “Additive Operators” Subclause 5.2.1, “Subscripting”</th></tr></thead><tbody><tr><td>[<a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-LockheedMartin05" target="_blank" rel="noopener">Lockheed Martin 2005</a>]</td><td>AV Rule 96, “Arrays shall not be treated polymorphically”</td></tr><tr><td>[<a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-Meyers96" target="_blank" rel="noopener">Meyers 1996</a>]</td><td>Item 3, “Never Treat Arrays Polymorphically”</td></tr><tr><td>[<a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-Stroustrup06" target="_blank" rel="noopener">Stroustrup 2006</a>]</td><td>“What’s Wrong with Arrays?”</td></tr><tr><td>[<a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-Sutter04" target="_blank" rel="noopener">Sutter 2004</a>]</td><td>Item 100, “Don’t Treat Arrays Polymorphically”</td></tr></tbody></table><hr><p><a href="https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=88046720" target="_blank" rel="noopener"><img data-src="https://wiki.sei.cmu.edu/confluence/download/attachments/88046682/button_arrow_left.png?version=1&amp;modificationDate=1216910800000&amp;api=v2" alt="SEI CERT C++ Coding Standard &gt; SEI CERT C++ Coding Standard &gt; button_arrow_left.png"></a><a href="https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=88046331" target="_blank" rel="noopener"><img data-src="https://wiki.sei.cmu.edu/confluence/download/attachments/88046682/button_arrow_up.png?version=1&amp;modificationDate=1216910618000&amp;api=v2" alt="SEI CERT C++ Coding Standard &gt; SEI CERT C++ Coding Standard &gt; button_arrow_up.png"></a><a href="https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=88046458" target="_blank" rel="noopener"><img data-src="https://wiki.sei.cmu.edu/confluence/download/attachments/88046682/button_arrow_right.png?version=1&amp;modificationDate=1216910815000&amp;api=v2" alt="SEI CERT C++ Coding Standard &gt; SEI CERT C++ Coding Standard &gt; button_arrow_right.png"></a></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>SEI CERT C++</category>
      </categories>
      <tags>
        <tag>SEI CERT C++</tag>
        <tag>编码规范</tag>
        <tag>翻译</tag>
        <tag>CERT Containers</tag>
      </tags>
  </entry>
  <entry>
    <title>CTR55-CPP. 不要使用对迭代器使用加法运算如果结果会溢出</title>
    <url>/posts/3996505531/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><!-- build time:Sat Nov 13 2021 15:45:21 GMT+0000 (Coordinated Universal Time) --><p>原文链接：</p><p><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/CTR55-CPP.+Do+not+use+an+additive+operator+on+an+iterator+if+the+result+would+overflow" target="_blank" rel="noopener">CTR55-CPP. Do not use an additive operator on an iterator if the result would overflow</a></p><p><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/CTR55-CPP.+Do+not+use+an+additive+operator+on+an+iterator+if+the+result+would+overflow" target="_blank" rel="noopener">https://wiki.sei.cmu.edu/confluence/display/cplusplus/CTR55-CPP.+Do+not+use+an+additive+operator+on+an+iterator+if+the+result+would+overflow</a></p><a id="more"></a><p>具有整型的表达式可以与指针相加或相减，结果是指针类型的值。如果结果指针不是一个有效的容器成员，或者在容器最后一个元素之后，加法运算的行为将是 <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-undefinedbehavior" target="_blank" rel="noopener">未定义的</a>. C++ 标准, [expr.add], paragraph 5 [<a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-ISO/IEC14882-2014" target="_blank" rel="noopener">ISO/IEC 14882-2014</a>]，部分陈述如下：</p><p>Expressions that have an integral type can be added to or subtracted from a pointer, resulting in a value of the pointer type. If the resulting pointer is not a valid member of the container, or one past the last element of the container, the behavior of the additive operator is <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-undefinedbehavior" target="_blank" rel="noopener">undefined</a>. The C++ Standard, [expr.add], paragraph 5 [<a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-ISO/IEC14882-2014" target="_blank" rel="noopener">ISO/IEC 14882-2014</a>], in part, states the following:</p><blockquote><p>If both the pointer operand and the result point to elements of the same array object, or one past the last element of the array object, the evaluation shall not produce an overflow; otherwise, the behavior is undefined.</p></blockquote><p>因为迭代器是一个泛化的指针，同样的限制也会被施加在和任随机访问迭代器的加法运算上。特别地，C++ 标准， [iterator.requirements.general], paragraph 5, 陈述如下：</p><p>Because iterators are a generalization of pointers, the same constraints apply to additive operators with random access iterators. Specifically, the C++ Standard, [iterator.requirements.general], paragraph 5, states the following:</p><blockquote><p>Just as a regular pointer to an array guarantees that there is a pointer value pointing past the last element of the array, so for any iterator type there is an iterator value that points past the last element of a corresponding sequence. These values are called <em>past-the-end</em> values. Values of an iterator <code>i</code> for which the expression <code>*i</code> is defined are called <em>dereferenceable</em>. The library never assumes that past-the-end values are dereferenceable.</p></blockquote><p>当运算结果会溢出容器范围时，不允许一个整型地表达式和指针或者随机访问迭代器相加或者相减。</p><p>Do not allow an expression of integral type to add to or subtract from a pointer or random access iterator when the resulting value would overflow the bounds of the container.</p><h2 id="不合规的代码示例-std-vector-Noncompliant-Code-Example-std-vector"><a class="header-anchor" href="#不合规的代码示例-std-vector-Noncompliant-Code-Example-std-vector">¶</a>不合规的代码示例 (<code>std::vector</code>) Noncompliant Code Example (<code>std::vector</code>)</h2><p>在这个不合规的代码示例中，一个来自 <code>std::vector</code> 的随机访问迭代器被用在一个加法表达式中，但是结果将在容器范围之外，而不是一个尾后值。</p><p>In this noncompliant code example, a random access iterator from a <code>std::vector</code> is used in an additive expression, but the resulting value could be outside the bounds of the container rather than a past-the-end value.</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;c)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> i = c.<span class="built_in">begin</span>(), e = i + <span class="number">20</span>; i != e; ++i) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="合规方案-std-vector-Compliant-Solution-std-vector"><a class="header-anchor" href="#合规方案-std-vector-Compliant-Solution-std-vector">¶</a>合规方案 (<code>std::vector</code>) Compliant Solution (<code>std::vector</code>)</h2><p>这个合规方案假设程序员的意图是处理容器中最多 20 项。和假设所有容器有 20 项或者更多元素不同的是，在加法中，容器的尺寸被用来决定容器的上限。</p><p>This compliant solution assumes that the programmer’s intention was to process up to 20 items in the container. Instead of assuming all containers will have 20 or more elements, the size of the container is used to determine the upper bound on the addition.</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;c)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::size_type maxSize = <span class="number">20</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> i = c.<span class="built_in">begin</span>(), e = i + <span class="built_in">std</span>::<span class="built_in">min</span>(maxSize, c.<span class="built_in">size</span>()); i != e; ++i) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="风险评估-Risk-Assessment"><a class="header-anchor" href="#风险评估-Risk-Assessment">¶</a>风险评估 Risk Assessment</h2><p>如果在指针上加上或者减去一个整数造成一个元素的引用在数组之外或者数组对象的最后一个元素之后，这种行为是 <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-undefinedbehavior" target="_blank" rel="noopener">undefined</a> ，但是经常造成缓冲器溢出或者缓冲器欠载运行，这经常被<a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-exploit" target="_blank" rel="noopener">exploited</a> 运行任意代码。迭代器和标准模板库容器展现出与指针和数组一样的行为和警告。</p><p>If adding or subtracting an integer to a pointer results in a reference to an element outside the array or one past the last element of the array object, the behavior is <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-undefinedbehavior" target="_blank" rel="noopener">undefined</a> but frequently leads to a buffer overflow or buffer underrun, which can often be <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-exploit" target="_blank" rel="noopener">exploited</a> to run arbitrary code. Iterators and standard template library containers exhibit the same behavior and caveats as pointers and arrays.</p><table><thead><tr><th style="text-align:left">Rule</th><th style="text-align:left">Severity</th><th style="text-align:left">Likelihood</th><th style="text-align:left">Remediation Cost</th><th style="text-align:left">Priority</th><th style="text-align:left">Level</th></tr></thead><tbody><tr><td style="text-align:left">CTR55-CPP</td><td style="text-align:left">High</td><td style="text-align:left">Likely</td><td style="text-align:left">Medium</td><td style="text-align:left"><strong>P18</strong></td><td style="text-align:left"><strong>L1</strong></td></tr></tbody></table><h2 id="Automated-Detection"><a class="header-anchor" href="#Automated-Detection">¶</a>Automated Detection</h2><table><thead><tr><th style="text-align:left">Tool</th><th style="text-align:left">Version</th><th style="text-align:left">Checker</th><th style="text-align:left">Description</th></tr></thead><tbody><tr><td style="text-align:left"><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/LDRA" target="_blank" rel="noopener">LDRA tool suite</a></td><td style="text-align:left"><img data-src="https://wiki.sei.cmu.edu/confluence/plugins/servlet/confluence/placeholder/macro?definition=e2luY2x1ZGU6TERSQV9WfQ&amp;locale=zh_CN&amp;version=2" alt="img"></td><td style="text-align:left"><strong>567 S**</strong> **</td><td style="text-align:left">Enhanced Enforcement</td></tr><tr><td style="text-align:left"><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/Parasoft" target="_blank" rel="noopener">Parasoft C/C++test</a></td><td style="text-align:left"><img data-src="https://wiki.sei.cmu.edu/confluence/plugins/servlet/confluence/placeholder/macro?definition=e2luY2x1ZGU6UGFyYXNvZnRfVn0&amp;locale=zh_CN&amp;version=2" alt="img"></td><td style="text-align:left"><strong>CERT_CPP-CTR55-a</strong></td><td style="text-align:left">Do not add or subtract a constant with a value greater than one from an iterator</td></tr></tbody></table><h2 id="Related-Vulnerabilities"><a class="header-anchor" href="#Related-Vulnerabilities">¶</a>Related Vulnerabilities</h2><p>Search for <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-vulnerability" target="_blank" rel="noopener">vulnerabilities</a> resulting from the violation of this rule on the <a href="https://www.kb.cert.org/vulnotes/bymetric?searchview&amp;query=FIELD+KEYWORDS+contains+CTR38-CPP" target="_blank" rel="noopener">CERT website</a>.</p><h2 id="Related-Guidelines"><a class="header-anchor" href="#Related-Guidelines">¶</a>Related Guidelines</h2><table><thead><tr><th><a href="https://wiki.sei.cmu.edu/confluence/display/c/SEI+CERT+C+Coding+Standard" target="_blank" rel="noopener">SEI CERT C Coding Standard</a></th><th><a href="https://wiki.sei.cmu.edu/confluence/display/c/ARR30-C.+Do+not+form+or+use+out-of-bounds+pointers+or+array+subscripts" target="_blank" rel="noopener">ARR30-C. Do not form or use out-of-bounds pointers or array subscripts</a></th></tr></thead><tbody><tr><td><a href="http://cwe.mitre.org/" target="_blank" rel="noopener">MITRE CWE</a></td><td><a href="http://cwe.mitre.org/data/definitions/129.html" target="_blank" rel="noopener">CWE 129</a>, Unchecked Array Indexing</td></tr></tbody></table><h2 id="Bibliography"><a class="header-anchor" href="#Bibliography">¶</a>Bibliography</h2><table><thead><tr><th>[<a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-Banahan03" target="_blank" rel="noopener">Banahan 2003</a>]</th><th>Section 5.3, “Pointers” Section 5.7, “Expressions Involving Pointers”</th></tr></thead><tbody><tr><td>[<a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-ISO/IEC14882-2014" target="_blank" rel="noopener">ISO/IEC 14882-2014</a>]</td><td>Subclause 5.7, “Additive Operators” Subclause 24.2.1, “In General”</td></tr><tr><td>[<a href="https://wiki.sei.cmu.edu/confluence/display/c/AA.+Bibliography#AA.Bibliography-VU#162289" target="_blank" rel="noopener">VU#162289</a>]</td><td></td></tr></tbody></table><hr><p><a href="https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=88046693" target="_blank" rel="noopener"><img data-src="https://wiki.sei.cmu.edu/confluence/download/attachments/88046682/button_arrow_left.png?version=1&amp;modificationDate=1216910800000&amp;api=v2" alt="SEI CERT C++ Coding Standard &gt; SEI CERT C++ Coding Standard &gt; button_arrow_left.png"></a><a href="https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=88046331" target="_blank" rel="noopener"><img data-src="https://wiki.sei.cmu.edu/confluence/download/attachments/88046682/button_arrow_up.png?version=1&amp;modificationDate=1216910618000&amp;api=v2" alt="SEI CERT C++ Coding Standard &gt; SEI CERT C++ Coding Standard &gt; button_arrow_up.png"></a><a href="https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=88046755" target="_blank" rel="noopener"><img data-src="https://wiki.sei.cmu.edu/confluence/download/attachments/88046682/button_arrow_right.png?version=1&amp;modificationDate=1216910815000&amp;api=v2" alt="SEI CERT C++ Coding Standard &gt; SEI CERT C++ Coding Standard &gt; button_arrow_right.png"></a></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>SEI CERT C++</category>
      </categories>
      <tags>
        <tag>SEI CERT C++</tag>
        <tag>编码规范</tag>
        <tag>翻译</tag>
        <tag>CERT Containers</tag>
      </tags>
  </entry>
  <entry>
    <title>CTR54-CPP. 不要相减不是指向同一个容器的迭代器</title>
    <url>/posts/2683327602/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><!-- build time:Sat Nov 13 2021 15:45:21 GMT+0000 (Coordinated Universal Time) --><p>原文链接：</p><p><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/CTR54-CPP.+Do+not+subtract+iterators+that+do+not+refer+to+the+same+container" target="_blank" rel="noopener">CTR54-CPP. Do not subtract iterators that do not refer to the same container</a></p><p><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/CTR54-CPP.+Do+not+subtract+iterators+that+do+not+refer+to+the+same+container" target="_blank" rel="noopener">https://wiki.sei.cmu.edu/confluence/display/cplusplus/CTR54-CPP.+Do+not+subtract+iterators+that+do+not+refer+to+the+same+container</a></p><a id="more"></a><p>当两个指针相减，两个指针必须指向同一个数组对象的元素或者指向数组对象最后一个元素之后；结果就是两个数组元素下标的差值。类似地，当两个迭代器相减时 (包括通过 <code>std::distance()</code>)，两个迭代器必须指向相同的容器对象或者必须通过在同一个迭代器对象调用 <code>end()</code> 获得 (或者 <code>cend()</code>)。</p><p>如果两个无关的迭代器 (包括指针) 相减，该操作导致<a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-undefinedbehavior" target="_blank" rel="noopener">undefined behavior</a> [<a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-ISO/IEC14882-2014" target="_blank" rel="noopener">ISO/IEC 14882-2014</a>]。不要相减两个迭代器 (包括指针) ，除非两个指向同一个迭代器或者其中一个迭代器超过容器的尾部。</p><p>When two pointers are subtracted, both must point to elements of the same array object or to one past the last element of the array object; the result is the difference of the subscripts of the two array elements. Similarly, when two iterators are subtracted (including via <code>std::distance()</code>), both iterators must refer to the same container object or must be obtained via a call to <code>end()</code> (or <code>cend()</code>) on the same container object.</p><p>If two unrelated iterators (including pointers) are subtracted, the operation results in <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-undefinedbehavior" target="_blank" rel="noopener">undefined behavior</a> [<a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-ISO/IEC14882-2014" target="_blank" rel="noopener">ISO/IEC 14882-2014</a>]. Do not subtract two iterators (including pointers) unless both point into the same container or one past the end of the same container.</p><h2 id="不合规的代码示例-Noncompliant-Code-Example"><a class="header-anchor" href="#不合规的代码示例-Noncompliant-Code-Example">¶</a>不合规的代码示例 Noncompliant Code Example</h2><p>这个不合规的代码示例试图判断指针 <code>test</code> 是否在范围<code>[r, r + n]</code> 内。然而，当 <code>test</code> 不指向给定的范围内，像在这个例子中，相减将产生未定义行为。</p><p>This noncompliant code example attempts to determine whether the pointer <code>test</code> is within the range <code>[r, r + n]</code>. However, when <code>test</code> does not point within the given range, as in this example, the subtraction produces undefined behavior.</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstddef&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Ty&gt;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">in_range</span><span class="params">(<span class="keyword">const</span> Ty *test, <span class="keyword">const</span> Ty *r, <span class="keyword">size_t</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span> &lt; (test - r) &amp;&amp; (test - r) &lt; (<span class="built_in">std</span>::<span class="keyword">ptrdiff_t</span>)n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">double</span> foo[<span class="number">10</span>];</span><br><span class="line">  <span class="keyword">double</span> *x = &amp;foo[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">double</span> bar;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::boolalpha &lt;&lt; in_range(&amp;bar, x, <span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="不合规的代码示例-Noncompliant-Code-Example-v2"><a class="header-anchor" href="#不合规的代码示例-Noncompliant-Code-Example-v2">¶</a>不合规的代码示例 Noncompliant Code Example</h2><p>在这个不合规的代码示例中，<code>in_range()</code> 函数通过使用比较函数代替减法来实现。C++ 标准， [expr.rel], paragraph 4 [<a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-ISO/IEC14882-2014" target="_blank" rel="noopener">ISO/IEC 14882-2014</a>], 陈述如下:</p><p>In this noncompliant code example, the <code>in_range()</code> function is implemented using a comparison expression instead of subtraction. The C++ Standard, [expr.rel], paragraph 4 [<a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-ISO/IEC14882-2014" target="_blank" rel="noopener">ISO/IEC 14882-2014</a>], states the following:</p><blockquote><p>If two operands <code>p</code> and <code>q</code> compare equal, <code>p&lt;=q</code> and <code>p&gt;=q</code> both yield <code>true</code> and <code>p&lt;q</code> and <code>p&gt;q</code> both yield <code>false</code>. Otherwise, if a pointer <code>p</code> compares greater than a pointer <code>q</code>, <code>p&gt;=q</code>, <code>p&gt;q</code>, <code>q&lt;=p</code>, and <code>q&lt;p</code> all yield <code>true</code> and <code>p&lt;=q</code>, <code>p&lt;q</code>, <code>q&gt;=p</code>, and <code>q&gt;p</code> all yield <code>false</code>. Otherwise, the result of each of the operators is unspecified.</p></blockquote><p>因此，比较两个不是指向同一个容器的指针或者其中之一超出容器之后将造成 <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-unspecifiedbehavior" target="_blank" rel="noopener">unspecified behavior</a>。虽然下面的例子是先前不合规代码示例的提升，但是它不会产生可移植代码并且在分段内存架构 (例如一些果实的 x86 变体) 机器上执行是可能失败。所以，这是不合规的。</p><p>Thus, comparing two pointers that do not point into the same container or one past the end of the container results in <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-unspecifiedbehavior" target="_blank" rel="noopener">unspecified behavior</a>. Although the following example is an improvement over the previous noncompliant code example, it does not result in portable code and may fail when executed on a segmented memory architecture (such as some antiquated x86 variants). Consequently, it is noncompliant.</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Ty&gt;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">in_range</span><span class="params">(<span class="keyword">const</span> Ty *test, <span class="keyword">const</span> Ty *r, <span class="keyword">size_t</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> test &gt;= r &amp;&amp; test &lt; (r + n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">double</span> foo[<span class="number">10</span>];</span><br><span class="line">  <span class="keyword">double</span> *x = &amp;foo[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">double</span> bar;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::boolalpha &lt;&lt; in_range(&amp;bar, x, <span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="不合规的代码示例-Noncompliant-Code-Example-v3"><a class="header-anchor" href="#不合规的代码示例-Noncompliant-Code-Example-v3">¶</a>不合规的代码示例 Noncompliant Code Example</h2><p>这个不合规的代码示例和先前的示例大致相同，只是它是使用迭代器来替换原始指针。和先前的例子一样， <code>in_range_impl()</code> 函数呈现了 <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-unspecifiedbehavior" target="_blank" rel="noopener">unspecified behavior</a> ，当迭代器没有指向同一个容器，因为操作语义 <code>a &lt; b</code> 对于随机访问的迭代器是 <code>b - a &gt; 0</code>，并且<code>&gt;=</code> 是由 <code>&lt;</code> 实现的.</p><p>This noncompliant code example is roughly equivalent to the previous example, except that it uses iterators in place of raw pointers. As with the previous example, the <code>in_range_impl()</code> function exhibits <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-unspecifiedbehavior" target="_blank" rel="noopener">unspecified behavior</a> when the iterators do not refer into the same container because the operational semantics of <code>a &lt; b</code> on a random access iterator are <code>b - a &gt; 0</code>, and <code>&gt;=</code> is implemented in terms of <code>&lt;</code>.</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RandIter&gt;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">in_range_impl</span><span class="params">(RandIter test, RandIter r_begin, RandIter r_end, <span class="built_in">std</span>::random_access_iterator_tag)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> test &gt;= r_begin &amp;&amp; test &lt; r_end;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter&gt;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">in_range</span><span class="params">(Iter test, Iter r_begin, Iter r_end)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;Iter&gt;::iterator_category cat;</span><br><span class="line">  <span class="keyword">return</span> in_range_impl(test, r_begin, r_end, cat);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">foo</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">bar</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::boolalpha &lt;&lt; in_range(bar.<span class="built_in">begin</span>(), foo.<span class="built_in">begin</span>(), foo.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="不合规的代码示例-Noncompliant-Code-Example-v4"><a class="header-anchor" href="#不合规的代码示例-Noncompliant-Code-Example-v4">¶</a>不合规的代码示例 Noncompliant Code Example</h2><p>在这个不合规的代码示例中，<code>std::less&lt;&gt;</code> 用来替换 <code>&lt;</code> 操作。C++ 标准 [comparisons], paragraph 14 [<a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-ISO/IEC14882-2014" target="_blank" rel="noopener">ISO/IEC 14882-2014</a>]，陈述如下：</p><p>In this noncompliant code example, <code>std::less&lt;&gt;</code> is used in place of the <code>&lt;</code> operator. The C++ Standard, [comparisons], paragraph 14 [<a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-ISO/IEC14882-2014" target="_blank" rel="noopener">ISO/IEC 14882-2014</a>], states the following:</p><blockquote><p>For templates <code>greater</code>, <code>less</code>, <code>greater_equal</code>, and <code>less_equal</code>, the specializations for any pointer type yield a total order, even if the built-in operators <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code> do not.</p></blockquote><p>虽然这个方式生成了全序，但是这个全序的定义根据实现依然不是特定的。举个例子，下述对于给定的，无关的指针， <code>a</code> 和 <code>b</code> 会导致触发断言：<code>assert(std::less&lt;T *&gt;()(a, b) == std::greater&lt;T *&gt;()(a, b));</code>。因此，这个不合规的代码例子依然是不可移植的，并且对于 <code>std::less&lt;&gt;</code> 一般的实现，当调用 <code>&lt;</code> 运算符时，可能甚至导致 <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-undefinedbehavior" target="_blank" rel="noopener">undefined behavior</a> 。</p><p>Although this approach yields a total ordering, the definition of that total ordering is still unspecified by the <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions" target="_blank" rel="noopener">implementation</a>. For instance, the following statement could result in the assertion triggering for a given, unrelated pair of pointers, <code>a</code> and <code>b</code>: <code>assert(std::less&lt;T *&gt;()(a, b) == std::greater&lt;T *&gt;()(a, b));</code>. Consequently, this noncompliant code example is still nonportable and, on common implementations of <code>std::less&lt;&gt;</code>, may even result in <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-undefinedbehavior" target="_blank" rel="noopener">undefined behavior</a> when the <code>&lt;</code> operator is invoked.</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Ty&gt;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">in_range</span><span class="params">(<span class="keyword">const</span> Ty *test, <span class="keyword">const</span> Ty *r, <span class="keyword">size_t</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::less&lt;<span class="keyword">const</span> Ty *&gt; less;</span><br><span class="line">  <span class="keyword">return</span> !less(test, r) &amp;&amp; less(test, r + n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">double</span> foo[<span class="number">10</span>];</span><br><span class="line">  <span class="keyword">double</span> *x = &amp;foo[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">double</span> bar;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::boolalpha &lt;&lt; in_range(&amp;bar, x, <span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="合规的方案-Compliant-Solution"><a class="header-anchor" href="#合规的方案-Compliant-Solution">¶</a>合规的方案 Compliant Solution</h2><p>这个合规的方案呈现了一个完全可移植的，但是或许低效的 <code>in_range()</code> 的实现，通过比较 <code>test</code> 和范围 <code>[r, n]</code> 内每个可能的地址。一个兼顾效率和完全可移植的合规方案目前未知。</p><p>This compliant solution demonstrates a fully portable, but likely inefficient, implementation of <code>in_range()</code> that compares <code>test</code> against each possible address in the range <code>[r, n]</code>. A compliant solution that is both efficient and fully portable is currently unknown.</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Ty&gt;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">in_range</span><span class="params">(<span class="keyword">const</span> Ty *test, <span class="keyword">const</span> Ty *r, <span class="keyword">size_t</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> *cur = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *&gt;(r);</span><br><span class="line">  <span class="keyword">auto</span> *<span class="built_in">end</span> = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *&gt;(r + n);</span><br><span class="line">  <span class="keyword">auto</span> *testPtr = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *&gt;(test);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (; cur != <span class="built_in">end</span>; ++cur) &#123;</span><br><span class="line">    <span class="keyword">if</span> (cur == testPtr) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">double</span> foo[<span class="number">10</span>];</span><br><span class="line">  <span class="keyword">double</span> *x = &amp;foo[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">double</span> bar;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::boolalpha &lt;&lt; in_range(&amp;bar, x, <span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="风险预估-Risk-Assessment"><a class="header-anchor" href="#风险预估-Risk-Assessment">¶</a>风险预估 Risk Assessment</h2><table><thead><tr><th style="text-align:left">Rule</th><th style="text-align:left">Severity</th><th style="text-align:left">Likelihood</th><th style="text-align:left">Remediation Cost</th><th style="text-align:left">Priority</th><th style="text-align:left">Level</th></tr></thead><tbody><tr><td style="text-align:left">CTR54-CPP</td><td style="text-align:left">Medium</td><td style="text-align:left">Probable</td><td style="text-align:left">Medium</td><td style="text-align:left"><strong>P8</strong></td><td style="text-align:left"><strong>L2</strong></td></tr></tbody></table><h3 id="Automated-Detection"><a class="header-anchor" href="#Automated-Detection">¶</a>Automated Detection</h3><table><thead><tr><th style="text-align:left">Tool</th><th style="text-align:left">Version</th><th style="text-align:left">Checker</th><th style="text-align:left">Description</th></tr></thead><tbody><tr><td style="text-align:left"><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/LDRA" target="_blank" rel="noopener">LDRA tool suite</a></td><td style="text-align:left"><img data-src="https://wiki.sei.cmu.edu/confluence/plugins/servlet/confluence/placeholder/macro?definition=e2luY2x1ZGU6TERSQV9WfQ&amp;locale=zh_CN&amp;version=2" alt="img"></td><td style="text-align:left"><strong>70 S, 87 S, 437 S, 438 S**</strong> **</td><td style="text-align:left">Enhanced Enforcement</td></tr><tr><td style="text-align:left"><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/Parasoft" target="_blank" rel="noopener">Parasoft C/C++test</a></td><td style="text-align:left"><img data-src="https://wiki.sei.cmu.edu/confluence/plugins/servlet/confluence/placeholder/macro?definition=e2luY2x1ZGU6UGFyYXNvZnRfVn0&amp;locale=zh_CN&amp;version=2" alt="img"></td><td style="text-align:left"><strong>CERT_CPP-CTR54-a</strong> <strong>CERT_CPP-CTR54-b</strong></td><td style="text-align:left">Do not compare iterators from different containers Do not compare two unrelated pointers</td></tr><tr><td style="text-align:left"><a href="https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=88046345" target="_blank" rel="noopener">PRQA QA-C++</a></td><td style="text-align:left"><img data-src="https://wiki.sei.cmu.edu/confluence/plugins/servlet/confluence/placeholder/macro?definition=e2luY2x1ZGU6UFJRQSBRQS1DKytfVn0&amp;locale=zh_CN&amp;version=2" alt="img"></td><td style="text-align:left"><strong>2668, 2761, 2762, 2763, 2766, 2767, 2768</strong></td><td style="text-align:left">Enforced by QA-CPP</td></tr></tbody></table><h3 id="Related-Vulnerabilities"><a class="header-anchor" href="#Related-Vulnerabilities">¶</a>Related Vulnerabilities</h3><p>Search for <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-vulnerabi" target="_blank" rel="noopener">vulnerabilities</a> resulting from the violation of this rule on the <a href="https://www.kb.cert.org/vulnotes/bymetric?searchview&amp;query=FIELD+KEYWORDS+contains+CTR36-CPP" target="_blank" rel="noopener">CERT website</a>.</p><h2 id="Related-Guidelines"><a class="header-anchor" href="#Related-Guidelines">¶</a>Related Guidelines</h2><table><thead><tr><th><a href="https://wiki.sei.cmu.edu/confluence/display/c/SEI+CERT+C+Coding+Standard" target="_blank" rel="noopener">SEI CERT C Coding Standard</a></th><th><a href="https://wiki.sei.cmu.edu/confluence/display/c/ARR36-C.+Do+not+subtract+or+compare+two+pointers+that+do+not+refer+to+the+same+array" target="_blank" rel="noopener">ARR36-C. Do not subtract or compare two pointers that do not refer to the same array</a></th></tr></thead><tbody><tr><td><a href="http://cwe.mitre.org/" target="_blank" rel="noopener">MITRE CWE</a></td><td><a href="http://cwe.mitre.org/data/definitions/469.html" target="_blank" rel="noopener">CWE-469</a>, Use of Pointer Subtraction to Determine Size</td></tr></tbody></table><h2 id="Bibliography"><a class="header-anchor" href="#Bibliography">¶</a>Bibliography</h2><table><thead><tr><th>[<a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-Banahan03" target="_blank" rel="noopener">Banahan 2003</a>]</th><th>Section 5.3, “Pointers” Section 5.7, “Expressions Involving Pointers”</th></tr></thead><tbody><tr><td>[<a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-ISO/IEC14882-2014" target="_blank" rel="noopener">ISO/IEC 14882-2014</a>]</td><td>Subclause 5.7, “Additive Operators” Subclause 5.9, “Relational Operators” Subclause 20.9.5, “Comparisons”</td></tr></tbody></table><hr><p><a href="https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=88046456" target="_blank" rel="noopener"><img data-src="https://wiki.sei.cmu.edu/confluence/download/attachments/88046682/button_arrow_left.png?version=1&amp;modificationDate=1216910800000&amp;api=v2" alt="SEI CERT C++ Coding Standard &gt; SEI CERT C++ Coding Standard &gt; button_arrow_left.png"></a><a href="https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=88046331" target="_blank" rel="noopener"><img data-src="https://wiki.sei.cmu.edu/confluence/download/attachments/88046682/button_arrow_up.png?version=1&amp;modificationDate=1216910618000&amp;api=v2" alt="SEI CERT C++ Coding Standard &gt; SEI CERT C++ Coding Standard &gt; button_arrow_up.png"></a><a href="https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=88046720" target="_blank" rel="noopener"><img data-src="https://wiki.sei.cmu.edu/confluence/download/attachments/88046682/button_arrow_right.png?version=1&amp;modificationDate=1216910815000&amp;api=v2" alt="SEI CERT C++ Coding Standard &gt; SEI CERT C++ Coding Standard &gt; button_arrow_right.png"></a></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>SEI CERT C++</category>
      </categories>
      <tags>
        <tag>SEI CERT C++</tag>
        <tag>编码规范</tag>
        <tag>翻译</tag>
        <tag>CERT Containers</tag>
      </tags>
  </entry>
  <entry>
    <title>CTR53-CPP. 使用有效的迭代器范围</title>
    <url>/posts/676034886/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><!-- build time:Sat Nov 13 2021 15:45:21 GMT+0000 (Coordinated Universal Time) --><p>原文链接：</p><p><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/CTR53-CPP.+Use+valid+iterator+ranges" target="_blank" rel="noopener">CTR53-CPP. Use valid iterator ranges</a></p><p><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/CTR53-CPP.+Use+valid+iterator+ranges" target="_blank" rel="noopener">https://wiki.sei.cmu.edu/confluence/display/cplusplus/CTR53-CPP.+Use+valid+iterator+ranges</a></p><a id="more"></a><p>当遍历一个容器的元素时，迭代器必须在有效范围内迭代。一个迭代器的范围是一对迭代器，分别指向首个元素和尾后元素。</p><p>一个有效迭代器范围有以下全部特点：</p><ul><li>两个迭代器指向同一个容器。</li><li>表示范围开始位置的迭代器在表示结束位置的迭代器。</li><li>迭代器没有失效，符合 <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/CTR51-CPP.+Use+valid+references%2C+pointers%2C+and+iterators+to+reference+elements+of+a+container" target="_blank" rel="noopener">CTR51-CPP. Use valid references, pointers, and iterators to reference elements of a container</a>。</li></ul><p>一个空的迭代器范围 (两个迭代器均有效并且相等) 也是被认为是有效的。</p><p>使用两个无效的迭代器的范围或者没有指向同一个容器导致 <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-undefinedbehavior" target="_blank" rel="noopener">未定义行为</a>.</p><p>When iterating over elements of a container, the iterators used must iterate over a valid range. An iterator range is a pair of iterators that refer to the first and past-the-end elements of the range respectively.</p><p>A valid iterator range has all of the following characteristics:</p><ul><li>Both iterators refer into the same container.</li><li>The iterator representing the start of the range precedes the iterator representing the end of the range.</li><li>The iterators are not invalidated, in conformance with <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/CTR51-CPP.+Use+valid+references%2C+pointers%2C+and+iterators+to+reference+elements+of+a+container" target="_blank" rel="noopener">CTR51-CPP. Use valid references, pointers, and iterators to reference elements of a container</a>.</li></ul><p>An empty iterator range (where the two iterators are valid and equivalent) is considered to be valid.</p><p>Using a range of two iterators that are invalidated or do not refer into the same container results in <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-undefinedbehavior" target="_blank" rel="noopener">undefined behavior</a>.</p><h2 id="不合规的代码示例-Noncompliant-Code-Example"><a class="header-anchor" href="#不合规的代码示例-Noncompliant-Code-Example">¶</a>不合规的代码示例 Noncompliant Code Example</h2><p>在这个不合规的代码示例中，两个迭代器将范围限定在同一个迭代器中，但是第一个迭代器不是先于第二个迭代器。在它的内部循环迭代中，<code>std::for_each()</code> 比较第一个迭代器 (在累加之后) 和第二个迭代器是否相等；只要它们不等，它就继续递增第一个迭代器。递增表示范围内尾后元素的迭代器导致 <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-undefinedbehavior" target="_blank" rel="noopener">undefined behavior</a>.</p><p>In this noncompliant example, the two iterators that delimit the range point into the same container, but the first iterator does not precede the second. On each iteration of its internal loop, <code>std::for_each()</code> compares the first iterator (after incrementing it) with the second for equality; as long as they are not equal, it will continue to increment the first iterator. Incrementing the iterator representing the past-the-end element of the range results in <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-undefinedbehavior" target="_blank" rel="noopener">undefined behavior</a>.</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;c)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::for_each(c.<span class="built_in">end</span>(), c.<span class="built_in">begin</span>(), [](<span class="keyword">int</span> i) &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i; &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无效迭代器范围也可能是由于对两个相等的值返回 true 的比较函数造成。查看 <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/CTR57-CPP.+Provide+a+valid+ordering+predicate" target="_blank" rel="noopener">CTR57-CPP. Provide a valid ordering predicate</a> 获取更多关于比较器的信息。</p><p>Invalid iterator ranges can also result from comparison functions that return true for equal values. See <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/CTR57-CPP.+Provide+a+valid+ordering+predicate" target="_blank" rel="noopener">CTR57-CPP. Provide a valid ordering predicate</a> for more information about comparators.</p><h2 id="合规的方案-Compliant-Solution"><a class="header-anchor" href="#合规的方案-Compliant-Solution">¶</a>合规的方案 Compliant Solution</h2><p>在这个合规方案中，这个传入<code>std::for_each()</code> 迭代器的值是恰当的顺序。</p><p>In this compliant solution, the iterator values passed to <code>std::for_each()</code> are passed in the proper order.</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;c)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::for_each(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), [](<span class="keyword">int</span> i) &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i; &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="不合规的代码示例-Noncompliant-Code-Example-v2"><a class="header-anchor" href="#不合规的代码示例-Noncompliant-Code-Example-v2">¶</a>不合规的代码示例 Noncompliant Code Example</h2><p>在这个不合规的代码示例中，来自不同容器的迭代器被传递了同一个迭代器范围。即使很多 STL <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions" target="_blank" rel="noopener">implementations</a> 将编译这块代码，程序可能表现得和开发者期望的一样，一个 STL 的实现将默认初始化的迭代器视为 <code>end()</code> 返回的迭代器的同义词不是必要的。</p><p>In this noncompliant code example, iterators from different containers are passed for the same iterator range. Although many STL <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions" target="_blank" rel="noopener">implementations</a> will compile this code and the program may behave as the developer expects, there is no requirement that an STL implementation treat a default-initialized iterator as a synonym for the iterator returned by <code>end()</code>.</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;c)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator e;</span><br><span class="line">  <span class="built_in">std</span>::for_each(c.<span class="built_in">begin</span>(), e, [](<span class="keyword">int</span> i) &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i; &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="合规的方案-Compliant-Solution-v2"><a class="header-anchor" href="#合规的方案-Compliant-Solution-v2">¶</a>合规的方案 Compliant Solution</h2><p>在这个合规方案中，通过调用 <code>end()</code> 生成的正确的迭代器被传入。</p><p>In this compliant solution, the proper iterator generated by a call to <code>end()</code> is passed.</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;c)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::for_each(c.begin(), c.end(), [](<span class="keyword">int</span> i) &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i; &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="风险评估-Risk-Assessment"><a class="header-anchor" href="#风险评估-Risk-Assessment">¶</a>风险评估 Risk Assessment</h2><p>使用无效的迭代器范围与缓冲区溢出类似，会引起攻击者执行任意代码。</p><p>Using an invalid iterator range is similar to allowing a buffer overflow, which can lead to an attacker running arbitrary code.</p><table><thead><tr><th style="text-align:left">Rule</th><th style="text-align:left">Severity</th><th style="text-align:left">Likelihood</th><th style="text-align:left">Remediation Cost</th><th style="text-align:left">Priority</th><th style="text-align:left">Level</th></tr></thead><tbody><tr><td style="text-align:left">CTR53-CPP</td><td style="text-align:left">High</td><td style="text-align:left">Probable</td><td style="text-align:left">High</td><td style="text-align:left"><strong>P6</strong></td><td style="text-align:left"><strong>L2</strong></td></tr></tbody></table><h3 id="Automated-Detection"><a class="header-anchor" href="#Automated-Detection">¶</a>Automated Detection</h3><table><thead><tr><th style="text-align:left">Tool</th><th style="text-align:left">Version</th><th style="text-align:left">Checker</th><th style="text-align:left">Description</th></tr></thead><tbody><tr><td style="text-align:left"><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/Parasoft" target="_blank" rel="noopener">Parasoft C/C++test</a></td><td style="text-align:left"><img data-src="https://wiki.sei.cmu.edu/confluence/plugins/servlet/confluence/placeholder/macro?definition=e2luY2x1ZGU6UGFyYXNvZnRfVn0&amp;locale=zh_CN&amp;version=2" alt="img"></td><td style="text-align:left"><strong>CERT_CPP-CTR53-a</strong> <strong>CERT_CPP-CTR53-b</strong></td><td style="text-align:left">Do not use an iterator range that isn’t really a range Do not compare iterators from different containers</td></tr><tr><td style="text-align:left"><a href="https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=88046345" target="_blank" rel="noopener">PRQA QA-C++</a></td><td style="text-align:left"><img data-src="https://wiki.sei.cmu.edu/confluence/plugins/servlet/confluence/placeholder/macro?definition=e2luY2x1ZGU6UFJRQSBRQS1DKytfVn0&amp;locale=zh_CN&amp;version=2" alt="img"></td><td style="text-align:left"><strong>3802</strong></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/PVS-Studio" target="_blank" rel="noopener">PVS-Studio</a></td><td style="text-align:left"><img data-src="https://wiki.sei.cmu.edu/confluence/plugins/servlet/confluence/placeholder/macro?definition=e2luY2x1ZGU6UFZTLVN0dWRpb19WfQ&amp;locale=zh_CN&amp;version=2" alt="img"></td><td style="text-align:left"><a href="https://www.viva64.com/en/w/v539/" target="_blank" rel="noopener"><strong>V539</strong></a>, <a href="https://www.viva64.com/en/w/v662/" target="_blank" rel="noopener"><strong>V662</strong></a>, <strong><a href="https://www.viva64.com/en/w/v789/" target="_blank" rel="noopener">V789</a></strong></td><td style="text-align:left"></td></tr></tbody></table><h3 id="Related-Vulnerabilities"><a class="header-anchor" href="#Related-Vulnerabilities">¶</a>Related Vulnerabilities</h3><p>In <em>Fun with erase()</em>, Chris Rohlf discusses the exploit potential of a program that calls <code>vector::erase()</code> with invalid iterator ranges [<a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-rohlf2009" target="_blank" rel="noopener">Rohlf 2009</a>].</p><p>Search for <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions" target="_blank" rel="noopener">vulnerabilities</a> resulting from the violation of this rule on the <a href="https://www.kb.cert.org/vulnotes/bymetric?searchview&amp;query=FIELD+KEYWORDS+contains+CTR53-CPP" target="_blank" rel="noopener">CERT website</a>.</p><h2 id="Related-Guidelines"><a class="header-anchor" href="#Related-Guidelines">¶</a>Related Guidelines</h2><table><thead><tr><th><a href="https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=88046682" target="_blank" rel="noopener">SEI CERT C++ Coding Standard</a></th><th><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/CTR51-CPP.+Use+valid+references%2C+pointers%2C+and+iterators+to+reference+elements+of+a+container" target="_blank" rel="noopener">CTR51-CPP. Use valid references, pointers, and iterators to reference elements of a container</a> <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/CTR57-CPP.+Provide+a+valid+ordering+predicate" target="_blank" rel="noopener">CTR57-CPP. Provide a valid ordering predicate</a></th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><h2 id="Bibliography"><a class="header-anchor" href="#Bibliography">¶</a>Bibliography</h2><table><thead><tr><th>[<a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-ISO/IEC14882-2014" target="_blank" rel="noopener">ISO/IEC 14882-2014</a>]</th><th>Clause 24, “Iterators Library” Subclause 25.3, “Mutating Sequence Operations”</th></tr></thead><tbody><tr><td>[<a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-Meyers01" target="_blank" rel="noopener">Meyers 2001</a>]</td><td>Item 32, “Follow Remove-Like Algorithms with <code>erase</code> If You Really Want to Remove Something”</td></tr></tbody></table><hr><p><a href="https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=88046690" target="_blank" rel="noopener"><img data-src="https://wiki.sei.cmu.edu/confluence/download/attachments/88046682/button_arrow_left.png?version=1&amp;modificationDate=1216910800000&amp;api=v2" alt="SEI CERT C++ Coding Standard &gt; SEI CERT C++ Coding Standard &gt; button_arrow_left.png"></a><a href="https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=88046331" target="_blank" rel="noopener"><img data-src="https://wiki.sei.cmu.edu/confluence/download/attachments/88046682/button_arrow_up.png?version=1&amp;modificationDate=1216910618000&amp;api=v2" alt="SEI CERT C++ Coding Standard &gt; SEI CERT C++ Coding Standard &gt; button_arrow_up.png"></a><a href="https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=88046693" target="_blank" rel="noopener"><img data-src="https://wiki.sei.cmu.edu/confluence/download/attachments/88046682/button_arrow_right.png?version=1&amp;modificationDate=1216910815000&amp;api=v2" alt="SEI CERT C++ Coding Standard &gt; SEI CERT C++ Coding Standard &gt; button_arrow_right.png"></a></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>SEI CERT C++</category>
      </categories>
      <tags>
        <tag>SEI CERT C++</tag>
        <tag>编码规范</tag>
        <tag>翻译</tag>
        <tag>CERT Containers</tag>
      </tags>
  </entry>
  <entry>
    <title>CTR52-CPP. 确保库函数不要溢出</title>
    <url>/posts/3185197214/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><!-- build time:Sat Nov 13 2021 15:45:21 GMT+0000 (Coordinated Universal Time) --><p>原文链接：</p><p><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/CTR52-CPP.+Guarantee+that+library+functions+do+not+overflow" target="_blank" rel="noopener">CTR52-CPP. Guarantee that library functions do not overflow</a></p><p><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/CTR52-CPP.+Guarantee+that+library+functions+do+not+overflow" target="_blank" rel="noopener">https://wiki.sei.cmu.edu/confluence/display/cplusplus/CTR52-CPP.+Guarantee+that+library+functions+do+not+overflow</a></p><a id="more"></a><p>拷贝数据到一个不够容纳这些数据的容器中导致缓冲区溢出。为了避免这类错误，被拷贝到目标容器的数据必须严格限制在目标容器的尺寸下，或者更完美的，目标容器必须确保足够大来容纳将被拷贝的数据。</p><p>Copying data into a container that is not large enough to hold that data results in a buffer overflow. To prevent such errors, data copied to the destination container must be restricted on the basis of the destination container’s size, or preferably, the destination container must be guaranteed to be large enough to hold the data to be copied.</p><p>由拷贝数据到尺寸不足的缓冲区导致的 <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-vulnerability" target="_blank" rel="noopener">漏洞</a> 也会涉及 null 结尾的字符串。参阅 <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/STR50-CPP.+Guarantee+that+storage+for+strings+has+sufficient+space+for+character+data+and+the+null+terminator" target="_blank" rel="noopener">STR50-CPP. Guarantee that storage for strings has sufficient space for character data and the null terminator</a> 获取涉及字符串的例子。</p><p><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-vulnerability" target="_blank" rel="noopener">Vulnerabilities</a> that result from copying data to an undersized buffer can also involve null-terminated strings. Consult <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/STR50-CPP.+Guarantee+that+storage+for+strings+has+sufficient+space+for+character+data+and+the+null+terminator" target="_blank" rel="noopener">STR50-CPP. Guarantee that storage for strings has sufficient space for character data and the null terminator</a> for specific examples of this rule that involve strings.</p><p>拷贝可以使用 <code>std::memcpy()</code> 函数。然而， <code>std::memmove()</code> 和 <code>std::memset()</code> 函数也会导致相同的漏洞，因为在覆写一块内存时没有检查该块是否有效。这类问题不止现定于 C 标准库函数；标准模板库 (STL) 泛型算法，例如 <code>std::copy()</code>，<code>std::fill()</code>，和 <code>std::transform()</code> 也假定有效的输出缓冲区尺寸 [<a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-ISO/IEC14882-2014" target="_blank" rel="noopener">ISO/IEC 14882-2014</a>].。</p><p>Copies can be made with the <code>std::memcpy()</code> function. However, the <code>std::memmove()</code> and <code>std::memset()</code> functions can also have the same vulnerabilities because they overwrite a block of memory without checking that the block is valid. Such issues are not limited to C standard library functions; standard template library (STL) generic algorithms, such as <code>std::copy()</code>, <code>std::fill()</code>, and <code>std::transform()</code>, also assume valid output buffer sizes [<a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-ISO/IEC14882-2014" target="_blank" rel="noopener">ISO/IEC 14882-2014</a>].</p><h2 id="不合规代码示例-Noncompliant-Code-Example"><a class="header-anchor" href="#不合规代码示例-Noncompliant-Code-Example">¶</a>不合规代码示例 Noncompliant Code Example</h2><p>STL 容器也会遭受与数组数据类型相同的漏洞。<code>std::copy()</code> 算法没有提供内部边界检查，会导致缓冲区溢出。在这个不合规的示例代码中，使用 <code>std::copy()</code>，把一个整型的 vector 从 <code>src</code> 拷贝到 <code>dest</code> 中。因为 <code>std::copy()</code> 不会展开 <code>dest</code> vector，程序在拷贝第一个元素时将溢出缓冲区。</p><p>STL containers can be subject to the same vulnerabilities as array data types. The <code>std::copy()</code> algorithm provides no inherent bounds checking and can lead to a buffer overflow. In this noncompliant code example, a vector of integers is copied from <code>src</code> to <code>dest</code> using <code>std::copy()</code>. Because <code>std::copy()</code> does nothing to expand the <code>dest</code> vector, the program will overflow the buffer on copying the first element.</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;src)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dest;</span><br><span class="line">  <span class="built_in">std</span>::copy(src.<span class="built_in">begin</span>(), src.<span class="built_in">end</span>(), dest.<span class="built_in">begin</span>());</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个风险在适用任何期望将值填入目标迭代器的算法。大多数 STL 算法期望目标容器有足够的空间来容纳提供的值。</p><p>This hazard applies to any algorithm that takes a destination iterator, expecting to fill it with values. Most of the STL algorithms expect the destination container to have sufficient space to hold the values provided.</p><h2 id="合规方案-Sufficient-Initial-Capacity-Compliant-Solution-Sufficient-Initial-Capacity"><a class="header-anchor" href="#合规方案-Sufficient-Initial-Capacity-Compliant-Solution-Sufficient-Initial-Capacity">¶</a>合规方案 (Sufficient Initial Capacity) Compliant Solution (Sufficient Initial Capacity)</h2><p>使用 <code>std::copy()</code> 恰当的方式是确保目标容器可以容纳所有正被拷贝进去的元素。这个合规方案扩容 vector 容量优先拷贝操作。</p><p>The proper way to use <code>std::copy()</code> is to ensure the destination container can hold all the elements being copied to it. This compliant solution enlarges the capacity of the vector prior to the copy operation.</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;src)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Initialize dest with src.size() default-inserted elements</span></span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dest</span><span class="params">(src.<span class="built_in">size</span>())</span></span>;</span><br><span class="line">  <span class="built_in">std</span>::copy(src.<span class="built_in">begin</span>(), src.<span class="built_in">end</span>(), dest.<span class="built_in">begin</span>());</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="合规方案-Per-Element-Growth-Compliant-Solution-Per-Element-Growth"><a class="header-anchor" href="#合规方案-Per-Element-Growth-Compliant-Solution-Per-Element-Growth">¶</a>合规方案 (Per-Element Growth) Compliant Solution (Per-Element Growth)</h2><p>可选的方法是提供一个 <code>std::back_insert_iterator</code> 作为目标容器的实参。这个迭代器会对每个算法提供的元素扩展目标容器，这保证了目标容器将变得足够大来容纳被提供的元素。</p><p>An alternative approach is to supply a <code>std::back_insert_iterator</code> as the destination argument. This iterator expands the destination container by one element for each element supplied by the algorithm, which guarantees the destination container will become sufficiently large to hold the elements provided.</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;src)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dest;</span><br><span class="line">  <span class="built_in">std</span>::copy(src.<span class="built_in">begin</span>(), src.<span class="built_in">end</span>(), <span class="built_in">std</span>::back_inserter(dest));</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="合规的方案-Assignment-Compliant-Solution-Assignment"><a class="header-anchor" href="#合规的方案-Assignment-Compliant-Solution-Assignment">¶</a>合规的方案 (Assignment) Compliant Solution (Assignment)</h2><p>最简单的方法就是直接用 <code>src</code> 来构造 <code>dest</code>，像这个合规方案里展示的。</p><p>The simplest solution is to construct <code>dest</code> from <code>src</code> directly, as in this compliant solution.</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;src)</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dest</span><span class="params">(src)</span></span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="不合规代码示例-Noncompliant-Code-Example-v2"><a class="header-anchor" href="#不合规代码示例-Noncompliant-Code-Example-v2">¶</a>不合规代码示例 Noncompliant Code Example</h2><p>在这个不合规的代码示例中, <code>std::fill_n()</code> 被用来填充 10 个值为 <code>0x42</code> 到缓冲区中。然而，缓冲区没有为这些数据分配任何空间，所以该操作导致缓冲区溢出。</p><p>In this noncompliant code example, <code>std::fill_n()</code> is used to fill a buffer with 10 instances of the value <code>0x42</code>. However, the buffer has not allocated any space for the elements, so this operation results in a buffer overflow.</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">  <span class="built_in">std</span>::fill_n(v.<span class="built_in">begin</span>(), <span class="number">10</span>, <span class="number">0x42</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="合规的方案-Sufficient-Initial-Capacity-Compliant-Solution-Sufficient-Initial-Capacity"><a class="header-anchor" href="#合规的方案-Sufficient-Initial-Capacity-Compliant-Solution-Sufficient-Initial-Capacity">¶</a>合规的方案 (Sufficient Initial Capacity) Compliant Solution (Sufficient Initial Capacity)</h2><p>这个合规的方案保证在试图填充容器之前容器的容量是足够的。</p><p>This compliant solution ensures the capacity of the vector is sufficient before attempting to fill the container.</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">  <span class="built_in">std</span>::fill_n(v.<span class="built_in">begin</span>(), <span class="number">10</span>, <span class="number">0x42</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而，这个合规方案是不充分的。构造器将默认构造 10 个类型为 <code>int</code> 的元素，在调用 <code>std::fill_n()</code> 时，这些元素立马被替换，这意味着容器内的每个元素被初始化的两次。</p><p>However, this compliant solution is inefficient. The constructor will default-construct 10 elements of type <code>int</code>, which are subsequently replaced by the call to <code>std::fill_n()</code>, meaning that each element in the container is initialized twice.</p><h2 id="合规的方案-Fill-Initialization-Compliant-Solution-Fill-Initialization"><a class="header-anchor" href="#合规的方案-Fill-Initialization-Compliant-Solution-Fill-Initialization">¶</a>合规的方案 (Fill Initialization) Compliant Solution (Fill Initialization)</h2><p>这个合规方案中初始化 <code>v</code> 为 10 个值都为 <code>0x42</code> 的元素。</p><p>This compliant solution initializes <code>v</code> to 10 elements whose values are all <code>0x42</code>.</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">10</span>, <span class="number">0x42</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="风险评估-Risk-Assessment"><a class="header-anchor" href="#风险评估-Risk-Assessment">¶</a>风险评估 Risk Assessment</h2><p>拷贝数据到不足以容纳数据大小的缓冲区中导致缓冲区溢出。攻击者可以 <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-exploit" target="_blank" rel="noopener">利用</a> 这个状况来执行任意代码。</p><p>Copying data to a buffer that is too small to hold the data results in a buffer overflow. Attackers can <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-exploit" target="_blank" rel="noopener">exploit</a> this condition to execute arbitrary code.</p><table><thead><tr><th style="text-align:left">Rule</th><th style="text-align:left">Severity</th><th style="text-align:left">Likelihood</th><th style="text-align:left">Remediation Cost</th><th style="text-align:left">Priority</th><th style="text-align:left">Level</th></tr></thead><tbody><tr><td style="text-align:left">CTR52-CPP</td><td style="text-align:left">High</td><td style="text-align:left">Likely</td><td style="text-align:left">Medium</td><td style="text-align:left"><strong>P18</strong></td><td style="text-align:left"><strong>L1</strong></td></tr></tbody></table><h2 id="Automated-Detection"><a class="header-anchor" href="#Automated-Detection">¶</a>Automated Detection</h2><table><thead><tr><th style="text-align:left">Tool</th><th style="text-align:left">Version</th><th style="text-align:left">Checker</th><th style="text-align:left">Description</th></tr></thead><tbody><tr><td style="text-align:left"><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/CodeSonar" target="_blank" rel="noopener">CodeSonar</a></td><td style="text-align:left"><img data-src="https://wiki.sei.cmu.edu/confluence/plugins/servlet/confluence/placeholder/macro?definition=e2luY2x1ZGU6Q29kZVNvbmFyX1Z9&amp;locale=zh_CN&amp;version=2" alt="img"></td><td style="text-align:left">**<a href="http://BADFUNC.BO" target="_blank" rel="noopener">BADFUNC.BO</a>.*****<a href="http://LANG.MEM.BO" target="_blank" rel="noopener">LANG.MEM.BO</a>**</td><td style="text-align:left">A collection of warning classes that report uses of library functions prone to internal buffer overflows.Buffer Overrun</td></tr><tr><td style="text-align:left"><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/Parasoft" target="_blank" rel="noopener">Parasoft C/C++test</a></td><td style="text-align:left"><img data-src="https://wiki.sei.cmu.edu/confluence/plugins/servlet/confluence/placeholder/macro?definition=e2luY2x1ZGU6UGFyYXNvZnRfVn0&amp;locale=zh_CN&amp;version=2" alt="img"></td><td style="text-align:left"><strong>CERT_CPP-CTR52-a</strong></td><td style="text-align:left">Do not pass empty container iterators to std algorithms as destinations</td></tr></tbody></table><h2 id="Related-Vulnerabilities"><a class="header-anchor" href="#Related-Vulnerabilities">¶</a>Related Vulnerabilities</h2><p>Search for <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions" target="_blank" rel="noopener">vulnerabilities</a> resulting from the violation of this rule on the <a href="https://www.kb.cert.org/vulnotes/bymetric?searchview&amp;query=FIELD+KEYWORDS+contains+CTR52-CPP" target="_blank" rel="noopener">CERT website</a>.</p><h2 id="Related-Guidelines"><a class="header-anchor" href="#Related-Guidelines">¶</a>Related Guidelines</h2><table><thead><tr><th><a href="https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=88046682" target="_blank" rel="noopener">SEI CERT C++ Coding Standard</a></th><th><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/STR50-CPP.+Guarantee+that+storage+for+strings+has+sufficient+space+for+character+data+and+the+null+terminator" target="_blank" rel="noopener">STR50-CPP. Guarantee that storage for strings has sufficient space for character data and the null terminator</a></th></tr></thead><tbody><tr><td><a href="https://wiki.sei.cmu.edu/confluence/display/c/SEI+CERT+C+Coding+Standard" target="_blank" rel="noopener">SEI CERT C Coding Standard</a></td><td><a href="https://wiki.sei.cmu.edu/confluence/display/c/ARR38-C.+Guarantee+that+library+functions+do+not+form+invalid+pointers" target="_blank" rel="noopener">ARR38-C. Guarantee that library functions do not form invalid pointers</a></td></tr><tr><td><a href="http://cwe.mitre.org/" target="_blank" rel="noopener">MITRE CWE</a></td><td><a href="http://cwe.mitre.org/data/definitions/119.html" target="_blank" rel="noopener">CWE 119</a>, Failure to Constrain Operations within the Bounds of an Allocated Memory Buffer <a href="http://cwe.mitre.org/data/definitions/805.html" target="_blank" rel="noopener">CWE 805</a>, Buffer Access with Incorrect Length Value</td></tr></tbody></table><h2 id="Bibliography"><a class="header-anchor" href="#Bibliography">¶</a>Bibliography</h2><table><thead><tr><th>[<a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-ISO/IEC14882-2014" target="_blank" rel="noopener">ISO/IEC 14882-2014</a>]</th><th>Subclause 25.3, “Mutating Sequence Operations”</th></tr></thead><tbody><tr><td>[<a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-ISO/IECTR24772-2013" target="_blank" rel="noopener">ISO/IEC TR 24772-2013</a>]</td><td>Buffer Overflow in Heap [XYB] Buffer Overflow in Stack [XYW] Unchecked Array Indexing [XYZ]</td></tr><tr><td>[<a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-Meyers01" target="_blank" rel="noopener">Meyers 2001</a>]</td><td>Item 30, “Make Sure Destination Ranges Are Big Enough”</td></tr></tbody></table><hr><p><a href="https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=88046457" target="_blank" rel="noopener"><img data-src="https://wiki.sei.cmu.edu/confluence/download/attachments/88046682/button_arrow_left.png?version=1&amp;modificationDate=1216910800000&amp;api=v2" alt="SEI CERT C++ Coding Standard &gt; SEI CERT C++ Coding Standard &gt; button_arrow_left.png"></a><a href="https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=88046331" target="_blank" rel="noopener"><img data-src="https://wiki.sei.cmu.edu/confluence/download/attachments/88046682/button_arrow_up.png?version=1&amp;modificationDate=1216910618000&amp;api=v2" alt="SEI CERT C++ Coding Standard &gt; SEI CERT C++ Coding Standard &gt; button_arrow_up.png"></a><a href="https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=88046456" target="_blank" rel="noopener"><img data-src="https://wiki.sei.cmu.edu/confluence/download/attachments/88046682/button_arrow_right.png?version=1&amp;modificationDate=1216910815000&amp;api=v2" alt="SEI CERT C++ Coding Standard &gt; SEI CERT C++ Coding Standard &gt; button_arrow_right.png"></a></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>SEI CERT C++</category>
      </categories>
      <tags>
        <tag>SEI CERT C++</tag>
        <tag>编码规范</tag>
        <tag>翻译</tag>
        <tag>CERT Containers</tag>
      </tags>
  </entry>
  <entry>
    <title>CTR51-CPP. 使用有效的引用，指针，迭代器来引用容器的元素</title>
    <url>/posts/39044419/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><!-- build time:Sat Nov 13 2021 15:45:21 GMT+0000 (Coordinated Universal Time) --><p>原文链接：</p><p><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/CTR51-CPP.+Use+valid+references%2C+pointers%2C+and+iterators+to+reference+elements+of+a+container" target="_blank" rel="noopener">CTR51-CPP. Use valid references, pointers, and iterators to reference elements of a container</a></p><p><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/CTR51-CPP.+Use+valid+references%2C+pointers%2C+and+iterators+to+reference+elements+of+a+container" target="_blank" rel="noopener">https://wiki.sei.cmu.edu/confluence/display/cplusplus/CTR51-CPP.+Use+valid+references%2C+pointers%2C+and+iterators+to+reference+elements+of+a+container</a></p><a id="more"></a><p>迭代器是指针的泛化，允许 C++ 程序可以在不同的数据结构 (容器) 以一种通用的方式运行。指针，引用和迭代器具有密切关系，在引用值时必须通过一个有效的迭代器，指针或者引用。任何时候存储一个指向一个容器内的元素的迭代器，引用或者指针都有风险，底层容器可能会被修改以致于已经存储的迭代器，指针或者引用失效。例如，当序列容器例如 <code>std::vector</code> 需要重新分配，已有的迭代器，指针和引用将会失效 [<a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-Kalev99" target="_blank" rel="noopener">Kalev 99</a>]。仅使用 <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-validpointer" target="_blank" rel="noopener">有效指针</a> ，引用，或者迭代器来指向容器内的元素。</p><p>C++ 标准，[container.requirements.general]，第 12 段 [<a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-ISO/IEC14882-2014" target="_blank" rel="noopener">ISO/IEC 14882-2014</a>] 陈述如下：</p><blockquote><p>除非另有规定 (显式或者通过其他函数来定义一个函数)，调用一个容器的成员函数或者传递一个作为参数的容器到库函数不应该使指向该容器内对象的迭代器失效，或修改该容器内对象的值。</p></blockquote><p>Iterators are a generalization of pointers that allow a C++ program to work with different data structures (containers) in a uniform manner [<a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-ISO/IEC14882-2014" target="_blank" rel="noopener">ISO/IEC 14882-2014</a>]. Pointers, references, and iterators share a close relationship in which it is required that referencing values be done through a valid iterator, pointer, or reference. Storing an iterator, reference, or pointer to an element within a container for any length of time comes with a risk that the underlying container may be modified such that the stored iterator, pointer, or reference becomes invalid. For instance, when a sequence container such as <code>std::vector</code> requires an underlying reallocation, outstanding iterators, pointers, and references will be invalidated [<a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-Kalev99" target="_blank" rel="noopener">Kalev 99</a>]. Use only a <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-validpointer" target="_blank" rel="noopener">valid pointer</a>, reference, or iterator to refer to an element of a container.</p><p>The C++ Standard, [container.requirements.general], paragraph 12 [<a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-ISO/IEC14882-2014" target="_blank" rel="noopener">ISO/IEC 14882-2014</a>] states the following:</p><blockquote><p>Unless otherwise specified (either explicitly or by defining a function in terms of other functions), invoking a container member function or passing a container as an argument to a library function shall not invalidate iterators to, or change the values of, objects within that container.</p></blockquote><p>C++ 标准允许引用和指针对于同样的操作各自独立地失效，这可能导致一个失效的引用但是未失效的指针。然后，依赖这个却别使不安全的，因为指针指向的对象可能与预期的不同，即使指针是有效的。例如，检索一个指向容器内元素的指针，擦除这个元素 (当销毁底层对象时，引用失效)，然后在容器的相同位置插入一个新的元素，造成现存的指针现在指向一个有效但是不同的对象。所以，任何使一个指针或者一个引用失效的操作应该被当作会使指针和引用都失效来对待。</p><p>The C++ Standard allows references and pointers to be invalidated independently for the same operation, which may result in an invalidated reference but not an invalidated pointer. However, relying on this distinction is insecure because the object pointed to by the pointer may be different than expected even if the pointer is valid. For instance, it is possible to retrieve a pointer to an element from a container, erase that element (invalidating references when destroying the underlying object), then insert a new element at the same location within the container causing the extant pointer to now point to a valid, but distinct object. Thus, any operation that invalidates a pointer or a reference should be treated as though it invalidates both pointers and references.</p><p>以下容器函数会使迭代器，引用和指针在特定情况下失效。</p><p>The following container functions can invalidate iterators, references, and pointers under certain circumstances.</p><table><thead><tr><th style="text-align:left">Class</th><th style="text-align:left">Function</th><th style="text-align:left">Iterators</th><th style="text-align:left">References/Pointers</th><th style="text-align:left">Notes</th></tr></thead><tbody><tr><td style="text-align:left"><code>std::deque</code></td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>insert()</code>, <code>emplace_front()</code>, <code>emplace_back()</code>, <code>emplace()</code>, <code>push_front()</code>, <code>push_back()</code></td><td style="text-align:left">X</td><td style="text-align:left">X</td><td style="text-align:left">在双端队列中间的插入操作使所有指向该队列的元素的迭代器和引用失效。尾部插入使所有迭代器失效但对该队列内元素的引用有效性没有影响。 An insertion in the middle of the deque invalidates all the iterators and references to elements of the deque. An insertion at either end of the deque invalidates all the iterators to the deque but has no effect on the validity of references to elements of the deque. ([deque.modifiers], paragraph 1)</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>erase()</code>, <code>pop_back()</code>, <code>resize()</code></td><td style="text-align:left">X</td><td style="text-align:left">X</td><td style="text-align:left">对双端队列最后一个元素的擦除操作只会使尾后迭代器和所有指向被擦除元素的迭代器和引用失效。对双端队列第一个元素的擦除操作只使被擦除的元素失效。对双端队列非第一个及非最后一个元素的擦除操作尾后迭代器和所有指向该队列内元素的迭代器及引用失效。An erase operation that erases the last element of a deque invalidates only the past-the-end iterator and all iterators and references to the erased elements. An erase operation that erases the first element of a deque but not the last element invalidates only the erased elements. An erase operation that erases neither the first element nor the last element of a deque invalidates the past-the-end iterator and all iterators and references to all the elements of the deque. ([deque.modifiers], paragraph 4)</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>clear()</code></td><td style="text-align:left">X</td><td style="text-align:left">X</td><td style="text-align:left">销毁容器内的所有元素使所有的容器内元素的引用，指针和迭代器失效。可能也会使尾后迭代器失效。Destroys all elements in the container. Invalidates all references, pointers, and iterators referring to the elements of the container and may invalidate the past-the-end iterator. ([sequence.reqmts], Table 100)</td></tr><tr><td style="text-align:left"><code>std::forward_list</code></td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>erase_after()</code>, <code>pop_front()</code>, <code>resize()</code></td><td style="text-align:left">X</td><td style="text-align:left">X</td><td style="text-align:left"><code>erase_after</code> 可能只使指向被擦除元素的迭代器和引用失效。<code>erase_after</code>shall invalidate only iterators and references to the erased elements. ([forwardlist.modifiers], paragraph 1)</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>remove()</code>, <code>unique()</code></td><td style="text-align:left">X</td><td style="text-align:left">X</td><td style="text-align:left">只使指向被擦除元素的迭代器和引用失效。Invalidates only the iterators and references to the erased elements. ([forwardlist.ops], paragraph 12 &amp; paragraph 16)</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>clear()</code></td><td style="text-align:left">X</td><td style="text-align:left">X</td><td style="text-align:left">销毁容器内的所有元素使所有的容器内元素的引用，指针和迭代器失效。可能也会使尾后迭代器失效。Destroys all elements in the container. Invalidates all references, pointers, and iterators referring to the elements of the container and may invalidate the past-the-end iterator. ([sequence.reqmts], Table 100)</td></tr><tr><td style="text-align:left"><code>std::list</code></td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>erase()</code>, <code>pop_front()</code>, <code>pop_back()</code>, <code>clear()</code>, <code>remove()</code>, <code>remove_if()</code>, <code>unique()</code></td><td style="text-align:left">X</td><td style="text-align:left">X</td><td style="text-align:left">Invalidates only the iterators and references to the erased elements. ([list.modifiers], paragraph 3 and [list.ops], paragraph 15 &amp; paragraph 19)</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>clear()</code></td><td style="text-align:left">X</td><td style="text-align:left">X</td><td style="text-align:left">销毁容器内的所有元素使所有的容器内元素的引用，指针和迭代器失效。可能也会使尾后迭代器失效。Destroys all elements in the container. Invalidates all references, pointers, and iterators referring to the elements of the container and may invalidate the past-the-end iterator. ([sequence.reqmts], Table 100)</td></tr><tr><td style="text-align:left"><code>std::vector</code></td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>reserve()</code></td><td style="text-align:left">X</td><td style="text-align:left">X</td><td style="text-align:left">在<code>reserve()</code> 之后，如果重分配发生，<code>capacity()</code> 将大于或者等于 <code>reverse</code> 的参数值，否则，将等于 <code>capacity()</code> 先前的值。重分配使所有指向序列元素的引用，指针和迭代器失效。After <code>reserve()</code>, <code>capacity()</code> is greater or equal to the argument of <code>reserve</code> if reallocation happens and is equal to the previous value of <code>capacity()</code> otherwise. Reallocation invalidates all the references, pointers, and iterators referring to the elements in the sequence. ([vector.capacity], paragraph 3 &amp; paragraph 6)</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>insert()</code>, <code>emplace_back()</code>, <code>emplace()</code>, <code>push_back()</code></td><td style="text-align:left">X</td><td style="text-align:left">X</td><td style="text-align:left">如果新的尺寸值大于旧的容量值，会造成重分配。如果没有发生重分配，所有在插入位置之前的迭代器和引用依然保持有效。所有在插入位置之后的迭代器和引用将失效。Causes reallocation if the new size is greater than the old capacity. If no reallocation happens, all the iterators and references before the insertion point remain valid. ([vector.modifiers], paragraph 1). All iterators and references after the insertion point are invalidated.</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>erase()</code>, <code>pop_back()</code>, <code>resize()</code></td><td style="text-align:left">X</td><td style="text-align:left">X</td><td style="text-align:left">在擦除位置及之后的迭代器和引用失效。Invalidates iterators and references at or after the point of the erase. ([vector.modifiers], paragraph 3)</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>clear()</code></td><td style="text-align:left">X</td><td style="text-align:left">X</td><td style="text-align:left">销毁容器内的所有元素使所有的容器内元素的引用，指针和迭代器失效。可能也会使尾后迭代器失效。Destroys all elements in the container. Invalidates all references, pointers, and iterators referring to the elements of the container and may invalidate the past-the-end iterator. ([sequence.reqmts], Table 100)</td></tr><tr><td style="text-align:left"><code>std::set</code>, <code>std::multiset</code>, <code>std::map</code>, <code>std::multimap</code></td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>erase()</code>, <code>clear()</code></td><td style="text-align:left">X</td><td style="text-align:left">X</td><td style="text-align:left">只使指向被擦除元素的迭代器和引用失效。Invalidates only iterators and references to the erased elements. ([associative.reqmts], paragraph 9)</td></tr><tr><td style="text-align:left"><code>std::unordered_set</code>, <code>std::unordered_multiset</code>, <code>std::unordered_map</code>, <code>std::unordered_multimap</code></td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>erase()</code>, <code>clear()</code></td><td style="text-align:left">X</td><td style="text-align:left">X</td><td style="text-align:left">只使指向被擦除元素的迭代器和引用失效。Invalidates only iterators and references to the erased elements. ([unord.req], paragraph 14)</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>insert()</code>, <code>emplace()</code></td><td style="text-align:left">X</td><td style="text-align:left"></td><td style="text-align:left"><code>insert</code> 和<code>emplace</code>成员不会对迭代器有效性造成影响，如果 (<em>N</em>+<em>n</em>) &lt; <em>z</em> * <em>B</em>，其中 <em>N</em> 是 <code>insert</code> 操作之前的容器元素个数， <em>n</em>是已插入元素的个数， <em>B</em> 是容器的桶个数，<em>z</em> 是容器的最大负载因子 。The <code>insert</code> and <code>emplace</code> members shall not affect the validity of iterators if (<em>N</em>+<em>n</em>) &lt; <em>z</em> * <em>B</em>, where <em>N</em> is the number of elements in the container prior to the <code>insert</code> operation, <em>n</em> is the number of elements inserted, <em>B</em> is the container’s bucket count, and <em>z</em> is the container’s maximum load factor. ([unord.req], paragraph 15)</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>rehash()</code>, <code>reserve()</code></td><td style="text-align:left">X</td><td style="text-align:left"></td><td style="text-align:left">重哈希会使迭代器失效，改变元素间的顺序，改变元素所在的桶，但是不会使指向元素的指针或者引用失效。Rehashing invalidates iterators, changes ordering between elements, and changes which buckets the elements appear in but does not invalidate pointers or references to elements. ([unord.req], paragraph 9)</td></tr><tr><td style="text-align:left"><code>std::valarray</code></td><td style="text-align:left"><code>resize()</code></td><td style="text-align:left"></td><td style="text-align:left">X</td><td style="text-align:left">改变大小操作使所有指向数组元素的指针和引用失效。Resizing invalidates all pointers and references to elements in the array. ([valarray.members], paragraph 12)</td></tr></tbody></table><p>一个<code>std::basic_string</code> 对象也是一个适用这条规则的容器。更多关于 <code>std::basic_string</code> 容器的特定信息，查看 <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/STR52-CPP.+Use+valid+references%2C+pointers%2C+and+iterators+to+reference+elements+of+a+basic_string" target="_blank" rel="noopener">STR52-CPP. Use valid references, pointers, and iterators to reference elements of a basic_string</a> 。</p><p>A <code>std::basic_string</code> object is also a container to which this rule applies. For more specific information pertaining to <code>std::basic_string</code> containers, see <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/STR52-CPP.+Use+valid+references%2C+pointers%2C+and+iterators+to+reference+elements+of+a+basic_string" target="_blank" rel="noopener">STR52-CPP. Use valid references, pointers, and iterators to reference elements of a basic_string</a>.</p><h2 id="不合规代码示例-Noncompliant-Code-Example"><a class="header-anchor" href="#不合规代码示例-Noncompliant-Code-Example">¶</a>不合规代码示例 Noncompliant Code Example</h2><p>在这个不合规的代码示例中，在首次调用 <code>insert()</code> 时，<code>pos</code> 就失效了， 下标循环迭代有<a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-undefinedbehavior" target="_blank" rel="noopener">未定义行为</a>.。</p><p>In this noncompliant code example, <code>pos</code> is invalidated after the first call to <code>insert()</code>, and subsequent loop iterations have <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-undefinedbehavior" target="_blank" rel="noopener">undefined behavior</a>.</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span> *items, <span class="built_in">std</span>::<span class="keyword">size_t</span> count)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">double</span>&gt; d;</span><br><span class="line">  <span class="keyword">auto</span> pos = d.<span class="built_in">begin</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; count; ++i, ++pos) &#123;</span><br><span class="line">    d.insert(pos, items[i] + <span class="number">41.0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="合规方案-Updated-Iterator-Compliant-Solution-Updated-Iterator"><a class="header-anchor" href="#合规方案-Updated-Iterator-Compliant-Solution-Updated-Iterator">¶</a>合规方案 (Updated Iterator) Compliant Solution (Updated Iterator)</h2><p>在这个合规方案中，每次迭代，<code>pos</code> 被重新分配了有效的迭代器，避免了未定义行为。</p><p>In this compliant solution, <code>pos</code> is assigned a valid iterator on each insertion, preventing undefined behavior.</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span> *items, <span class="built_in">std</span>::<span class="keyword">size_t</span> count)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">double</span>&gt; d;</span><br><span class="line">  <span class="keyword">auto</span> pos = d.<span class="built_in">begin</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; count; ++i, ++pos) &#123;</span><br><span class="line">    pos = d.insert(pos, items[i] + <span class="number">41.0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="合规方案-Generic-Algorithm-Compliant-Solution-Generic-Algorithm"><a class="header-anchor" href="#合规方案-Generic-Algorithm-Compliant-Solution-Generic-Algorithm">¶</a>合规方案 (Generic Algorithm) Compliant Solution (Generic Algorithm)</h2><p>这个合规方案用通用标准模板库算法 <code>std::transform()</code> 替换了手写循环。<code>std::transform()</code> 的函数调用接受转换的元素范围，被转换值存储的位置 (这里是一个用于在 <code>d</code> 的起始位置插入这些值的 <code>std::inserter</code> 对象)，应用的转换函数 (这里是一个简单的 lambda 表达式)。</p><p>This compliant solution replaces the handwritten loop with the generic standard template library algorithm <code>std::transform()</code>. The call to <code>std::transform()</code> accepts the range of elements to transform, the location to store the transformed values (which, in this case, is a <code>std::inserter</code> object to insert them at the beginning of <code>d</code>), and the transformation function to apply (which, in this case, is a simple lambda).</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span> *items, <span class="built_in">std</span>::<span class="keyword">size_t</span> count)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">double</span>&gt; d;</span><br><span class="line">  <span class="built_in">std</span>::transform(items, items + count, <span class="built_in">std</span>::inserter(d, d.<span class="built_in">begin</span>()),</span><br><span class="line">                 [](<span class="keyword">double</span> d) &#123; <span class="keyword">return</span> d + <span class="number">41.0</span>; &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="风险评估-Risk-Assessment"><a class="header-anchor" href="#风险评估-Risk-Assessment">¶</a>风险评估 Risk Assessment</h2><p>使用指向容器内元素的无效的引用，指针，或者迭代器将导致未定义行为。</p><p>Using invalid references, pointers, or iterators to reference elements of a container results in undefined behavior.</p><table><thead><tr><th style="text-align:left">Rule</th><th style="text-align:left">Severity</th><th style="text-align:left">Likelihood</th><th style="text-align:left">Remediation Cost</th><th style="text-align:left">Priority</th><th style="text-align:left">Level</th></tr></thead><tbody><tr><td style="text-align:left">CTR51-CPP</td><td style="text-align:left">High</td><td style="text-align:left">Probable</td><td style="text-align:left">High</td><td style="text-align:left"><strong>P6</strong></td><td style="text-align:left"><strong>L2</strong></td></tr></tbody></table><h2 id="Automated-Detection"><a class="header-anchor" href="#Automated-Detection">¶</a>Automated Detection</h2><table><thead><tr><th style="text-align:left">Tool</th><th style="text-align:left">Version</th><th style="text-align:left">Checker</th><th style="text-align:left">Description</th></tr></thead><tbody><tr><td style="text-align:left"><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/Parasoft" target="_blank" rel="noopener">Parasoft C/C++test</a></td><td style="text-align:left"><img data-src="https://wiki.sei.cmu.edu/confluence/plugins/servlet/confluence/placeholder/macro?definition=e2luY2x1ZGU6UGFyYXNvZnRfVn0&amp;locale=zh_CN&amp;version=2" alt="img"></td><td style="text-align:left"><strong>CERT_CPP-CTR51-a</strong></td><td style="text-align:left">Do not modify container while iterating over it</td></tr><tr><td style="text-align:left"><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/PVS-Studio" target="_blank" rel="noopener">PVS-Studio</a></td><td style="text-align:left"><img data-src="https://wiki.sei.cmu.edu/confluence/plugins/servlet/confluence/placeholder/macro?definition=e2luY2x1ZGU6UFZTLVN0dWRpb19WfQ&amp;locale=zh_CN&amp;version=2" alt="img"></td><td style="text-align:left"><strong><a href="https://www.viva64.com/en/w/v783/" target="_blank" rel="noopener">V783</a></strong></td><td style="text-align:left"></td></tr></tbody></table><h2 id="Related-Vulnerabilities"><a class="header-anchor" href="#Related-Vulnerabilities">¶</a>Related Vulnerabilities</h2><p>Search for <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-vulnerabil" target="_blank" rel="noopener">vulnerabilities</a> resulting from the violation of this rule on the <a href="https://www.kb.cert.org/vulnotes/bymetric?searchview&amp;query=FIELD+KEYWORDS+contains+CTR51-CPP" target="_blank" rel="noopener">CERT website</a>.</p><h2 id="Related-Guidelines"><a class="header-anchor" href="#Related-Guidelines">¶</a>Related Guidelines</h2><table><thead><tr><th style="text-align:left"><a href="https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=88046682" target="_blank" rel="noopener">SEI CERT C++ Coding Standard</a></th><th style="text-align:left"><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/STR52-CPP.+Use+valid+references%2C+pointers%2C+and+iterators+to+reference+elements+of+a+basic_string" target="_blank" rel="noopener">STR52-CPP. Use valid references, pointers, and iterators to reference elements of a basic_string</a></th></tr></thead><tbody><tr><td style="text-align:left"></td><td style="text-align:left"></td></tr></tbody></table><h2 id="Bibliography"><a class="header-anchor" href="#Bibliography">¶</a>Bibliography</h2><table><thead><tr><th style="text-align:left">[<a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-ISO/IEC14882-2014" target="_blank" rel="noopener">ISO/IEC 14882-2014</a>]</th><th style="text-align:left">Clause 23, “Containers Library” Subclause 24.2.1, “In General”</th></tr></thead><tbody><tr><td style="text-align:left">[<a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-Kalev99" target="_blank" rel="noopener">Kalev 1999</a>]</td><td style="text-align:left"><em>ANSI/ISO C++ Professional Programmer’s Handbook</em></td></tr><tr><td style="text-align:left">[<a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-Meyers01" target="_blank" rel="noopener">Meyers 2001</a>]</td><td style="text-align:left">Item 43, “Prefer Algorithm Calls to Handwritten Loops”</td></tr><tr><td style="text-align:left">[<a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-Sutter04" target="_blank" rel="noopener">Sutter 2004</a>]</td><td style="text-align:left">Item 84, “Prefer Algorithm Calls to Handwritten Loops”</td></tr></tbody></table><hr><p><a href="https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=88046704" target="_blank" rel="noopener"><img data-src="https://wiki.sei.cmu.edu/confluence/download/attachments/88046682/button_arrow_left.png?version=1&amp;modificationDate=1216910800000&amp;api=v2" alt="SEI CERT C++ Coding Standard &gt; SEI CERT C++ Coding Standard &gt; button_arrow_left.png"></a><a href="https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=88046331" target="_blank" rel="noopener"><img data-src="https://wiki.sei.cmu.edu/confluence/download/attachments/88046682/button_arrow_up.png?version=1&amp;modificationDate=1216910618000&amp;api=v2" alt="SEI CERT C++ Coding Standard &gt; SEI CERT C++ Coding Standard &gt; button_arrow_up.png"></a><a href="https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=88046690" target="_blank" rel="noopener"><img data-src="https://wiki.sei.cmu.edu/confluence/download/attachments/88046682/button_arrow_right.png?version=1&amp;modificationDate=1216910815000&amp;api=v2" alt="SEI CERT C++ Coding Standard &gt; SEI CERT C++ Coding Standard &gt; button_arrow_right.png"></a></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>SEI CERT C++</category>
      </categories>
      <tags>
        <tag>SEI CERT C++</tag>
        <tag>编码规范</tag>
        <tag>翻译</tag>
        <tag>CERT Containers</tag>
      </tags>
  </entry>
  <entry>
    <title>CTR50-CPP. 保证容器索引和迭代器在有效范围内</title>
    <url>/posts/2396132143/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><!-- build time:Sat Nov 13 2021 15:45:21 GMT+0000 (Coordinated Universal Time) --><p>原文链接：</p><p><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/CTR50-CPP.+Guarantee+that+container+indices+and+iterators+are+within+the+valid+range" target="_blank" rel="noopener">CTR50-CPP. 保证容器索引和迭代器在有效范围内</a></p><p><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/CTR50-CPP.+Guarantee+that+container+indices+and+iterators+are+within+the+valid+range" target="_blank" rel="noopener">https://wiki.sei.cmu.edu/confluence/display/cplusplus/CTR50-CPP.+Guarantee+that+container+indices+and+iterators+are+within+the+valid+range</a></p><a id="more"></a><p>保证数据引用在数据的边界范围内是程序员一定要负全责的。同理，当程序员使用标准模板容器库，也需要确保索引在容器范围之内。</p><p>Ensuring that array references are within the bounds of the array is almost entirely the responsibility of the programmer. Likewise, when using standard template library vectors, the programmer is responsible for ensuring integer indexes are within the bounds of the vector.</p><h2 id="不合规代码示例（指针）-Noncompliant-Code-Example-Pointers"><a class="header-anchor" href="#不合规代码示例（指针）-Noncompliant-Code-Example-Pointers">¶</a>不合规代码示例（指针） Noncompliant Code Example (Pointers)</h2><p>这个不合规代码示例展示了一个函数，<code>insert_in_table()</code>，包含两个 <code>int</code> 参数，<code>pos</code> 和 <code>value</code>，会受来自不可信源的数据影响。函数执行了范围检查以确保 <code>pos</code> 不会超出数组的上界，由 <code>tableSize</code> 指定，但是未检查下界。因为 <code>pos</code> 被声明为一个 (signed) <code>int</code>，这个参数可以设想为一个负数，导致一次超出 <code>table</code> 引用的内存范围的写入。</p><p>This noncompliant code example shows a function, <code>insert_in_table()</code>, that has two <code>int</code> parameters, <code>pos</code> and <code>value</code>, both of which can be influenced by data originating from untrusted sources. The function performs a range check to ensure that <code>pos</code> does not exceed the upper bound of the array, specified by <code>tableSize</code>, but fails to check the lower bound. Because <code>pos</code> is declared as a (signed) <code>int</code>, this parameter can assume a negative value, resulting in a write outside the bounds of the memory referenced by <code>table</code>.</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstddef&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_in_table</span><span class="params">(<span class="keyword">int</span> *table, <span class="built_in">std</span>::<span class="keyword">size_t</span> tableSize, <span class="keyword">int</span> pos, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (pos &gt;= tableSize) &#123;</span><br><span class="line">    <span class="comment">// Handle error</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  table[pos] = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="合规的方案-size-t-Compliant-Solution-size-t"><a class="header-anchor" href="#合规的方案-size-t-Compliant-Solution-size-t">¶</a>合规的方案 (<code>size_t</code>) Compliant Solution (<code>size_t</code>)</h2><p>这个合规的方案中，参数 <code>pos</code> 被声明为 <code>size_t</code>，可以避免传入负值变量。</p><p>In this compliant solution, the parameter <code>pos</code> is declared as <code>size_t</code>, which prevents the passing of negative arguments.</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstddef&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_in_table</span><span class="params">(<span class="keyword">int</span> *table, <span class="built_in">std</span>::<span class="keyword">size_t</span> tableSize, <span class="built_in">std</span>::<span class="keyword">size_t</span> pos, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (pos &gt;= tableSize) &#123;</span><br><span class="line">    <span class="comment">// Handle error</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  table[pos] = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="合规的方案-Non-Type-Templates-Compliant-Solution-Non-Type-Templates"><a class="header-anchor" href="#合规的方案-Non-Type-Templates-Compliant-Solution-Non-Type-Templates">¶</a>合规的方案 (Non-Type Templates) Compliant Solution (Non-Type Templates)</h2><p>无类型模板可以被用来定义接收一个数组类型的函数，数组边界可以编译器推导。这个合规的方案与先前需要在调用 <code>insert_in_table</code> 时额外提供一个已知边界的边界检查方案，在功能上等价的。</p><p>Non-type templates can be used to define functions accepting an array type where the array bounds are deduced at compile time. This compliant solution is functionally equivalent to the previous bounds-checking one except that it additionally supports calling <code>insert_in_table()</code> with an array of known bounds.</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstddef&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;new&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_in_table</span><span class="params">(<span class="keyword">int</span> *table, <span class="built_in">std</span>::<span class="keyword">size_t</span> tableSize, <span class="built_in">std</span>::<span class="keyword">size_t</span> pos, <span class="keyword">int</span> value)</span> </span>&#123; <span class="comment">// #1</span></span><br><span class="line">  <span class="keyword">if</span> (pos &gt;= tableSize) &#123;</span><br><span class="line">    <span class="comment">// Handle error</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  table[pos] = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="built_in">std</span>::<span class="keyword">size_t</span> N&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_in_table</span><span class="params">(<span class="keyword">int</span> (&amp;table)[N], <span class="built_in">std</span>::<span class="keyword">size_t</span> pos, <span class="keyword">int</span> value)</span> </span>&#123; <span class="comment">// #2</span></span><br><span class="line">  insert_in_table(table, N, pos, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Exposition only</span></span><br><span class="line">  <span class="keyword">int</span> table1[<span class="number">100</span>];</span><br><span class="line">  <span class="keyword">int</span> *table2 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];</span><br><span class="line">  insert_in_table(table1, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">// Calls #2</span></span><br><span class="line">  insert_in_table(table2, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">// Error, no matching function call</span></span><br><span class="line">  insert_in_table(table1, <span class="number">100</span>, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">// Calls #1</span></span><br><span class="line">  insert_in_table(table2, <span class="number">100</span>, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">// Calls #1</span></span><br><span class="line">  <span class="keyword">delete</span> [] table2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="不合规代码示例-std-vector-Noncompliant-Code-Example-std-vector"><a class="header-anchor" href="#不合规代码示例-std-vector-Noncompliant-Code-Example-std-vector">¶</a>不合规代码示例 (<code>std::vector</code>) Noncompliant Code Example (<code>std::vector</code>)</h2><p>在这个不合规的代码示例中，<code>std::vector</code> 被用来替换指针和尺寸。这个函数执行一次范围检查确保 <code>pos</code> 不会超出容器的上边界。因为 <code>pos</code> 被声明为一个 (signed) <code>long long</code>，这个参数可以是负数。在把 <code>std::vector::size_type</code> 以 <code>unsigned int</code> 来实现的系统中 (例如 <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-msvc" target="_blank" rel="noopener">Microsoft Visual Studio</a>2013)，对于比较表达式，一般的算数转换会被用来将无符号值转换为有符号值。如果 <code>pos</code> 是一个负值， 这次比较将不会失败，当负值在索引操作中被解释为一个大的无符号值，将导致一次 <code>std::vector</code> 对象的越界写入。</p><p>In this noncompliant code example, a <code>std::vector</code> is used in place of a pointer and size pair. The function performs a range check to ensure that <code>pos</code> does not exceed the upper bound of the container. Because <code>pos</code> is declared as a (signed) <code>long long</code>, this parameter can assume a negative value. On systems where <code>std::vector::size_type</code> is ultimately implemented as an <code>unsigned int</code> (such as with <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-msvc" target="_blank" rel="noopener">Microsoft Visual Studio</a>2013), the usual arithmetic conversions applied for the comparison expression will convert the unsigned value to a signed value. If <code>pos</code> has a negative value, this comparison will not fail, resulting in a write outside the bounds of the <code>std::vector</code> object when the negative value is interpreted as a large unsigned value in the indexing operator.</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_in_table</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;table, <span class="keyword">long</span> <span class="keyword">long</span> pos, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (pos &gt;= table.<span class="built_in">size</span>()) &#123;</span><br><span class="line">    <span class="comment">// Handle error</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  table[pos] = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="合规方案-std-vector-size-t-Compliant-Solution-std-vector-size-t"><a class="header-anchor" href="#合规方案-std-vector-size-t-Compliant-Solution-std-vector-size-t">¶</a>合规方案 (<code>std::vector</code>, <code>size_t</code>) Compliant Solution (<code>std::vector</code>, <code>size_t</code>)</h2><p>在这个合规的方案中，参数 <code>pos</code> 被声明为 <code>size_t</code>，确保了当给定一个大的正数 (从一个负数变量转换而来)， 比较表达式执行失败。</p><p>In this compliant solution, the parameter <code>pos</code> is declared as <code>size_t</code>, which ensures that the comparison expression will fail when a large, positive value (converted from a negative argument) is given.</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_in_table</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;table, <span class="built_in">std</span>::<span class="keyword">size_t</span> pos, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (pos &gt;= table.<span class="built_in">size</span>()) &#123;</span><br><span class="line">    <span class="comment">// Handle error</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  table[pos] = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="合规的方案-std-vector-at-Compliant-Solution-std-vector-at"><a class="header-anchor" href="#合规的方案-std-vector-at-Compliant-Solution-std-vector-at">¶</a>合规的方案 (<code>std::vector::at()</code>) Compliant Solution (<code>std::vector::at()</code>)</h2><p>这个合规的方案中，通过 <code>at()</code> 方法来访问容器。这个方案提供了边界检查，如果 <code>pos</code> 不是一个有效的索引值时，抛出一个 <code>std::out_of_range</code> 异常。<code>insert_in_table()</code> 被定义为一个 <code>noexcept(false)</code> 函数，符合 <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/ERR55-CPP.+Honor+exception+specifications" target="_blank" rel="noopener">ERR55-CPP. Honor exception specifications</a> 。</p><p>In this compliant solution, access to the vector is accomplished with the <code>at()</code> method. This method provides bounds checking, throwing a <code>std::out_of_range</code> exception if <code>pos</code> is not a valid index value. The <code>insert_in_table()</code> function is declared with <code>noexcept(false)</code> in compliance with <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/ERR55-CPP.+Honor+exception+specifications" target="_blank" rel="noopener">ERR55-CPP. Honor exception specifications</a>.</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_in_table</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;table, <span class="built_in">std</span>::<span class="keyword">size_t</span> pos, <span class="keyword">int</span> value)</span> <span class="title">noexcept</span><span class="params">(<span class="literal">false</span>)</span> </span>&#123;</span><br><span class="line">  table.at(pos) = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="不合规代码示例-Iterrators-Noncompliant-Code-Example-Iterators"><a class="header-anchor" href="#不合规代码示例-Iterrators-Noncompliant-Code-Example-Iterators">¶</a>不合规代码示例 (Iterrators) Noncompliant Code Example (Iterators)</h2><p>在这个不合规的代码示例中，函数 <code>f_imp()</code> 给定了 (正确的) 容器尾迭代器 <code>e</code>，<code>b</code> 是同个容器的迭代器。然而，<code>b</code> 不在该容器的有效范围内也是有可能的。举个例子，如果容器是空的，<code>b</code> 将和 <code>e</code> 相等，导致不正确的引用。</p><p>In this noncompliant code example, the <code>f_imp()</code> function is given the (correct) ending iterator <code>e</code> for a container, and <code>b</code> is an iterator from the same container. However, it is possible that <code>b</code> is not within the valid range of its container. For instance, if the container were empty, <code>b</code> would equal <code>e</code> and be improperly dereferenced.</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ForwardIterator&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f_imp</span><span class="params">(ForwardIterator b, ForwardIterator e, <span class="keyword">int</span> val, <span class="built_in">std</span>::forward_iterator_tag)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    *b++ = val;</span><br><span class="line">  &#125; <span class="keyword">while</span> (b != e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ForwardIterator&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(ForwardIterator b, ForwardIterator e, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;ForwardIterator&gt;::iterator_category cat;</span><br><span class="line">  f_imp(b, e, val, cat);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="合规方案-Compliant-Solution"><a class="header-anchor" href="#合规方案-Compliant-Solution">¶</a>合规方案 Compliant Solution</h2><p>这个合规方案在试图解引用 <code>b</code> 前对迭代器有效性做了测试。</p><p>This compliant solution tests for iterator validity before attempting to dereference <code>b.</code></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ForwardIterator&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f_imp</span><span class="params">(ForwardIterator b, ForwardIterator e, <span class="keyword">int</span> val, <span class="built_in">std</span>::forward_iterator_tag)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (b != e) &#123;</span><br><span class="line">    *b++ = val;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ForwardIterator&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(ForwardIterator b, ForwardIterator e, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;ForwardIterator&gt;::iterator_category cat;</span><br><span class="line">  f_imp(b, e, val, cat);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Risk-Assessment"><a class="header-anchor" href="#Risk-Assessment">¶</a>Risk Assessment</h2><p>Using an invalid array or container index can result in an arbitrary memory overwrite or <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-abnormaltermination" target="_blank" rel="noopener">abnormal program termination</a>.</p><table><thead><tr><th style="text-align:left">Rule</th><th style="text-align:left">Severity</th><th style="text-align:left">Likelihood</th><th style="text-align:left">Remediation Cost</th><th style="text-align:left">Priority</th><th style="text-align:left">Level</th></tr></thead><tbody><tr><td style="text-align:left">CTR50-CPP</td><td style="text-align:left">High</td><td style="text-align:left">Likely</td><td style="text-align:left">High</td><td style="text-align:left"><strong>P9</strong></td><td style="text-align:left"><strong>L2</strong></td></tr></tbody></table><h2 id="Automated-Detection"><a class="header-anchor" href="#Automated-Detection">¶</a>Automated Detection</h2><table><thead><tr><th style="text-align:left">Tool</th><th style="text-align:left">Version</th><th style="text-align:left">Checker</th><th style="text-align:left">Description</th></tr></thead><tbody><tr><td style="text-align:left"><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/CodeSonar" target="_blank" rel="noopener">CodeSonar</a></td><td style="text-align:left">5.3p0</td><td style="text-align:left">**<a href="http://LANG.MEM.BO" target="_blank" rel="noopener">LANG.MEM.BO</a> LANG.MEM.BU <a href="http://LANG.MEM.TO" target="_blank" rel="noopener">LANG.MEM.TO</a> LANG.MEM.TU **<strong>LANG.MEM.TBA *</strong>*LANG.STRUCT.PBB ****LANG.STRUCT.PPE**</td><td style="text-align:left">Buffer overrun Buffer underrun Type overrun Type underrun Tainted buffer access Pointer before beginning of object Pointer past end of object</td></tr><tr><td style="text-align:left"><a href="https://www.securecoding.cert.org/confluence/display/cplusplus/Klocwork" target="_blank" rel="noopener">Klocwork</a></td><td style="text-align:left">2018</td><td style="text-align:left"><strong><a href="https://support.roguewave.com/documentation/klocwork/en/current/certcandcsecurecodingstandardidsmappedtoklocworkcandccheckers/" target="_blank" rel="noopener">ABV.ANY_SIZE_ARRAY</a></strong> <strong><a href="https://support.roguewave.com/documentation/klocwork/en/current/certcandcsecurecodingstandardidsmappedtoklocworkcandccheckers/" target="_blank" rel="noopener">ABV.GENERAL</a></strong> <strong><a href="https://support.roguewave.com/documentation/klocwork/en/current/certcandcsecurecodingstandardidsmappedtoklocworkcandccheckers/" target="_blank" rel="noopener">ABV.STACK</a></strong> <strong><a href="https://support.roguewave.com/documentation/klocwork/en/current/certcandcsecurecodingstandardidsmappedtoklocworkcandccheckers/" target="_blank" rel="noopener">ABV.TAINTED</a></strong> <strong><a href="https://support.roguewave.com/documentation/klocwork/en/current/certcandcsecurecodingstandardidsmappedtoklocworkcandccheckers/" target="_blank" rel="noopener">SV.TAINTED.ALLOC_SIZE</a></strong> <strong><a href="https://support.roguewave.com/documentation/klocwork/en/current/certcandcsecurecodingstandardidsmappedtoklocworkcandccheckers/" target="_blank" rel="noopener">SV.TAINTED.CALL.INDEX_ACCESS</a></strong> <strong><a href="https://support.roguewave.com/documentation/klocwork/en/current/certcandcsecurecodingstandardidsmappedtoklocworkcandccheckers/" target="_blank" rel="noopener">SV.TAINTED.CALL.LOOP_BOUND</a></strong> <strong><a href="https://support.roguewave.com/documentation/klocwork/en/current/certcandcsecurecodingstandardidsmappedtoklocworkcandccheckers/" target="_blank" rel="noopener">SV.TAINTED.INDEX_ACCESS</a></strong></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/LDRA" target="_blank" rel="noopener">LDRA tool suite</a></td><td style="text-align:left">9.7.1</td><td style="text-align:left"><strong>45 D, 47 S, 476 S, 489 S, 64 X, 66 X, 68 X, 69 X, 70 X, 71 X, 79 X**</strong> **</td><td style="text-align:left">Partially implemented</td></tr><tr><td style="text-align:left"><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/Parasoft" target="_blank" rel="noopener">Parasoft C/C++test</a></td><td style="text-align:left">10.4.2</td><td style="text-align:left"><strong>CERT_CPP-CTR50-a</strong></td><td style="text-align:left">Guarantee that container indices are within the valid range</td></tr><tr><td style="text-align:left"><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/Polyspace+Bug+Finder" target="_blank" rel="noopener">Polyspace Bug Finder</a></td><td style="text-align:left">R2020a</td><td style="text-align:left"><a href="https://www.mathworks.com/help/bugfinder/ref/certcctr50cpp.html" target="_blank" rel="noopener">CERT C++: CTR50-CPP</a></td><td style="text-align:left">Checks for:Array access out of boundsArray access with tainted indexPointer dereference with tainted offsetRule partially covered.</td></tr><tr><td style="text-align:left"><a href="https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=88046345" target="_blank" rel="noopener">PRQA QA-C++</a></td><td style="text-align:left">4.4</td><td style="text-align:left"><strong>2891, 3139, 3140</strong></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/PVS-Studio" target="_blank" rel="noopener">PVS-Studio</a></td><td style="text-align:left">7.07</td><td style="text-align:left"><strong><a href="https://www.viva64.com/en/w/v781/" target="_blank" rel="noopener">V781</a></strong></td><td style="text-align:left"></td></tr></tbody></table><h2 id="Related-Vulnerabilities"><a class="header-anchor" href="#Related-Vulnerabilities">¶</a>Related Vulnerabilities</h2><p>Search for <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-vulnerabi" target="_blank" rel="noopener">vulnerabilities</a> resulting from the violation of this rule on the <a href="https://www.kb.cert.org/vulnotes/bymetric?searchview&amp;query=FIELD+KEYWORDS+contains+CTR50-CPP" target="_blank" rel="noopener">CERT website</a>.</p><h2 id="Related-Guidelines"><a class="header-anchor" href="#Related-Guidelines">¶</a>Related Guidelines</h2><table><thead><tr><th><a href="https://wiki.sei.cmu.edu/confluence/display/c/SEI+CERT+C+Coding+Standard" target="_blank" rel="noopener">SEI CERT C Coding Standard</a></th><th><a href="https://wiki.sei.cmu.edu/confluence/display/c/ARR30-C.+Do+not+form+or+use+out-of-bounds+pointers+or+array+subscripts" target="_blank" rel="noopener">ARR30-C. Do not form or use out-of-bounds pointers or array subscripts</a></th></tr></thead><tbody><tr><td><a href="http://cwe.mitre.org/" target="_blank" rel="noopener">MITRE CWE</a></td><td><a href="http://cwe.mitre.org/data/definitions/119.html" target="_blank" rel="noopener">CWE 119</a>, Failure to Constrain Operations within the Bounds of a Memory Buffer <a href="http://cwe.mitre.org/data/definitions/129.html" target="_blank" rel="noopener">CWE 129</a>, Improper Validation of Array Index</td></tr></tbody></table><h2 id="Bibliography"><a class="header-anchor" href="#Bibliography">¶</a>Bibliography</h2><table><thead><tr><th>[<a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-ISO/IEC14882-2014" target="_blank" rel="noopener">ISO/IEC 14882-2014</a>]</th><th>Clause 23, “Containers Library” Subclause 24.2.1, “In General”</th></tr></thead><tbody><tr><td>[<a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-ISO/IECTR24772-2013" target="_blank" rel="noopener">ISO/IEC TR 24772-2013</a>]</td><td>Boundary Beginning Violation [XYX] Wrap-Around Error [XYY] Unchecked Array Indexing [XYZ]</td></tr><tr><td>[<a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-Viega05" target="_blank" rel="noopener">Viega 2005</a>]</td><td>Section 5.2.13, “Unchecked Array Indexing”</td></tr></tbody></table><hr><p><a href="https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=88046331" target="_blank" rel="noopener"><img data-src="https://wiki.sei.cmu.edu/confluence/download/attachments/88046682/button_arrow_left.png?version=1&amp;modificationDate=1216910800000&amp;api=v2" alt="img"></a><a href="https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=88046331" target="_blank" rel="noopener"><img data-src="https://wiki.sei.cmu.edu/confluence/download/attachments/88046682/button_arrow_up.png?version=1&amp;modificationDate=1216910618000&amp;api=v2" alt="img"></a><a href="https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=88046457" target="_blank" rel="noopener"><img data-src="https://wiki.sei.cmu.edu/confluence/download/attachments/88046682/button_arrow_right.png?version=1&amp;modificationDate=1216910815000&amp;api=v2" alt="img"></a></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>SEI CERT C++</category>
      </categories>
      <tags>
        <tag>SEI CERT C++</tag>
        <tag>编码规范</tag>
        <tag>翻译</tag>
        <tag>CERT Containers</tag>
      </tags>
  </entry>
  <entry>
    <title>自动驾驶仿真 - AirSim (9) - 如何在 AirSim 使用雷达</title>
    <url>/posts/954477841/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><!-- build time:Sat Nov 13 2021 15:45:21 GMT+0000 (Coordinated Universal Time) --><p>针对载具和汽车，AirSim 支持雷达。</p><a id="more"></a><p>可用及其他雷达设定可以通过 AirSimSettings json 配置.<br>请查看 <a href="sensors.md">general sensors</a> 获取通用/共享的传感器设置.</p><h2 id="在汽车上使能雷达-Enabling-lidar-on-a-vehicle"><a class="header-anchor" href="#在汽车上使能雷达-Enabling-lidar-on-a-vehicle">¶</a>在汽车上使能雷达 Enabling lidar on a vehicle</h2><ul><li>雷达默认是不可用的。 为了使用雷达， 在 settings json 中设定雷达 SensorType 和 Enabled 属性.</li></ul><figure class="highlight"><table><tr><td class="code"><pre><span class="line">"Lidar1": &#123;</span><br><span class="line">     "SensorType": 6,</span><br><span class="line">     "Enabled" : true,</span><br></pre></td></tr></table></figure><ul><li>汽车多雷达也可用.</li></ul><h2 id="雷达配置-Lidar-configuration"><a class="header-anchor" href="#雷达配置-Lidar-configuration">¶</a>雷达配置 Lidar configuration</h2><p>目前，下列参数可通过 setting json 来配置.</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>NumberOfChannels</td><td>雷达的激光/通道数目</td></tr><tr><td>Range</td><td>范围， 米值</td></tr><tr><td>PointsPerSecond</td><td>每秒捕捉的点数</td></tr><tr><td>RotationsPerSecond</td><td>每秒旋转角度</td></tr><tr><td>HorizontalFOVStart</td><td>雷达初始 Horizontal FOV, 角度制</td></tr><tr><td>HorizontalFOVEnd</td><td>雷达终止 Horizontal FOV, 角度制</td></tr><tr><td>VerticalFOVUpper</td><td>雷达 Vertical FOV 上限, 角度制</td></tr><tr><td>VerticalFOVLower</td><td>雷达 Vertical FOV 下限, 角度制</td></tr><tr><td>X Y Z</td><td>雷达相对于汽车的位置 (NED 坐标系, 米制)</td></tr><tr><td>Roll Pitch Yaw</td><td>雷达相对于汽车的方向 (角度制, 沿 +X 方向的 yaw-pitch-roll)</td></tr><tr><td>DataFrame</td><td>输出的数据坐标系 (“VehicleInertialFrame” 或 “SensorLocalFrame”)</td></tr></tbody></table><p>例如,</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"SeeDocsAt"</span>: <span class="string">"https://github.com/Microsoft/AirSim/blob/master/docs/settings_json.md"</span>,</span><br><span class="line">  <span class="attr">"SettingsVersion"</span>: <span class="number">1.2</span>,</span><br><span class="line"></span><br><span class="line">  <span class="attr">"SimMode"</span>: <span class="string">"Multirotor"</span>,</span><br><span class="line"></span><br><span class="line">  <span class="attr">"Vehicles"</span>: &#123;</span><br><span class="line">    <span class="attr">"Drone1"</span>: &#123;</span><br><span class="line">      <span class="attr">"VehicleType"</span>: <span class="string">"simpleflight"</span>,</span><br><span class="line">      <span class="attr">"AutoCreate"</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">"Sensors"</span>: &#123;</span><br><span class="line">        <span class="attr">"LidarSensor1"</span>: &#123;</span><br><span class="line">          <span class="attr">"SensorType"</span>: <span class="number">6</span>,</span><br><span class="line">          <span class="attr">"Enabled"</span>: <span class="literal">true</span>,</span><br><span class="line">          <span class="attr">"NumberOfChannels"</span>: <span class="number">16</span>,</span><br><span class="line">          <span class="attr">"RotationsPerSecond"</span>: <span class="number">10</span>,</span><br><span class="line">          <span class="attr">"PointsPerSecond"</span>: <span class="number">100000</span>,</span><br><span class="line">          <span class="attr">"X"</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">"Y"</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">"Z"</span>: <span class="number">-1</span>,</span><br><span class="line">          <span class="attr">"Roll"</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">"Pitch"</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">"Yaw"</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">"VerticalFOVUpper"</span>: <span class="number">-15</span>,</span><br><span class="line">          <span class="attr">"VerticalFOVLower"</span>: <span class="number">-25</span>,</span><br><span class="line">          <span class="attr">"HorizontalFOVStart"</span>: <span class="number">-20</span>,</span><br><span class="line">          <span class="attr">"HorizontalFOVEnd"</span>: <span class="number">20</span>,</span><br><span class="line">          <span class="attr">"DrawDebugPoints"</span>: <span class="literal">true</span>,</span><br><span class="line">          <span class="attr">"DataFrame"</span>: <span class="string">"SensorLocalFrame"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"LidarSensor2"</span>: &#123;</span><br><span class="line">          <span class="attr">"SensorType"</span>: <span class="number">6</span>,</span><br><span class="line">          <span class="attr">"Enabled"</span>: <span class="literal">true</span>,</span><br><span class="line">          <span class="attr">"NumberOfChannels"</span>: <span class="number">4</span>,</span><br><span class="line">          <span class="attr">"RotationsPerSecond"</span>: <span class="number">10</span>,</span><br><span class="line">          <span class="attr">"PointsPerSecond"</span>: <span class="number">10000</span>,</span><br><span class="line">          <span class="attr">"X"</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">"Y"</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">"Z"</span>: <span class="number">-1</span>,</span><br><span class="line">          <span class="attr">"Roll"</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">"Pitch"</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">"Yaw"</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">"VerticalFOVUpper"</span>: <span class="number">-15</span>,</span><br><span class="line">          <span class="attr">"VerticalFOVLower"</span>: <span class="number">-25</span>,</span><br><span class="line">          <span class="attr">"DrawDebugPoints"</span>: <span class="literal">true</span>,</span><br><span class="line">          <span class="attr">"DataFrame"</span>: <span class="string">"SensorLocalFrame"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="用于调试的服务端可视化-Server-side-visualization-for-debugging"><a class="header-anchor" href="#用于调试的服务端可视化-Server-side-visualization-for-debugging">¶</a>用于调试的服务端可视化 Server side visualization for debugging</h2><p>默认情况下，雷达点不会被绘制在视图中。 为了能够在视图中绘制激光扫描点， 请通过 settings json 使能 <code>DrawDebugPoints</code>.<br>例如,</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">"Lidar1": &#123;</span><br><span class="line">     ...</span><br><span class="line">     "DrawDebugPoints": true</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h2 id="客户端-API-Client-API"><a class="header-anchor" href="#客户端-API-Client-API">¶</a>客户端 API Client API</h2><p>使用 <code>getLidarData()</code> API 来获取雷达数据.</p><ul><li>这个 API 返回带捕捉时间戳和雷达位置的平面阵列的浮点数数组.</li><li>点云:<ul><li>浮点数表示每个在范围之类最后扫描到的 [x,y,z] 坐标.</li><li>输出的数据帧可以通过 “DataFrame” 属性来配置。<br>“” 或者 “VehicleInertialFrame” – 默认; 返回汽车惯性坐标系下的点 (NED 坐标系, 米制)<br>“SensorLocalFrame” – 返回雷达局部坐标系下的点 (NED 坐标系, 米制)</li></ul></li><li>雷达位姿:<ul><li>在汽车惯性坐标系下的雷达位姿 (NED 坐标系, 米制)</li><li>可以转换到其他坐标系下的点.</li></ul></li></ul><h3 id="Python-例程-Python-Examples"><a class="header-anchor" href="#Python-例程-Python-Examples">¶</a>Python 例程 Python Examples</h3><p><a href="https://github.com/Microsoft/AirSim/tree/master/PythonClient//multirotor" target="_blank" rel="noopener">drone_lidar.py</a><br><a href="https://github.com/Microsoft/AirSim/tree/master/PythonClient//car" target="_blank" rel="noopener">car_lidar.py</a></p><h2 id="即将到来"><a class="header-anchor" href="#即将到来">¶</a>即将到来</h2><ul><li>客户端的雷达数据可视化.</li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>自动驾驶</category>
      </categories>
      <tags>
        <tag>自动驾驶</tag>
        <tag>AirSim</tag>
      </tags>
  </entry>
  <entry>
    <title>自动驾驶仿真 - AirSim (8) - AirSim 传感器</title>
    <url>/posts/3783722863/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><!-- build time:Sat Nov 13 2021 15:45:21 GMT+0000 (Coordinated Universal Time) --><p>AirSim 目前支持一下传感器.</p><a id="more"></a><p>每类传感器都与之关联一个整型枚举值来表示传感器类型.</p><ul><li>Camera</li><li>Barometer = 1</li><li>Imu = 2</li><li>Gps = 3</li><li>Magnetometer = 4</li><li>Distance Sensor = 5</li><li>Lidar = 6</li></ul><p><strong>注意</strong> : 相机配置与其他传感器不一样,所以没有关联枚举值. 相机配置和 API 查看 <a href="settings.md">general settings</a> 和 <a href="image_apis.md">image API</a> .</p><h2 id="默认传感器-Default-sensors"><a class="header-anchor" href="#默认传感器-Default-sensors">¶</a>默认传感器 Default sensors</h2><p>如果没有在 <code>settings.json</code> 指定传感器, 基于 sim 模式下,下列传感器默认可用.</p><h3 id="载具-Multirotor"><a class="header-anchor" href="#载具-Multirotor">¶</a>载具 Multirotor</h3><ul><li>Imu</li><li>Magnetometer</li><li>Gps</li><li>Barometer</li></ul><h3 id="车-Car"><a class="header-anchor" href="#车-Car">¶</a>车 Car</h3><ul><li>Gps</li></ul><h3 id="计算机视觉-ComputerVision"><a class="header-anchor" href="#计算机视觉-ComputerVision">¶</a>计算机视觉 ComputerVision</h3><ul><li>None</li></ul><p>场景之后, <a href="https://github.com/Microsoft/AirSim/blob/master/AirLib/include/common/AirSimSettings.hpp" target="_blank" rel="noopener">AirSimSettings.hpp</a> 中的 <code>createDefaultSensorSettings</code> 方法是用来设置上述带默认参数的传感器, 根据在 sim 模式在下 <code>settings.json</code> 文件设定的.</p><h2 id="配置默认传感器列表-Configuring-the-default-sensor-list"><a class="header-anchor" href="#配置默认传感器列表-Configuring-the-default-sensor-list">¶</a>配置默认传感器列表 Configuring the default sensor list</h2><p>默认传感器列表可以在 settings json 配置:</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">"DefaultSensors": &#123;</span><br><span class="line">    "Barometer": &#123;</span><br><span class="line">         "SensorType": 1,</span><br><span class="line">         "Enabled" : true</span><br><span class="line">    &#125;,</span><br><span class="line">    "Imu": &#123;</span><br><span class="line">         "SensorType": 2,</span><br><span class="line">         "Enabled" : true</span><br><span class="line">    &#125;,</span><br><span class="line">    "Gps": &#123;</span><br><span class="line">         "SensorType": 3,</span><br><span class="line">         "Enabled" : true</span><br><span class="line">    &#125;,</span><br><span class="line">    "Magnetometer": &#123;</span><br><span class="line">         "SensorType": 4,</span><br><span class="line">         "Enabled" : true</span><br><span class="line">    &#125;,</span><br><span class="line">    "Distance": &#123;</span><br><span class="line">         "SensorType": 5,</span><br><span class="line">         "Enabled" : true</span><br><span class="line">    &#125;,</span><br><span class="line">    "Lidar2": &#123;</span><br><span class="line">         "SensorType": 6,</span><br><span class="line">         "Enabled" : true,</span><br><span class="line">         "NumberOfChannels": 4,</span><br><span class="line">         "PointsPerSecond": 10000</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h2 id="配置汽车专用传感器列表-Configuring-vehicle-specific-sensor-list"><a class="header-anchor" href="#配置汽车专用传感器列表-Configuring-vehicle-specific-sensor-list">¶</a>配置汽车专用传感器列表 Configuring vehicle-specific sensor list</h2><p>如果载具提供他自己的传感器列表, 它<strong>必须</strong>提供完整的列表. <strong>不支持</strong> 选择性的增加/删除/更新默认传感器列表<br>汽车专用传感器列表可以在设置汽车的 json 部分设置.<br>即,</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line"> "Vehicles": &#123;</span><br><span class="line"></span><br><span class="line">     "Drone1": &#123;</span><br><span class="line">         "VehicleType": "SimpleFlight",</span><br><span class="line">         "AutoCreate": true,</span><br><span class="line">         ...</span><br><span class="line">         "Sensors": &#123;</span><br><span class="line">             "MyLidar1": &#123;</span><br><span class="line">                 "SensorType": 6,</span><br><span class="line">                 "Enabled" : true,</span><br><span class="line">                 "NumberOfChannels": 16,</span><br><span class="line">                 "PointsPerSecond": 10000,</span><br><span class="line">                 "X": 0, "Y": 0, "Z": -1,</span><br><span class="line">                 "DrawDebugPoints": true</span><br><span class="line">             &#125;,</span><br><span class="line">             "MyLidar2": &#123;</span><br><span class="line">                 "SensorType": 6,</span><br><span class="line">                 "Enabled" : true,</span><br><span class="line">                 "NumberOfChannels": 4,</span><br><span class="line">                 "PointsPerSecond": 10000,</span><br><span class="line">                 "X": 0, "Y": 0, "Z": -1,</span><br><span class="line">                 "DrawDebugPoints": true</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="传感器专用设置-Sensor-specific-settings"><a class="header-anchor" href="#传感器专用设置-Sensor-specific-settings">¶</a>传感器专用设置 Sensor specific settings</h3><p>每种传感器类型也有它自己的设置.</p><p>以雷达专用设定为例,请查看 <a href="lidar.md">lidar</a> .</p><h2 id="传感器-APIs-Sensor-APIs"><a class="header-anchor" href="#传感器-APIs-Sensor-APIs">¶</a>传感器 APIs Sensor APIs</h2><p>使用例程可直接跳转到 <a href="https://github.com/Microsoft/AirSim/blob/master/PythonClient/multirotor/hello_drone.py" target="_blank" rel="noopener"><code>hello_drone.py</code></a> 或 <a href="https://github.com/Microsoft/AirSim/blob/master/HelloDrone/main.cpp" target="_blank" rel="noopener"><code>hello_drone.cpp</code></a> , 或者浏览下述全部的 API.</p><ul><li><p>Barometer</p><p>C++</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">msr::airlib::<span class="function">BarometerBase::Output <span class="title">getBarometerData</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; barometer_name, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; vehicle_name)</span></span>;</span><br></pre></td></tr></table></figure><p>Python</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">barometer_data = getBarometerData(barometer_name = <span class="string">""</span>, vehicle_name = <span class="string">""</span>)</span><br></pre></td></tr></table></figure></li><li><p>IMU</p><p>C++</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">msr::airlib::<span class="function">ImuBase::Output <span class="title">getImuData</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; imu_name = <span class="string">""</span>, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; vehicle_name = <span class="string">""</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>Python</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">imu_data = getImuData(imu_name = <span class="string">""</span>, vehicle_name = <span class="string">""</span>)</span><br></pre></td></tr></table></figure></li><li><p>GPS</p><p>C++</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">msr::airlib::<span class="function">GpsBase::Output <span class="title">getGpsData</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; gps_name = <span class="string">""</span>, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; vehicle_name = <span class="string">""</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>Python</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">gps_data = getGpsData(gps_name = <span class="string">""</span>, vehicle_name = <span class="string">""</span>)</span><br></pre></td></tr></table></figure></li><li><p>Magnetometer</p><p>C++</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">msr::airlib::<span class="function">MagnetometerBase::Output <span class="title">getMagnetometerData</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; magnetometer_name = <span class="string">""</span>, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; vehicle_name = <span class="string">""</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>Python</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">magnetometer_data = getMagnetometerData(magnetometer_name = <span class="string">""</span>, vehicle_name = <span class="string">""</span>)</span><br></pre></td></tr></table></figure></li><li><p>Distance sensor</p><p>C++</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">msr::airlib::<span class="function">DistanceBase::Output <span class="title">getDistanceSensorData</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; distance_sensor_name = <span class="string">""</span>, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; vehicle_name = <span class="string">""</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>Python</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">distance_sensor_name = getDistanceSensorData(distance_sensor_name = <span class="string">""</span>, vehicle_name = <span class="string">""</span>)</span><br></pre></td></tr></table></figure></li><li><p>Lidar<br>See <a href="lidar.md">lidar</a> for Lidar API.</p></li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>自动驾驶</category>
      </categories>
      <tags>
        <tag>自动驾驶</tag>
        <tag>AirSim</tag>
      </tags>
  </entry>
  <entry>
    <title>自动驾驶仿真 - AirSim(7) - AirSim 多载具</title>
    <url>/posts/2251441435/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><!-- build time:Sat Nov 13 2021 15:45:21 GMT+0000 (Coordinated Universal Time) --><p>从 release 1.2 开始, AirSim 完全能够支持多载具. 这能允许你更简单的创建多个载具并用 APIs 来控制它们.</p><a id="more"></a><h2 id="创建多个载具-Creating-Multiple-Vehicles"><a class="header-anchor" href="#创建多个载具-Creating-Multiple-Vehicles">¶</a>创建多个载具 Creating Multiple Vehicles</h2><p>在 <a href="settings.md">settings.json</a> 可以很简单地对它们设定. <code>Vehicles</code> 元素允许你指定你想创建地载具列表, 包括初始位置和方向.位置是基于 SI 单位下的原点位于 Unreal 环境下玩家出生点的 NED 坐标系.方向基于角度制的偏航、俯仰和翻转.</p><h3 id="创建多辆汽车-Creating-Multiple-Cars"><a class="header-anchor" href="#创建多辆汽车-Creating-Multiple-Cars">¶</a>创建多辆汽车 Creating Multiple Cars</h3><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"SettingsVersion"</span>: <span class="number">1.2</span>,</span><br><span class="line">  <span class="attr">"SimMode"</span>: <span class="string">"Car"</span>,</span><br><span class="line"></span><br><span class="line">  <span class="attr">"Vehicles"</span>: &#123;</span><br><span class="line">    <span class="attr">"Car1"</span>: &#123;</span><br><span class="line">      <span class="attr">"VehicleType"</span>: <span class="string">"PhysXCar"</span>,</span><br><span class="line">      <span class="attr">"X"</span>: <span class="number">4</span>,</span><br><span class="line">      <span class="attr">"Y"</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">"Z"</span>: <span class="number">-2</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"Car2"</span>: &#123;</span><br><span class="line">      <span class="attr">"VehicleType"</span>: <span class="string">"PhysXCar"</span>,</span><br><span class="line">      <span class="attr">"X"</span>: <span class="number">-4</span>,</span><br><span class="line">      <span class="attr">"Y"</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">"Z"</span>: <span class="number">-2</span>,</span><br><span class="line">      <span class="attr">"Yaw"</span>: <span class="number">90</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建多个飞行器-Creating-Multiple-Drones"><a class="header-anchor" href="#创建多个飞行器-Creating-Multiple-Drones">¶</a>创建多个飞行器 Creating Multiple Drones</h3><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"SettingsVersion"</span>: <span class="number">1.2</span>,</span><br><span class="line">  <span class="attr">"SimMode"</span>: <span class="string">"Multirotor"</span>,</span><br><span class="line"></span><br><span class="line">  <span class="attr">"Vehicles"</span>: &#123;</span><br><span class="line">    <span class="attr">"Drone1"</span>: &#123;</span><br><span class="line">      <span class="attr">"VehicleType"</span>: <span class="string">"SimpleFlight"</span>,</span><br><span class="line">      <span class="attr">"X"</span>: <span class="number">4</span>,</span><br><span class="line">      <span class="attr">"Y"</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">"Z"</span>: <span class="number">-2</span>,</span><br><span class="line">      <span class="attr">"Yaw"</span>: <span class="number">-180</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"Drone2"</span>: &#123;</span><br><span class="line">      <span class="attr">"VehicleType"</span>: <span class="string">"SimpleFlight"</span>,</span><br><span class="line">      <span class="attr">"X"</span>: <span class="number">8</span>,</span><br><span class="line">      <span class="attr">"Y"</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">"Z"</span>: <span class="number">-2</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多载具的-APIs-使用-Using-APIs-for-Multiple-Vehicles"><a class="header-anchor" href="#多载具的-APIs-使用-Using-APIs-for-Multiple-Vehicles">¶</a>多载具的 APIs 使用 Using APIs for Multiple Vehicles</h2><p>从 AirSim 1.2 以来的新 APIs 允许你指定 <code>vehicle_name</code>. 这个名称和 json settings 的键值对应 (举个例子, 上述的 Car1 或 Drone2 ).</p><p><a href="https://github.com/Microsoft/AirSim/tree/master/PythonClient//car/multi_agent_car.py" target="_blank" rel="noopener">Example code for cars</a></p><p><a href="https://github.com/Microsoft/AirSim/tree/master/PythonClient//multirotor/multi_agent_drone.py" target="_blank" rel="noopener">Example code for multirotors</a></p><p><strong>PS:</strong> 这里提供一份 C++ 的实现</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> msr::airlib;</span><br><span class="line">msr::airlib::CarRpcLibClient client;</span><br><span class="line"></span><br><span class="line">client.confirmConnection();</span><br><span class="line">client.enableApiControl(<span class="literal">true</span>, <span class="string">"Car1"</span>);</span><br><span class="line">client.enableApiControl(<span class="literal">true</span>, <span class="string">"Car2"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> car_controls1 = client.getCarControls(<span class="string">"Car1"</span>);</span><br><span class="line"><span class="keyword">auto</span> car_controls2 = client.getCarControls(<span class="string">"Car2"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">  <span class="comment">// get state of the car</span></span><br><span class="line">  <span class="keyword">auto</span> car_state1 = client.getCarState(<span class="string">"Car1"</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Car1: Speed "</span> &lt;&lt; car_state1.speed &lt;&lt; <span class="string">", Gear "</span> &lt;&lt; car_state1.gear &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> car_state2 = client.getCarState(<span class="string">"Car2"</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Car1: Speed "</span> &lt;&lt; car_state2.speed &lt;&lt; <span class="string">", Gear "</span> &lt;&lt; car_state2.gear &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// go forward</span></span><br><span class="line">  car_controls1.throttle = <span class="number">0.5</span>;</span><br><span class="line">  car_controls2.throttle = <span class="number">0.5</span>;</span><br><span class="line">  client.setCarControls(car_controls1, <span class="string">"Car1"</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Car1: Go Forward.\n"</span>;</span><br><span class="line"></span><br><span class="line">  car_controls2.throttle = <span class="number">0.5</span>;</span><br><span class="line">  car_controls2.steering = <span class="number">-0.5</span>;</span><br><span class="line">  client.setCarControls(car_controls2, <span class="string">"Car2"</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Car2: Go Forward.\n"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// apply breaks</span></span><br><span class="line">  car_controls1.brake = <span class="number">1</span>;</span><br><span class="line">  client.setCarControls(car_controls1, <span class="string">"Car1"</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Car1: Apply break\n"</span>;</span><br><span class="line">  car_controls1.brake = <span class="number">0</span>;  <span class="comment">// remove break</span></span><br><span class="line"></span><br><span class="line">  car_controls2.brake = <span class="number">1</span>;</span><br><span class="line">  client.setCarControls(car_controls2, <span class="string">"Car2"</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Car2: Apply break\n"</span>;</span><br><span class="line">  car_controls2.brake = <span class="number">0</span>;  <span class="comment">// remove break</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">3</span>));  <span class="comment">// let car drive a bit</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;ImageCaptureBase::ImageResponse&gt;&amp; response1 =</span><br><span class="line">      client.simGetImages(&#123;ImageCaptureBase::ImageRequest(<span class="string">"0"</span>, ImageCaptureBase::ImageType::DepthVis),</span><br><span class="line">                           ImageCaptureBase::ImageRequest(<span class="string">"1"</span>, ImageCaptureBase::ImageType::Scene, <span class="literal">false</span>, <span class="literal">false</span>)&#125;,</span><br><span class="line">                          <span class="string">"Car1"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Car1: Retrieved images: "</span> &lt;&lt; response1.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;ImageCaptureBase::ImageResponse&gt;&amp; response2 =</span><br><span class="line">      client.simGetImages(&#123;ImageCaptureBase::ImageRequest(<span class="string">"0"</span>, ImageCaptureBase::ImageType::Segmentation),</span><br><span class="line">                           ImageCaptureBase::ImageRequest(<span class="string">"1"</span>, ImageCaptureBase::ImageType::Scene, <span class="literal">false</span>, <span class="literal">false</span>)&#125;,</span><br><span class="line">                          <span class="string">"Car2"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Car2: Retrieved images: "</span> &lt;&lt; response2.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  cv::Mat img_mat10 = cv::imdecode(response1.at(<span class="number">0</span>).image_data_uint8, cv::IMREAD_GRAYSCALE);</span><br><span class="line">  cv::imshow(<span class="string">"cat1_multi:DepthVis"</span>, img_mat10);</span><br><span class="line">  cv::waitKey(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function">cv::Mat <span class="title">img_mat11</span><span class="params">(response1.at(<span class="number">1</span>).<span class="built_in">height</span>, response1.at(<span class="number">1</span>).<span class="built_in">width</span>, CV_8UC3,</span></span></span><br><span class="line"><span class="function"><span class="params">                    (<span class="keyword">void</span>*)response1.at(<span class="number">1</span>).image_data_uint8.data())</span></span>;</span><br><span class="line">  cv::imshow(<span class="string">"cat1_multi:Scene"</span>, img_mat11);</span><br><span class="line">  cv::waitKey(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">  cv::Mat img_mat20 = cv::imdecode(response1.at(<span class="number">0</span>).image_data_uint8, cv::IMREAD_UNCHANGED);</span><br><span class="line">  cv::imshow(<span class="string">"cat2_multi:DepthVis"</span>, img_mat10);</span><br><span class="line">  cv::waitKey(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function">cv::Mat <span class="title">img_mat21</span><span class="params">(response2.at(<span class="number">1</span>).<span class="built_in">height</span>, response2.at(<span class="number">1</span>).<span class="built_in">width</span>, CV_8UC3,</span></span></span><br><span class="line"><span class="function"><span class="params">                    (<span class="keyword">void</span>*)response2.at(<span class="number">1</span>).image_data_uint8.data())</span></span>;</span><br><span class="line">  cv::imshow(<span class="string">"cat2_multi:Scene"</span>, img_mat21);</span><br><span class="line">  cv::waitKey(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">client.reset();</span><br><span class="line">client.enableApiControl(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h3 id="Demo"><a class="header-anchor" href="#Demo">¶</a>Demo</h3><p><a href="https://youtu.be/35dgcuLuF5M" target="_blank" rel="noopener"><img data-src="images/demo_multi_vehicles.png" alt="AirSimMultiple Vehicles Demo Video"></a></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>自动驾驶</category>
      </categories>
      <tags>
        <tag>自动驾驶</tag>
        <tag>AirSim</tag>
      </tags>
  </entry>
  <entry>
    <title>自动驾驶仿真 - AirSim (6) - 设置</title>
    <url>/posts/1270863220/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><!-- build time:Sat Nov 13 2021 15:45:21 GMT+0000 (Coordinated Universal Time) --><p>接下去主要介绍一下 <code>AirSim</code> 的配置参数, 翻译了 <a href="https://microsoft.github.io/AirSim/settings" target="_blank" rel="noopener">官方</a> 文档.</p><a id="more"></a><hr><p>[TOC]</p><hr><h2 id="设置保存在哪儿-Where-are-Settings-Stored"><a class="header-anchor" href="#设置保存在哪儿-Where-are-Settings-Stored">¶</a>设置保存在哪儿? Where are Settings Stored</h2><p>Windows: <code>Documents\AirSim</code><br>Linux: <code>~/Documents/AirSim</code></p><p>文件格式通常为 <a href="https://en.wikipedia.org/wiki/JSON" target="_blank" rel="noopener">json format</a>. 在首次启动 AirSim 是将创建 <code>settings.json</code> 文件, 不含任何设置. 为了避免产生问题, 通常使用 ASCII 格式来保存 json 文件.</p><h2 id="如何选择汽车还是飞行器-How-to-Chose-Between-Car-and-Multirotor"><a class="header-anchor" href="#如何选择汽车还是飞行器-How-to-Chose-Between-Car-and-Multirotor">¶</a>如何选择汽车还是飞行器? How to Chose Between Car and Multirotor</h2><p>默认设置是飞行器. 要使用汽车, 则设置 <code>&quot;SimMode&quot;: &quot;Car&quot;</code> :</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"SettingsVersion"</span>: <span class="number">1.2</span>,</span><br><span class="line">  <span class="attr">"SimMode"</span>: <span class="string">"Car"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>选择汽车, 则设置 <code>&quot;SimMode&quot;: &quot;Multirotor&quot;</code>. 如果想让用户选择载具类型, 则设置 <code>&quot;SimMode&quot;: &quot;&quot;</code>.</p><h2 id="可用设置及默认值-Available-Settings-and-Their-Defaults"><a class="header-anchor" href="#可用设置及默认值-Available-Settings-and-Their-Defaults">¶</a>可用设置及默认值 Available Settings and Their Defaults</h2><p>下述是完整的可用设置参数及其默认值的列表. 如果在 json 文件中没有设置参数, 则会使用默认值. 有些默认参数简单地指定为 <code>&quot;&quot;</code>, 表示实际参数值需要你根据实际使用的载具来选择. 举个例子, <code>ViewMode</code> 默认参数为 <code>&quot;&quot;</code> , 针对飞行器转换成 <code>&quot;FlyWithMe&quot;</code>, 针对汽车则是 <code>&quot;SpringArmChase&quot;</code> .</p><p><strong>警告:</strong> 不要把拷贝下面的文本到你自己的 settings.json. 我们强烈建议只加入你不想设置为默认值的参数. 唯一需要设置的元素是 <code>&quot;SettingsVersion&quot;</code>.</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"SimMode"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="attr">"ClockType"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="attr">"ClockSpeed"</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">"LocalHostIp"</span>: <span class="string">"127.0.0.1"</span>,</span><br><span class="line">  <span class="attr">"RecordUIVisible"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"LogMessagesVisible"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"ViewMode"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="attr">"RpcEnabled"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"EngineSound"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"PhysicsEngineName"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="attr">"SpeedUnitFactor"</span>: <span class="number">1.0</span>,</span><br><span class="line">  <span class="attr">"SpeedUnitLabel"</span>: <span class="string">"m/s"</span>,</span><br><span class="line">  <span class="attr">"Recording"</span>: &#123;</span><br><span class="line">    <span class="attr">"RecordOnMove"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"RecordInterval"</span>: <span class="number">0.05</span>,</span><br><span class="line">    <span class="attr">"Cameras"</span>: [</span><br><span class="line">        &#123; <span class="attr">"CameraName"</span>: <span class="string">"0"</span>, <span class="attr">"ImageType"</span>: <span class="number">0</span>, <span class="attr">"PixelsAsFloat"</span>: <span class="literal">false</span>, <span class="attr">"Compress"</span>: <span class="literal">true</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"CameraDefaults"</span>: &#123;</span><br><span class="line">    <span class="attr">"CaptureSettings"</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"ImageType"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">"Width"</span>: <span class="number">256</span>,</span><br><span class="line">        <span class="attr">"Height"</span>: <span class="number">144</span>,</span><br><span class="line">        <span class="attr">"FOV_Degrees"</span>: <span class="number">90</span>,</span><br><span class="line">        <span class="attr">"AutoExposureSpeed"</span>: <span class="number">100</span>,</span><br><span class="line">        <span class="attr">"AutoExposureBias"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">"AutoExposureMaxBrightness"</span>: <span class="number">0.64</span>,</span><br><span class="line">        <span class="attr">"AutoExposureMinBrightness"</span>: <span class="number">0.03</span>,</span><br><span class="line">        <span class="attr">"MotionBlurAmount"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">"TargetGamma"</span>: <span class="number">1.0</span>,</span><br><span class="line">        <span class="attr">"ProjectionMode"</span>: <span class="string">""</span>,</span><br><span class="line">        <span class="attr">"OrthoWidth"</span>: <span class="number">5.12</span></span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"NoiseSettings"</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"Enabled"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">"ImageType"</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="attr">"RandContrib"</span>: <span class="number">0.2</span>,</span><br><span class="line">        <span class="attr">"RandSpeed"</span>: <span class="number">100000.0</span>,</span><br><span class="line">        <span class="attr">"RandSize"</span>: <span class="number">500.0</span>,</span><br><span class="line">        <span class="attr">"RandDensity"</span>: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">        <span class="attr">"HorzWaveContrib"</span>:<span class="number">0.03</span>,</span><br><span class="line">        <span class="attr">"HorzWaveStrength"</span>: <span class="number">0.08</span>,</span><br><span class="line">        <span class="attr">"HorzWaveVertSize"</span>: <span class="number">1.0</span>,</span><br><span class="line">        <span class="attr">"HorzWaveScreenSize"</span>: <span class="number">1.0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="attr">"HorzNoiseLinesContrib"</span>: <span class="number">1.0</span>,</span><br><span class="line">        <span class="attr">"HorzNoiseLinesDensityY"</span>: <span class="number">0.01</span>,</span><br><span class="line">        <span class="attr">"HorzNoiseLinesDensityXY"</span>: <span class="number">0.5</span>,</span><br><span class="line"></span><br><span class="line">        <span class="attr">"HorzDistortionContrib"</span>: <span class="number">1.0</span>,</span><br><span class="line">        <span class="attr">"HorzDistortionStrength"</span>: <span class="number">0.002</span></span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"Gimbal"</span>: &#123;</span><br><span class="line">      <span class="attr">"Stabilization"</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">"Pitch"</span>: NaN, <span class="attr">"Roll"</span>: NaN, <span class="attr">"Yaw"</span>: NaN</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="string">"X"</span>: NaN, <span class="attr">"Y"</span>: NaN, <span class="attr">"Z"</span>: NaN,</span><br><span class="line">    <span class="attr">"Pitch"</span>: NaN, <span class="attr">"Roll"</span>: NaN, <span class="attr">"Yaw"</span>: NaN</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"OriginGeopoint"</span>: &#123;</span><br><span class="line">    <span class="attr">"Latitude"</span>: <span class="number">47.641468</span>,</span><br><span class="line">    <span class="attr">"Longitude"</span>: <span class="number">-122.140165</span>,</span><br><span class="line">    <span class="attr">"Altitude"</span>: <span class="number">122</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"TimeOfDay"</span>: &#123;</span><br><span class="line">    <span class="attr">"Enabled"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"StartDateTime"</span>: <span class="string">""</span>,</span><br><span class="line">    <span class="attr">"CelestialClockSpeed"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"StartDateTimeDst"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"UpdateIntervalSecs"</span>: <span class="number">60</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"SubWindows"</span>: [</span><br><span class="line">    &#123;<span class="attr">"WindowID"</span>: <span class="number">0</span>, <span class="attr">"CameraName"</span>: <span class="string">"0"</span>, <span class="attr">"ImageType"</span>: <span class="number">3</span>, <span class="attr">"Visible"</span>: <span class="literal">false</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">"WindowID"</span>: <span class="number">1</span>, <span class="attr">"CameraName"</span>: <span class="string">"0"</span>, <span class="attr">"ImageType"</span>: <span class="number">5</span>, <span class="attr">"Visible"</span>: <span class="literal">false</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">"WindowID"</span>: <span class="number">2</span>, <span class="attr">"CameraName"</span>: <span class="string">"0"</span>, <span class="attr">"ImageType"</span>: <span class="number">0</span>, <span class="attr">"Visible"</span>: <span class="literal">false</span>&#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"SegmentationSettings"</span>: &#123;</span><br><span class="line">    <span class="attr">"InitMethod"</span>: <span class="string">""</span>,</span><br><span class="line">    <span class="attr">"MeshNamingMethod"</span>: <span class="string">""</span>,</span><br><span class="line">    <span class="attr">"OverrideExisting"</span>: <span class="literal">false</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"PawnPaths"</span>: &#123;</span><br><span class="line">    <span class="attr">"BareboneCar"</span>: &#123;<span class="attr">"PawnBP"</span>: <span class="string">"Class'/AirSim/VehicleAdv/Vehicle/VehicleAdvPawn.VehicleAdvPawn_C'"</span>&#125;,</span><br><span class="line">    <span class="attr">"DefaultCar"</span>: &#123;<span class="attr">"PawnBP"</span>: <span class="string">"Class'/AirSim/VehicleAdv/SUV/SuvCarPawn.SuvCarPawn_C'"</span>&#125;,</span><br><span class="line">    <span class="attr">"DefaultQuadrotor"</span>: &#123;<span class="attr">"PawnBP"</span>: <span class="string">"Class'/AirSim/Blueprints/BP_FlyingPawn.BP_FlyingPawn_C'"</span>&#125;,</span><br><span class="line">    <span class="attr">"DefaultComputerVision"</span>: &#123;<span class="attr">"PawnBP"</span>: <span class="string">"Class'/AirSim/Blueprints/BP_ComputerVisionPawn.BP_ComputerVisionPawn_C'"</span>&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"Vehicles"</span>: &#123;</span><br><span class="line">    <span class="attr">"SimpleFlight"</span>: &#123;</span><br><span class="line">      <span class="attr">"VehicleType"</span>: <span class="string">"SimpleFlight"</span>,</span><br><span class="line">      <span class="attr">"DefaultVehicleState"</span>: <span class="string">"Armed"</span>,</span><br><span class="line">      <span class="attr">"AutoCreate"</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">"PawnPath"</span>: <span class="string">""</span>,</span><br><span class="line">      <span class="attr">"EnableCollisionPassthrogh"</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">"EnableCollisions"</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">"AllowAPIAlways"</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">"RC"</span>: &#123;</span><br><span class="line">        <span class="attr">"RemoteControlID"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">"AllowAPIWhenDisconnected"</span>: <span class="literal">false</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"Cameras"</span>: &#123;</span><br><span class="line">        <span class="comment">//same elements as CameraDefaults above, key as name</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"X"</span>: NaN, <span class="attr">"Y"</span>: NaN, <span class="attr">"Z"</span>: NaN,</span><br><span class="line">      <span class="attr">"Pitch"</span>: NaN, <span class="attr">"Roll"</span>: NaN, <span class="attr">"Yaw"</span>: NaN</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"PhysXCar"</span>: &#123;</span><br><span class="line">      <span class="attr">"VehicleType"</span>: <span class="string">"PhysXCar"</span>,</span><br><span class="line">      <span class="attr">"DefaultVehicleState"</span>: <span class="string">""</span>,</span><br><span class="line">      <span class="attr">"AutoCreate"</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">"PawnPath"</span>: <span class="string">""</span>,</span><br><span class="line">      <span class="attr">"EnableCollisionPassthrogh"</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">"EnableCollisions"</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">"RC"</span>: &#123;</span><br><span class="line">        <span class="attr">"RemoteControlID"</span>: <span class="number">-1</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"Cameras"</span>: &#123;</span><br><span class="line">        <span class="attr">"MyCamera1"</span>: &#123;</span><br><span class="line">          <span class="comment">//same elements as elements inside CameraDefaults above</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"MyCamera2"</span>: &#123;</span><br><span class="line">          <span class="comment">//same elements as elements inside CameraDefaults above</span></span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"X"</span>: NaN, <span class="attr">"Y"</span>: NaN, <span class="attr">"Z"</span>: NaN,</span><br><span class="line">      <span class="attr">"Pitch"</span>: NaN, <span class="attr">"Roll"</span>: NaN, <span class="attr">"Yaw"</span>: NaN</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="仿真模式-SimMode"><a class="header-anchor" href="#仿真模式-SimMode">¶</a>仿真模式 SimMode</h2><p>SimMode 决定了将使用哪种仿真模式. 目前支持一下参数值:</p><ul><li><code>&quot;&quot;</code>: 提示用户选择载具类型, 飞行器或者汽车</li><li><code>&quot;Multirotor&quot;</code>: 使用飞行器仿真</li><li><code>&quot;Car&quot;</code>: 使用汽车仿真</li><li><code>&quot;ComputerVision&quot;</code>: 只用摄像头, 没有载具和物理 (<strong>PS</strong>: 应该泛指物理碰撞、接触之类的交互)</li></ul><h2 id="视角模式-ViewMode"><a class="header-anchor" href="#视角模式-ViewMode">¶</a>视角模式 ViewMode</h2><p>ViewMode 决定哪儿相机被设置为默认以及相机如何跟随载具 (<strong>PS:</strong> 就是在用户的观察视角, 而不是载具摄像头的视角). 对于无人机, 默认 ViewMode 是<code>&quot;FlyWithMe&quot;</code> , 汽车的 ViewMode 是 <code>&quot;SpringArmChase&quot;</code>.</p><ul><li><code>FlyWithMe</code>: 从 6 个自由度跟随</li><li><code>GroundObserver</code>: 在 XY 平面内自由跟随.</li><li><code>Fpv</code>: 载具前部摄像机视角 (<strong>PS:</strong> 第一人称, 汽车的话就是驾驶室人眼的位置)</li><li><code>Manual</code>: 不会自动移动摄像机. 通过方向键和 ASWD 键来移动摄摄像机.</li><li><code>SpringArmChase</code>: 通过以固定在载具上以弹簧杆 (不可见)相连的摄像机视角跟随 (所以看起来有点延迟) (<strong>PS</strong>: 相当于在载具上装了根延长杆 (类似手持的拍照杆), 延长杆有点弹性, 导致载具起步时, 视角有种被拽着一起动的感觉) .</li><li><code>NoDisplay</code>: 这将冻结主屏幕的渲染, 但是对子窗口、录频及 APIs 的渲染依然激活. (<strong>PS</strong>: UE 里面子窗口好像也是黑的, 但是 APIs 可以调用出来图像). 在那些你只关心获取到的图像而不关心如何在主屏幕渲染的 “无用” 模式下, 这个模式能节省资源. 这也可以提高录像图像的 FPS.</li></ul><h2 id="时间-TimeOfDay"><a class="header-anchor" href="#时间-TimeOfDay">¶</a>时间 TimeOfDay</h2><p>该设置控制环境中太阳的位置. 默认 <code>Enabled</code> 是 false, 意味这太阳的位置无论何时太阳都在场景的左侧并且一直不变. 如果 <code>Enabled</code> 是 true, 那么太阳的位置将会通过在 <code>OriginGeopoint</code> 节点中设定的经度, 纬度, 高度结合在 <code>StartDateTime</code> 设定的时间来计算. <code>StartDateTime</code> 是一串 <a href="https://en.cppreference.com/w/cpp/io/manip/get_time" target="_blank" rel="noopener">%Y-%m-%d %H:%M:%S</a> 格式的字符串, 举个例子, <code>2018-02-12 15:20:00</code>. 如果字符串为空, 那么就用当前的日期和时间. 如果 <code>StartDateTimeDst</code> 是 true, 那么我们将调整白天时长. 太阳的位置根据 <code>UpdateIntervalSecs</code>设定的时间间隔来持续更新. 在某些情况下, 可能希望天体时钟可以比仿真始终更快或者更慢. 这可以通过<code>CelestialClockSpeed</code>设置, 举个例子, 值 100 意味这仿真时钟 1 秒, 太阳的位置将提前 100 秒, 所以天空中的太阳看起来移动的更加快了.</p><p><strong>PS:</strong> 怎么设置太阳都没有动, 改变时间倒是太阳的起始点位置变了.</p><p>参考 <a href="apis.md#time-of-day-api">Time of Day API</a>.</p><h2 id="地理原点-OriginGeopoint"><a class="header-anchor" href="#地理原点-OriginGeopoint">¶</a>地理原点 OriginGeopoint</h2><p>这个将设置玩家出生点在 Unreal 环境中的经度, 维度, 高度. 载具的原点通过这个值来转换. 记住所有通过 APIs 的坐标系都是基于国际标准单位制的 NED 坐标系统. 这意味着每个载具都开始于 NED 坐标系下的 (0, 0, 0) 点. 每日的时间设置也是根据<code>OriginGeopoint</code> 设定的地理坐标系计算.</p><h2 id="子窗口-SubWindows"><a class="header-anchor" href="#子窗口-SubWindows">¶</a>子窗口 SubWindows</h2><p>这个设定指定按下 0 键显示的 3 个子窗口. WindowsID 可以是 0 到 2, CameraName 可以是载具上的任何一个 <a href="image_apis.md#available_cameras">可用的相机</a>. ImageType 的值根据 <a href="image_apis.md#available-imagetype">ImageType enum</a> 决定显示哪类图片. 举个例子, 对于下面的载具, 分别显示了驾驶员视角, 前视角, 后视角的场景, 深度, 分割图像. .</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">"SubWindows": [</span><br><span class="line">  &#123;"WindowID": 0, "ImageType": 0, "CameraName": "3", "Visible": true&#125;,</span><br><span class="line">  &#123;"WindowID": 1, "ImageType": 3, "CameraName": "0", "Visible": true&#125;,</span><br><span class="line">  &#123;<span class="attr">"WindowID"</span>: <span class="number">2</span>, <span class="attr">"ImageType"</span>: <span class="number">6</span>, <span class="attr">"CameraName"</span>: <span class="string">"4"</span>, <span class="attr">"Visible"</span>: <span class="literal">true</span>&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="记录-Recording"><a class="header-anchor" href="#记录-Recording">¶</a>记录 Recording</h2><p>记录功能允许你已设定的时间间隔采集类似位置, 方向, 速度的图像. 你可以通过按下红色的 Recored 按钮或者 R 键来开始记录. 数据将被保存在 <code>Documents\AirSim</code> 文件夹中, 每个记录会话都放在一个时间戳命名的子文件中, 以 tab 分割的文本 (<strong>PS:</strong> 举个例子, Record 的数据被保存在已时间戳命名的文件夹中 <code>2020-06-14-13-43-41</code> 文件夹中, 图片放在 <code>image</code> 子文件夹中, 数据放在 <code>airsim_rec.txt</code> 文本文件中, 文本以 Tab 分割).</p><ul><li><code>RecordInterval</code>: 设定采样图片的最小间隔, 秒.</li><li><code>RecordOnMove</code>: 设定在载具位置和姿态没有变化的时候不要采集.</li><li><code>Cameras</code>: 控制采集哪个相机的图像. 默认的采集 camera 0 的压缩的 png 格式的场景图像. 这个设定是一个 json 数组的形式, 所以你可以指定采集多个相机不同<a href="settings.md#image-capture-settings">image types</a>的图像, 当 PixelsAsFloat 是 true, 图像将被以 <a href="pfm.md">pfm</a> 格式保存而不是 png.</li></ul><h2 id="时钟速度-ClockSpeed"><a class="header-anchor" href="#时钟速度-ClockSpeed">¶</a>时钟速度 ClockSpeed</h2><p>这个设置将允许你设置仿真的时钟. 举个例子, 5.0 表示当挂钟过了 1 秒, 仿真时间过了 5.0 秒 (即仿真运行更快了). 值 0.1 表示仿真比挂钟慢了 10X. 值 1 表示仿真时间和真实时间一样. 当仿真时钟运行更快的情况下, 仿真质量可能降低, 意识到这点很重要. 所以你可能看到一些物体穿模, 因为碰撞没有被探测到. 然后, 降低仿真时钟 (即值 &lt; 1.0) 通常能提高仿真质量.</p><h2 id="分割设置-Segmentation-Settings"><a class="header-anchor" href="#分割设置-Segmentation-Settings">¶</a>分割设置 Segmentation Settings</h2><p><code>InitMethod</code> 决定如何在启动的时候初始化 object IDs 来生成 <a href="image_apis.md#segmentation">segmentation</a>. 值 <code>&quot;&quot;</code> 或者 <code>&quot;CommonObjectsRandomIDs&quot;</code> (默认) 意味着在启动时给每个 object 分配随机的 IDs. 生成的分割图中, 每个 object 也被分配为随机的颜色. 值 <code>&quot;None&quot;</code> 意味这不初始化 object IDs. 这将造成分割视图只有单一固定的颜色. 如果你计划通过 <a href="image_apis.md#segmentation">APIs</a> 来设置 object IDs 会有用. 这也能节约大场景的启动延时, 像 CityEnviron.</p><p>如果 <code>OverrideExisting</code> 是 <code>false</code>, 那么初始化时不会改变已分配的非零的 object IDs , 否则会.</p><p>如果 <code>MeshNamingMethod</code> 为 <code>&quot;&quot;</code> 或者 <code>&quot;OwnerName&quot;</code> , 那么我们用网格拥有者的名字来生成随机哈希值作为 object IDs. 如果是<code>&quot;StaticMeshName&quot;</code> , 那么我们用静态的网格名称来生成随机哈希值作为 object IDs. 记住这种方法通常不能区分相同静态网格的单个实例, 但是名称通常更加直观.</p><h2 id="相机设置-Camera-Settings"><a class="header-anchor" href="#相机设置-Camera-Settings">¶</a>相机设置 Camera Settings</h2><p><code>CameraDefaults</code> 作为所有相机设置的根节点元素. 默认值可以被 <code>Vehicles</code> 中的 <code>Cameras</code> 元素中的单个相机设置覆盖.</p><h3 id="Note-on-ImageType-element"><a class="header-anchor" href="#Note-on-ImageType-element">¶</a>Note on ImageType element</h3><p>JSON 数组的<code>ImageType</code> 元素决定哪种图像类型将被运用. 可用的值在图像类型那一节说明过. 此外, 我们也支持特殊的值 <code>ImageType: -1</code> , 来对外部相机设置 (即你在屏幕上看到的场景视角).</p><p>举个例子, <code>CaptureSettings</code> 元素是 json 数组, 所以你可以很容易地添加多个图像类型的设置.</p><h3 id="捕捉设置-CaptureSettings"><a class="header-anchor" href="#捕捉设置-CaptureSettings">¶</a>捕捉设置 CaptureSettings</h3><p><code>CaptureSettings</code> 决定如何渲染不同的图像类型, 比如 scene, depth, disparity, surface normals 和 segmentation. 宽度, 高度, FOV 的设置应该无需多言. <code>AutoExposureSpeed</code>决定眼睛的适应速度多快 (<strong>PS</strong>: 自动曝光速度?) . 通常我们设定一个较大值, 比如 100 来避免图像采集中的假影. 类似地, 我们默认设置 <code>MotionBlurAmount</code> 为 0 来避免地面图像地假影. <code>ProjectionMode</code> 决定采集的相机用的投影模式, 该值可以是 <code>&quot;perspective</code>&quot; (默认) 或者 <code>&quot;orthographic&quot;</code>. 如果投影模式是 <code>&quot;orthographic&quot;</code> , 那么<code>OrthoWidth</code> 决定以米制宽度来采集投影区域.</p><p>更多其他设置, 请参考 <a href="https://docs.unrealengine.com/latest/INT/Engine/Rendering/PostProcessEffects/AutomaticExposure/" target="_blank" rel="noopener">this article</a>.</p><p>(<strong>PS:</strong> 这里不太懂, 没有图像相关的知识)</p><h3 id="噪声设置-NoiseSettings"><a class="header-anchor" href="#噪声设置-NoiseSettings">¶</a>噪声设置 NoiseSettings</h3><p><code>NoiseSettings</code> 允许对指定的图像类型增加噪声, 通过模拟相机传感器的噪声, 干涉和其他假影. 默认美哟添加噪声 即 <code>Enabled: false</code>. 如果你设置 <code>Enabled: true</code> , 那么不同类型的噪声, 干涉, 假影生效, 每个都可以被进一步设置. 噪声的效果通过在 Unreal 引擎中后期材质处理是添加阴影来实现, 称为 <a href="https://github.com/Microsoft/AirSim/blob/master/Unreal/Plugins/AirSim/Content/HUDAssets/CameraSensorNoise.uasset" target="_blank" rel="noopener">CameraSensorNoise</a>.</p><p>相机的噪声和干涉仿真的例子:</p><p><a href="https://youtu.be/1BeCEZmQyp0" target="_blank" rel="noopener"><img data-src="images/camera_noise_demo.png" alt="AirSim Drone Demo Video"></a></p><h4 id="随机噪声-Random-noise"><a class="header-anchor" href="#随机噪声-Random-noise">¶</a>随机噪声 Random noise</h4><p>这将通过下述参数来增加随机噪声斑点.</p><ul><li><code>RandContrib</code>: 这决定了噪声像素与图像像素的混合比率, 0 表示没有噪声, 1 表示只有噪声.</li><li><code>RandSpeed</code>: 这决定了噪音波动的速度, 1 表示没有波动, 高值如 1E6 表示完全波动.</li><li><code>RandSize</code>: 这决定了噪声的粗糙程度, 1 表示每个像素都有自己的噪声, 较大的值表示多个像素有相同的噪声值.</li><li><code>RandDensity</code>: 这决定了有多少像素会有噪声, 1 表示所有像素都有噪声, 较高的值意味着较少的像素 (指数).</li></ul><h4 id="Horizontal-bump-distortion"><a class="header-anchor" href="#Horizontal-bump-distortion">¶</a>Horizontal bump distortion</h4><p>这增加了水平凸起/闪烁/重影效果.</p><ul><li><code>HorzWaveContrib</code>: 这决定了噪声像素与图像像素的混合比率, 0 表示没有噪声, 1 表示只有噪声</li><li><code>HorzWaveStrength</code>: 这决定了该影响的整体强度.</li><li><code>HorzWaveVertSize</code>: 这决定了有多少垂直像素会受到影响</li><li><code>HorzWaveScreenSize</code>:这决定了有大的屏幕受影响</li></ul><h4 id="Horizontal-noise-lines"><a class="header-anchor" href="#Horizontal-noise-lines">¶</a>Horizontal noise lines</h4><p>这在水平线上增加了噪声区域.</p><ul><li><code>HorzNoiseLinesContrib</code>: 这决定了噪声像素与图像像素的混合比率, 0 表示没有噪声, 1 表示只有噪声</li><li><code>HorzNoiseLinesDensityY</code>: 这决定了水平线中有多少像素会受到影响.</li><li><code>HorzNoiseLinesDensityXY</code>: 这决定了屏幕上有多少行会受到影响.</li></ul><h4 id="Horizontal-line-distortion"><a class="header-anchor" href="#Horizontal-line-distortion">¶</a>Horizontal line distortion</h4><p>这增加了水平线上的波动.</p><ul><li><code>HorzDistortionContrib</code>: 这决定了噪声像素与图像像素的混合比率, 0 表示没有噪声, 1 表示只有噪声.</li><li><code>HorzDistortionStrength</code>: 这决定了失真的强度</li></ul><h3 id="云台-Gimbal"><a class="header-anchor" href="#云台-Gimbal">¶</a>云台 Gimbal</h3><p><code>Gimbal</code> 元素允许冻结相机的俯仰, 翻转, 偏航. 这个设置会被忽略, 除非 <code>ImageType</code> 是 -1. <code>Stabilization</code> 默认设置为 0 , 意味着没有云台, 即相机在所有轴上都随着物体发生变化. 值 1 意味着完全稳定. 介于 0 到 1 之间的值作为对在 <code>Pitch</code>, <code>Roll</code> 和<code>Yaw</code> 元素被指定的固定角度 (角度, 世界坐标系) 和载具的方向的权重. 当任一角度被省略或者设置为 <code>NaN</code>, 那么这个角度是不稳定的 (即随着物体而运动).</p><p><strong>PS</strong>: 应该是云台</p><h2 id="载具设置-Vehicles-Settings"><a class="header-anchor" href="#载具设置-Vehicles-Settings">¶</a>载具设置 Vehicles Settings</h2><p>每种仿真模式将遍历在该设置中的载具列表, 然后创建那些 <code>&quot;AutoCreate&quot;: true</code> 的载具. 每个被设定的载具有个成为该载具名称的键值. 如果 <code>&quot;Vehicles&quot;</code> 元素缺省, 那么这个列表将被填入名为 <code>&quot;PhysXCar&quot;</code> 的默认汽车和名为 <code>&quot;SimpleFlight&quot;</code> 默认飞行器.</p><h3 id="通用载具设置-Common-Vehicle-Setting"><a class="header-anchor" href="#通用载具设置-Common-Vehicle-Setting">¶</a>通用载具设置 Common Vehicle Setting</h3><ul><li><code>VehicleType</code>: 可以是 <code>PhysXCar</code>, <code>SimpleFlight</code>, <code>PX4Multirotor</code> 或者 <code>ComputerVision</code>. 这个没有默认值, 所以必须被指定.</li><li><code>PawnPath</code>: 这个允许覆盖载具使用的 pawn blueprint. 举个例子, 你可以创建一个新的 pawn blueprint , 继承于 ACarPawn, 作为你自己项目中而不在 AirSim 代码中的仓储机器人, 然后在这里指定路径. 参见 <a href="#PawnPaths">PawnPaths</a>.</li><li><code>DefaultVehicleState</code>: 飞行器可用的值为 <code>Armed</code> 或 <code>Disarmed</code>.</li><li><code>AutoCreate</code>: 如果为 true, 那么这个载具将被加载 (如果选中的 sim 模式支持.</li><li><code>RC</code>: 这个子元素允许通过<code>RemoteControlID</code>指定载具使用哪个远程控制器. 值 -1 意味着使用键盘 (飞行器暂时不支持). 值 &gt;= 0 指定被连接上的远程控制器其中的一个. 举个例子, 在 Window 中, 可用的 RCs 列表可以在 Game Controllers 面板中看到.</li><li><code>X, Y, Z, Yaw, Roll, Pitch</code>: 这个元素允许你指定载具的初始位置和方向. 位置是在 SI 单位制 NED 坐标系中, 坐标系原点被设置在 Unreal 环境中的玩家出生点. 方向以角度指定.</li><li><code>IsFpvVehicle</code>: 这个设置允许指定哪个载具的摄像头被跟随. 当 <code>ViewMode</code> 被设置为 <code>Fpv</code> 时, 这个视角将被显示. 默认情况下, AirSim 选择设置中的第一个载具作为 FPV 载具.</li><li><code>Cameras</code>: 这个元素设定载具的相机设置. 这个元素中的关键是 <a href="image_apis.md#available_cameras">available camera</a> 的名称, 这个值和上述 <code>CameraDefaults</code> 的一致. 举个例子, 为了改变前面中间相机 FOV 为 120 度, 你可以用这个 <code>Vehicles</code> 设置:</li></ul><figure class="highlight"><table><tr><td class="code"><pre><span class="line">"Vehicles": &#123;</span><br><span class="line">    "FishEyeDrone": &#123;</span><br><span class="line">      "VehicleType": "SimpleFlight",</span><br><span class="line">      "Cameras": &#123;</span><br><span class="line">        "front-center": &#123;</span><br><span class="line">          "CaptureSettings": [</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="attr">"ImageType"</span>: <span class="number">0</span>,</span><br><span class="line">              <span class="attr">"FOV_Degrees"</span>: <span class="number">120</span></span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Using-PX4"><a class="header-anchor" href="#Using-PX4">¶</a>Using PX4</h3><p>By default we use <a href="simple_flight.md">simple_flight</a> so you don’t have to do separate HITL or SITL setups. We also support <a href="px4_setup.md">“PX4”</a> for advanced users. To use PX4 with AirSim, you can use the following for <code>Vehicles</code> setting:</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">"Vehicles": &#123;</span><br><span class="line">    "PX4": &#123;</span><br><span class="line">      "VehicleType": "PX4Multirotor",</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Additional-PX4-Settings"><a class="header-anchor" href="#Additional-PX4-Settings">¶</a>Additional PX4 Settings</h4><p>The defaults for PX4 is to enable hardware-in-loop setup. There are various other settings available for PX4 as follows with their default values:</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">"Vehicles": &#123;</span><br><span class="line">    "PX4": &#123;</span><br><span class="line">      "VehicleType": "PX4Multirotor",</span><br><span class="line"></span><br><span class="line">      "ControlIp": "127.0.0.1",</span><br><span class="line">      "ControlPort": 14580,</span><br><span class="line">      "LogViewerHostIp": "127.0.0.1",</span><br><span class="line">      "LogViewerPort": 14388,</span><br><span class="line">      "OffboardCompID": 1,</span><br><span class="line">      "OffboardSysID": 134,</span><br><span class="line">      "QgcHostIp": "127.0.0.1",</span><br><span class="line">      "QgcPort": 14550,</span><br><span class="line">      "SerialBaudRate": 115200,</span><br><span class="line">      "SerialPort": "*",</span><br><span class="line">      "SimCompID": 42,</span><br><span class="line">      "SimSysID": 142,</span><br><span class="line">      "TcpPort": 4560,</span><br><span class="line">      "UdpIp": "127.0.0.1",</span><br><span class="line">      "UdpPort": 14560,</span><br><span class="line">      "UseSerial": true,</span><br><span class="line">      "UseTcp": false,</span><br><span class="line">      "VehicleCompID": 1,</span><br><span class="line">      "VehicleSysID": 135,</span><br><span class="line">      "Model": "Generic",</span><br><span class="line">      "LocalHostIp": "127.0.0.1"</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>These settings define the MavLink SystemId and ComponentId for the Simulator (SimSysID, SimCompID), and for the vehicle (VehicleSysID, VehicleCompID)<br>and the node that allows remote control of the drone from another app this is called the offboard node (OffboardSysID, OffboardCompID).</p><p>If you want the simulator to also talk to your ground control app (like QGroundControl) you can also set the UDP address for that in case you want to run<br>that on a different machine (QgcHostIp, QgcPort). The default is local host so QGroundControl should “just work” if it is running on the same machine.</p><p>You can connect the simulator to the LogViewer app, provided in this repo, by setting the UDP address for that (LogViewerHostIp, LogViewerPort).</p><p>And for each flying drone added to the simulator there is a named block of additional settings. In the above you see the default name “PX4”. You can change this name from the Unreal Editor when you add a new BP_FlyingPawn asset. You will see these properties grouped under the category “MavLink”. The MavLink node for this pawn can be remote over UDP or it can be connected to a local serial port. If serial then set UseSerial to true, otherwise set UseSerial to false. For serial connections you also need to set the appropriate SerialBaudRate. The default of 115200 works with Pixhawk version 2 over USB.</p><p>When communicating with the PX4 drone over serial port both the HIL** messages and vehicle control messages share the same serial port.<br>When communicating over UDP or TCP PX4 requires two separate channels. If UseTcp is false, then UdpIp, UdpPort are used to send HIL** messages,<br>otherwise the TcpPort is used. TCP support in PX4 was added in 1.9.2 with the <code>lockstep</code> feature because the guarantee of message delivery that<br>TCP provides is required for the proper functioning of lockstep. AirSim becomes a TCP server in that case, and waits for a connection<br>from the PX4 app. The second channel for controlling the vehicle is defined by (ControlIp, ControlPort) and is always a UDP channel.</p><h2 id="其他设置-Other-Settings"><a class="header-anchor" href="#其他设置-Other-Settings">¶</a>其他设置 Other Settings</h2><h3 id="引擎声音-EngineSound"><a class="header-anchor" href="#引擎声音-EngineSound">¶</a>引擎声音 EngineSound</h3><p>通过设置 <a href="settings.md">setting</a> <code>&quot;EngineSound&quot;: false</code> 来关闭引擎声音. 目前这个设置只在汽车上运用.</p><h3 id="PawnPaths"><a class="header-anchor" href="#PawnPaths">¶</a>PawnPaths</h3><p>This allows you to specify your own vehicle pawn blueprints, for example, you can replace the default car in AirSim with your own car. Your vehicle BP can reside in Content folder of your own Unreal project (i.e. outside of AirSim plugin folder). For example, if you have a car BP located in file <code>Content\MyCar\MySedanBP.uasset</code> in your project then you can set <code>&quot;DefaultCar&quot;: {&quot;PawnBP&quot;:&quot;Class'/Game/MyCar/MySedanBP.MySedanBP_C'&quot;}</code>. The <code>XYZ.XYZ_C</code> is a special notation required to specify class for BP <code>XYZ</code>. Please note that your BP must be derived from CarPawn class. By default this is not the case but you can re-parent the BP using the “Class Settings” button in toolbar in UE editor after you open the BP and then choosing “Car Pawn” for Parent Class settings in Class Options. It’s also a good idea to disable “Auto Possess Player” and “Auto Possess AI” as well as set AI Controller Class to None in BP details. Please make sure your asset is included for cooking in packaging options if you are creating binary.</p><h3 id="物理引擎名称-PhysicsEngineName"><a class="header-anchor" href="#物理引擎名称-PhysicsEngineName">¶</a>物理引擎名称 PhysicsEngineName</h3><p>对于汽车, 我们目前只支持 <code>PhysX</code> (忽略这是设置值), 对于飞行器, 我们只支持 <code>&quot;FastPhysicsEngine&quot;</code> .</p><h3 id="本地主机-IP-设置-LocalHostIp-Setting"><a class="header-anchor" href="#本地主机-IP-设置-LocalHostIp-Setting">¶</a>本地主机 IP 设置 LocalHostIp Setting</h3><p>当你需要连接到远程主机, 你需要通过以太网适配器来互联, 举个例子, 可能通过以太网或者 Wi-Fi, 或者其他一些虚拟适配器或者 VPN. 你的 PC 可能有多个网络, 这些网络可能不孕寻互相通讯, 这种情况下, UDP 消息就不能传播到其他主机上. 所以 <code>LocalHostIp</code>允许你配置如何连接这些主机. 默认值 127.0.0.1 不能够到达外部主机, 这个默认值只能用来单个主机内部通讯.</p><h3 id="速度单位因子-SpeedUnitFactor"><a class="header-anchor" href="#速度单位因子-SpeedUnitFactor">¶</a>速度单位因子 SpeedUnitFactor</h3><p>速度转换成<code>m/s</code>因子, 默认为 1. 与 <code>SpeedUnitLabel</code> 结合使用. 这通常只被用来显示, 比如汽车行驶速度显示. 举个例子, 速度转换到 <code>miles/hr</code> 的因子是 2.23694.</p><h3 id="速度单位标签-SpeedUnitLabel"><a class="header-anchor" href="#速度单位标签-SpeedUnitLabel">¶</a>速度单位标签 SpeedUnitLabel</h3><p>速度单位, 默认为 <code>m/s</code>. 结合 <code>SpeedUnitFactor</code> 一起使用.</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>自动驾驶</category>
      </categories>
      <tags>
        <tag>自动驾驶</tag>
        <tag>AirSim</tag>
      </tags>
  </entry>
  <entry>
    <title>自动驾驶仿真 - AirSim (5) - 图片 APIs - C++</title>
    <url>/posts/3314168402/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><!-- build time:Sat Nov 13 2021 15:45:21 GMT+0000 (Coordinated Universal Time) --><p>接下去主要介绍一下 <code>AirSim</code> 的 <code>APIs</code> 的使用, 参考 <a href="https://microsoft.github.io/AirSim/image_apis/" target="_blank" rel="noopener">官方</a> 文档, 并结合结合 OpenCV 来用 C++ 实现部分 官方 Python 的例程.</p><a id="more"></a><hr><p>[TOC]</p><hr><h2 id="读取相机图片"><a class="header-anchor" href="#读取相机图片">¶</a>读取相机图片</h2><p>官方<a href="https://microsoft.github.io/AirSim/image_apis/" target="_blank" rel="noopener">例程</a> 提供了两种读取相机图片的方式 (需要修改, 代码参考如下). 这个例程获取 “0” 号相机的单幅图片. 返回值为 png 格式图片的字节. 如果要获取其他格式图片或者其他可用相机的图片参考下一小节.</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"vehicles/multirotor/api/MultirotorRpcLibClient. hpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getOneImage</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> msr::airlib;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//for car use CarRpcLibClient</span></span><br><span class="line">    msr::airlib::MultirotorRpcLibClient client;</span><br><span class="line"></span><br><span class="line">    msr::airlib::<span class="built_in">vector</span>&lt;<span class="keyword">uint8_t</span>&gt; png_image = client. simGetImage(<span class="string">"0"</span>, VehicleCameraBase::ImageType::Scene);</span><br><span class="line">    <span class="comment">//do something with images</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="更加灵活的获取图片"><a class="header-anchor" href="#更加灵活的获取图片">¶</a>更加灵活的获取图片</h2><p><code>simGetImages</code> API 相比于 <code>simGetImage</code> API 更加复杂, 举个例子, 你可以通过单个 API 调用获取左侧、右侧、左侧的相机深度视图. <code>simGetImages</code>API 允许你获取未压缩的图片或者浮点单通道的图片数据 (而不是 8 位 3 通道 (RGB)).</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ImageRequest(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; camera_name_val, ImageCaptureBase::ImageType image_type_val, <span class="keyword">bool</span> pixels_as_float_val = <span class="literal">false</span>, <span class="keyword">bool</span> compress_val = <span class="literal">true</span>)</span><br></pre></td></tr></table></figure><p><code>ImageRequest</code> 图片请求类的参数为</p><p><code>camera_name_val</code>: 相机编号, 可以输入 <code>&quot;0&quot;</code>, <code>&quot;1&quot;</code>, <code>&quot;2&quot;</code>, <code>&quot;3&quot;</code>, <code>&quot;4&quot;</code> 或者 <code>&quot;front_center&quot;</code>, <code>&quot;front_right&quot;</code>, <code>&quot;front_left&quot;</code>, <code>&quot;fpv&quot;</code>, <code>&quot;back_center&quot;</code>.</p><p><code>image_type_val</code>: 图片类型, 可支持的图片类型有:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Scene = <span class="number">0</span>,</span><br><span class="line">DepthPlanner = <span class="number">1</span>,</span><br><span class="line">DepthPerspective = <span class="number">2</span>,</span><br><span class="line">DepthVis = <span class="number">3</span>,</span><br><span class="line">DisparityNormalized = <span class="number">4</span>,</span><br><span class="line">Segmentation = <span class="number">5</span>,</span><br><span class="line">SurfaceNormals = <span class="number">6</span>,</span><br><span class="line">Infrared = <span class="number">7</span></span><br></pre></td></tr></table></figure><p><code>pixels_as_float_val</code>: 是否为浮点值, 默认为 <code>false</code>.</p><p><code>compress_val</code>: 是否是压缩数据, 默认为 <code>true</code></p><p><strong>PS:</strong> 后两个参数这里会影响到 opencv 的矩阵或者解码图片. 这里通过将一组图像请求信息 <code>ImageRequest</code> 放入容器中, 通过 <code>simGetImages</code> 一次性请求. 之后可通过迭代获取各个相机的图像数据.</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getStereoAndDepthImages</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> msr::airlib;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> VehicleCameraBase::ImageRequest ImageRequest;</span><br><span class="line">    <span class="keyword">typedef</span> VehicleCameraBase::ImageResponse ImageResponse;</span><br><span class="line">    <span class="keyword">typedef</span> VehicleCameraBase::ImageType ImageType;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//for car use</span></span><br><span class="line">    <span class="comment">//msr::airlib::CarRpcLibClient client;</span></span><br><span class="line">    msr::airlib::MultirotorRpcLibClient client;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//get right, left and depth images. First two as png, second as float16.</span></span><br><span class="line">    msr::airlib::<span class="built_in">vector</span>&lt;ImageRequest&gt; request = &#123;</span><br><span class="line">        <span class="comment">//png format</span></span><br><span class="line">        ImageRequest(<span class="string">"0"</span>, ImageType::Scene),</span><br><span class="line">        <span class="comment">//uncompressed RGB array bytes</span></span><br><span class="line">        ImageRequest(<span class="string">"1"</span>, ImageType::Scene, <span class="literal">false</span>, <span class="literal">false</span>),</span><br><span class="line">        <span class="comment">//floating point uncompressed image</span></span><br><span class="line">        ImageRequest(<span class="string">"1"</span>, ImageType::DepthPlanner, <span class="literal">true</span>)</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">vector</span>&lt;ImageResponse&gt;&amp; response = client. simGetImages(request);</span><br><span class="line">    <span class="comment">//do something with response which contains image data, pose, timestamp etc</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="通过-OpenCV-显示图片"><a class="header-anchor" href="#通过-OpenCV-显示图片">¶</a>通过 <code>OpenCV</code> 显示图片</h2><p>虽然获取到的图片是 <code>uint8_t</code> 类型的数据, 但是无法通过直接转换成 <code>cv::Mat</code> 来使用 <code>OpenCV</code> 进行操作处理. 主要是获取到的是压缩的图片数据. 这里要使用 <code>cv::imdecode</code> 来对图片进行解码. 对应的两个 API 略有不同.</p><p>如果是压缩的数据：需要用 <code>cv::imdecode</code> 来解码生成 <code>cv::Mat</code> 的数据格式； 如果是非压缩的数据, 可以直接进行构造. 具体可见代码. 深度图片需要对 Mat 调用 <code>normalize</code> 归一化, 否则图片可能全白.</p><p>参考资料:</p><p><a href="https://github.com/microsoft/AirSim/issues/966" target="_blank" rel="noopener">https://github.com/microsoft/AirSim/issues/966</a></p><p><a href="https://github.com/Microsoft/AirSim/issues/491" target="_blank" rel="noopener">https://github.com/Microsoft/AirSim/issues/491</a></p><p>完整源码如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"opencv2/opencv. hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"vehicles/multirotor/api/MultirotorRpcLibClient. hpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ImageAPIs::getStereoAndDepthImages4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">namespace</span> msr::airlib;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">typedef</span> ImageCaptureBase::ImageRequest ImageRequest;</span><br><span class="line">  <span class="keyword">typedef</span> ImageCaptureBase::ImageResponse ImageResponse;</span><br><span class="line">  <span class="keyword">typedef</span> ImageCaptureBase::ImageType ImageType;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// for car use</span></span><br><span class="line">  <span class="comment">// msr::airlib::CarRpcLibClient client;</span></span><br><span class="line">  msr::airlib::MultirotorRpcLibClient client;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// get right, left and depth images. First two as png, second as float16.</span></span><br><span class="line">  msr::airlib::<span class="built_in">vector</span>&lt;ImageRequest&gt; request = &#123;<span class="comment">// png format</span></span><br><span class="line">                                               ImageRequest(<span class="string">"0"</span>, ImageType::Scene),</span><br><span class="line">                                               <span class="comment">// uncompressed RGB array bytes</span></span><br><span class="line">                                               ImageRequest(<span class="string">"1"</span>, ImageType::Scene, <span class="literal">false</span>, <span class="literal">false</span>),</span><br><span class="line">                                               <span class="comment">// floating point uncompressed image</span></span><br><span class="line">                                               ImageRequest(<span class="string">"1"</span>, ImageType::DepthPlanner, <span class="literal">true</span>)&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;ImageResponse&gt;&amp; response = client. simGetImages(request);</span><br><span class="line">      <span class="keyword">if</span> (response. <span class="built_in">size</span>() != request. <span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Images were not received!"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 左侧相机 ImageRequest("0", ImageType::Scene)</span></span><br><span class="line">      <span class="comment">// 默认参数是压缩数据, 调用 imdecode</span></span><br><span class="line">      cv::Mat left_mat = cv::imdecode(response. at(<span class="number">0</span>). image_data_uint8, cv::IMREAD_UNCHANGED);</span><br><span class="line">      cv::imshow(<span class="string">"left"</span>, left_mat);</span><br><span class="line">      cv::waitKey(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">      <span class="function">cv::Mat <span class="title">right_mat</span><span class="params">(response. at(<span class="number">1</span>). <span class="built_in">height</span>, response. at(<span class="number">1</span>). <span class="built_in">width</span>, CV_8UC3,</span></span></span><br><span class="line"><span class="function"><span class="params">                        (<span class="keyword">void</span>*)response. at(<span class="number">1</span>). image_data_uint8. data())</span></span>;</span><br><span class="line">      cv::imshow(<span class="string">"right"</span>, right_mat);</span><br><span class="line">      cv::waitKey(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 深度图片 ImageRequest("1", ImageType::DepthPlanner, true)</span></span><br><span class="line">      <span class="comment">// 这里需要对 Mat 调用 normalize 归一化, 否则图片可能全白.</span></span><br><span class="line">      <span class="function">cv::Mat <span class="title">gt_depth_mat</span><span class="params">(response. at(<span class="number">2</span>). <span class="built_in">height</span>, response. at(<span class="number">2</span>). <span class="built_in">width</span>, CV_32FC1,</span></span></span><br><span class="line"><span class="function"><span class="params">                           (<span class="keyword">void</span>*)response. at(<span class="number">2</span>). image_data_float. data())</span></span>;</span><br><span class="line">      cv::normalize(gt_depth_mat, gt_depth_mat, <span class="number">1</span>, <span class="number">0</span>, cv::NORM_MINMAX);</span><br><span class="line">      cv::imshow(<span class="string">"depth"</span>, gt_depth_mat);</span><br><span class="line">      cv::waitKey(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (rpc::timeout&amp; t) &#123;</span><br><span class="line">    <span class="comment">// will display a message like</span></span><br><span class="line">    <span class="comment">// rpc::timeout: Timeout of 50ms while calling RPC function 'sleep'</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; t. what() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img data-src="image-20200613175100646.png" alt="image-20200613175100646"></p><h2 id="可用的相机"><a class="header-anchor" href="#可用的相机">¶</a>可用的相机</h2><h3 id="车"><a class="header-anchor" href="#车">¶</a>车</h3><p><code>API</code> 可以通过一下相机名称调用: <code>&quot;front_center&quot;</code>, <code>&quot;front_right&quot;</code>, <code>&quot;front_left&quot;</code>, <code>&quot;fpv&quot;</code>, <code>&quot;back_center&quot;</code>. FPV 相机处于驾驶员头部位置 (First Person Virsion, 第一人称视角).</p><h3 id="飞行器"><a class="header-anchor" href="#飞行器">¶</a>飞行器</h3><p><code>API</code> 可以通过一下相机名称调用: <code>front_center</code>, <code>front_right</code>, <code>front_left</code>, <code>bottom_center</code> 和<code>back_center</code>.</p><h3 id="计算机视觉模式"><a class="header-anchor" href="#计算机视觉模式">¶</a>计算机视觉模式</h3><p>和飞行器的一致.</p><h3 id="向后兼容的相机名称"><a class="header-anchor" href="#向后兼容的相机名称">¶</a>向后兼容的相机名称</h3><p>在 AirSim v1. 2 之前, 相机是通过 ID 来指定的. 考虑到向后兼容, 依然可以用下相机的 ID 序号来代替, 顺序与上述名称保持一直. 此外, 相机名称为空字符串 <code>&quot;&quot;</code> 也是可以的, 也就是默认相机, 通常为 <code>&quot;0&quot;</code> .</p><h2 id="“Computer-Vision”-模式"><a class="header-anchor" href="#“Computer-Vision”-模式">¶</a>“Computer Vision” 模式</h2><p>可以在 AirSim 中使用 “Computer Virsion” 模式. 在这个模式下, 物理引擎被禁用, 没有载具, 只有相机. 可以通过键盘移动视角 (按 F1 可以看帮助). 可以按下 Record 按钮来持续生成图片. 或者可以调用 APIs 来移动相机和获取图片.</p><p>编辑 <a href="https://microsoft.github.io/AirSim/settings/" target="_blank" rel="noopener">settings. json</a> 文件可以激活这种模式. 在用户的 <code>Documents\AirSim</code> 文件夹内 (Linux 则在 <code>Documents\AirSim</code>) 然后更改下列变量的值.</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"SettingsVersion"</span>: <span class="number">1.</span> <span class="number">2</span>,</span><br><span class="line">  <span class="attr">"SimMode"</span>: <span class="string">"ComputerVision"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/Microsoft/AirSim/tree/master/PythonClient//computer_vision/cv_mode.py" target="_blank" rel="noopener">Python 例程</a> 移动相机并获取图片.</p><p>这是模式是受 <a href="http://unrealcv.org/" target="_blank" rel="noopener">UnrealCV project</a> 启发的.</p><p><strong>PS</strong>:</p><ul><li>我这里提供了 C++ 的版本, 直接用 OpenCV 动态显示了, 没有保存成图片格式.</li><li><code>settings. json</code> 编辑完成后, 不需要重启 UE 编辑器, 只要重新运行当前项目即可.</li><li>方向键调整相机位置(前后左右), wasd 调整朝向.</li><li>欧拉角转四元数可以参考 Eigen 库, 这里没写.</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ImageAPIs::CVMode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">namespace</span> msr::airlib;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">typedef</span> ImageCaptureBase::ImageRequest ImageRequest;</span><br><span class="line">  <span class="keyword">typedef</span> ImageCaptureBase::ImageResponse ImageResponse;</span><br><span class="line">  <span class="keyword">typedef</span> ImageCaptureBase::ImageType ImageType;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// for car use</span></span><br><span class="line">  msr::airlib::MultirotorRpcLibClient client;</span><br><span class="line">  client. confirmConnection();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Press any key to set camera-0 gimble to 15-degree pitch. \n"</span>;</span><br><span class="line">  <span class="built_in">std</span>::getchar();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// TODO client. simSetCameraOrientation();</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Press any key to get camera parameters. \n"</span>;</span><br><span class="line">  <span class="built_in">std</span>::getchar();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> camera_name = <span class="number">0</span>; camera_name &lt; <span class="number">5</span>; ++camera_name) &#123;</span><br><span class="line">    CameraInfo camera_info = client. simGetCameraInfo(<span class="built_in">std</span>::to_string(camera_name));</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"CameraInfo "</span> &lt;&lt; camera_name &lt;&lt; <span class="string">": \n"</span></span><br><span class="line">              &lt;&lt; <span class="string">"Pose: "</span> &lt;&lt; camera_info. pose. <span class="built_in">position</span>. x() &lt;&lt; <span class="string">" "</span> &lt;&lt; camera_info. pose. <span class="built_in">position</span>. y() &lt;&lt; <span class="string">" "</span></span><br><span class="line">              &lt;&lt; camera_info. pose. <span class="built_in">position</span>. z() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span></span><br><span class="line">              &lt;&lt; <span class="string">"FOV: "</span> &lt;&lt; camera_info. fov &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// get right, left and depth images. First two as png, second as float16.</span></span><br><span class="line">  msr::airlib::<span class="built_in">vector</span>&lt;ImageRequest&gt; request = &#123;ImageRequest(<span class="string">"0"</span>, ImageType::DepthVis),</span><br><span class="line">                                               ImageRequest(<span class="string">"1"</span>, ImageType::DepthPerspective, <span class="literal">true</span>),</span><br><span class="line">                                               ImageRequest(<span class="string">"2"</span>, ImageType::Segmentation),</span><br><span class="line">                                               ImageRequest(<span class="string">"3"</span>, ImageType::Scene),</span><br><span class="line">                                               ImageRequest(<span class="string">"4"</span>, ImageType::DisparityNormalized),</span><br><span class="line">                                               ImageRequest(<span class="string">"4"</span>, ImageType::SurfaceNormals)&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">/* TODO</span></span><br><span class="line"><span class="comment">   client. simSetVehiclePose();</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> msr::airlib::<span class="built_in">vector</span>&lt;ImageResponse&gt;&amp; responses = client. simGetImages(request);</span><br><span class="line">    <span class="comment">// do something with response which contains image data, pose, timestamp etc</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; responses. <span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">      <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">strid</span><span class="params">(<span class="built_in">std</span>::to_string(i))</span></span>;</span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">auto</span>&amp; response = responses. at(i);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (response. pixels_as_float) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Type "</span> &lt;&lt; <span class="keyword">int</span>(response. image_type) &lt;&lt; <span class="string">", size "</span> &lt;&lt; response. image_data_float. <span class="built_in">size</span>() &lt;&lt; <span class="string">", pos "</span></span><br><span class="line">                  &lt;&lt; response. camera_position. x() &lt;&lt; <span class="string">" "</span> &lt;&lt; response. camera_position. y() &lt;&lt; <span class="string">" "</span></span><br><span class="line">                  &lt;&lt; response. camera_position. z() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Type "</span> &lt;&lt; <span class="keyword">int</span>(response. image_type) &lt;&lt; <span class="string">", size "</span> &lt;&lt; response. image_data_uint8. <span class="built_in">size</span>() &lt;&lt; <span class="string">", pos "</span></span><br><span class="line">                  &lt;&lt; response. camera_position. x() &lt;&lt; <span class="string">" "</span> &lt;&lt; response. camera_position. y() &lt;&lt; <span class="string">" "</span></span><br><span class="line">                  &lt;&lt; response. camera_position. z() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">switch</span> (response. image_type) &#123;</span><br><span class="line">        <span class="keyword">case</span> ImageType::Scene:</span><br><span class="line">          <span class="keyword">if</span> (!response. pixels_as_float &amp;&amp; response.compress) &#123;</span><br><span class="line">            cv::Mat img_mat = cv::imdecode(response. image_data_uint8, cv::IMREAD_UNCHANGED);</span><br><span class="line">            cv::imshow(response. camera_name + <span class="string">":Scene-"</span> + strid, img_mat);</span><br><span class="line">            cv::waitKey(<span class="number">5</span>);</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!response. pixels_as_float &amp;&amp; !response.compress) &#123;</span><br><span class="line">            cv::Mat img_mat(response. <span class="built_in">height</span>, response. <span class="built_in">width</span>, CV_8UC3, (<span class="keyword">void</span>*)response. image_data_uint8. data());</span><br><span class="line">            cv::imshow(response. camera_name + <span class="string">":Scene-"</span> + strid, img_mat);</span><br><span class="line">            cv::waitKey(<span class="number">5</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> ImageType::DepthPlanner:</span><br><span class="line">          <span class="keyword">if</span> (!response. pixels_as_float &amp;&amp; response.compress) &#123;</span><br><span class="line">            cv::Mat img_mat = cv::imdecode(response. image_data_uint8, cv::IMREAD_GRAYSCALE);</span><br><span class="line">            cv::imshow(response. camera_name + <span class="string">":DepthPlanner-"</span> + strid, img_mat);</span><br><span class="line">            cv::waitKey(<span class="number">5</span>);</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (response. pixels_as_float &amp;&amp; response.compress) &#123;</span><br><span class="line">            cv::Mat img_mat(response. <span class="built_in">height</span>, response. <span class="built_in">width</span>, CV_32FC1, (<span class="keyword">void</span>*)response. image_data_float. data());</span><br><span class="line">            cv::normalize(img_mat, img_mat, <span class="number">1</span>, <span class="number">0</span>, cv::NORM_MINMAX);</span><br><span class="line">            cv::imshow(response. camera_name + <span class="string">":DepthPlanner-"</span> + strid, img_mat);</span><br><span class="line">            cv::waitKey(<span class="number">5</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ImageType::DepthPerspective:</span><br><span class="line">          <span class="keyword">if</span> (!response. pixels_as_float &amp;&amp; response.compress) &#123;</span><br><span class="line">            cv::Mat img_mat = cv::imdecode(response. image_data_uint8, cv::IMREAD_GRAYSCALE);</span><br><span class="line">            cv::imshow(response. camera_name + <span class="string">":DepthPerspective-"</span> + strid, img_mat);</span><br><span class="line">            cv::waitKey(<span class="number">5</span>);</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (response. pixels_as_float &amp;&amp; response.compress) &#123;</span><br><span class="line">            <span class="comment">// cv::Mat img_mat = cv::imdecode(response. image_data_float, cv::IMREAD_GRAYSCALE);</span></span><br><span class="line">            cv::Mat img_mat(response. <span class="built_in">height</span>, response. <span class="built_in">width</span>, CV_32FC1, (<span class="keyword">void</span>*)response. image_data_float. data());</span><br><span class="line">            cv::normalize(img_mat, img_mat, <span class="number">1</span>, <span class="number">0</span>, cv::NORM_MINMAX);</span><br><span class="line">            cv::imshow(response. camera_name + <span class="string">":DepthPerspective-"</span> + strid, img_mat);</span><br><span class="line">            cv::waitKey(<span class="number">5</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ImageType::DepthVis:</span><br><span class="line">          <span class="keyword">if</span> (!response. pixels_as_float &amp;&amp; response.compress) &#123;</span><br><span class="line">            cv::Mat img_mat = cv::imdecode(response. image_data_uint8, cv::IMREAD_GRAYSCALE);</span><br><span class="line">            cv::imshow(response. camera_name + <span class="string">":DepthVis-"</span> + strid, img_mat);</span><br><span class="line">            cv::waitKey(<span class="number">5</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ImageType::DisparityNormalized:</span><br><span class="line">          <span class="keyword">if</span> (response. pixels_as_float) &#123;</span><br><span class="line">            <span class="function">cv::Mat <span class="title">img_mat</span><span class="params">(response. <span class="built_in">height</span>, response. <span class="built_in">width</span>, CV_32FC1, (<span class="keyword">void</span>*)response. image_data_float. data())</span></span>;</span><br><span class="line">            cv::normalize(img_mat, img_mat, <span class="number">1</span>, <span class="number">0</span>, cv::NORM_MINMAX);</span><br><span class="line">            cv::imshow(response. camera_name + <span class="string">":DisparityNormalized-"</span> + strid, img_mat);</span><br><span class="line">            cv::waitKey(<span class="number">5</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ImageType::Segmentation:</span><br><span class="line">          <span class="keyword">if</span> (!response. pixels_as_float &amp;&amp; response.compress) &#123;</span><br><span class="line">            cv::Mat img_mat = cv::imdecode(response. image_data_uint8, cv::IMREAD_UNCHANGED);</span><br><span class="line">            cv::imshow(response. camera_name + <span class="string">":Segmentation-"</span> + strid, img_mat);</span><br><span class="line">            cv::waitKey(<span class="number">5</span>);</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!response. pixels_as_float &amp;&amp; !response.compress) &#123;</span><br><span class="line">            cv::Mat img_mat(response. <span class="built_in">height</span>, response. <span class="built_in">width</span>, CV_8UC3, (<span class="keyword">void</span>*)response. image_data_uint8. data());</span><br><span class="line">            cv::imshow(response. camera_name + <span class="string">":Segmentation-"</span> + strid, img_mat);</span><br><span class="line">            cv::waitKey(<span class="number">5</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ImageType::SurfaceNormals:</span><br><span class="line">          <span class="keyword">if</span> (!response. pixels_as_float &amp;&amp; response.compress) &#123;</span><br><span class="line">            cv::Mat img_mat = cv::imdecode(response. image_data_uint8, cv::IMREAD_UNCHANGED);</span><br><span class="line">            cv::imshow(response. camera_name + <span class="string">":SurfaceNormals-"</span> + strid, img_mat);</span><br><span class="line">            cv::waitKey(<span class="number">5</span>);</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!response. pixels_as_float &amp;&amp; !response.compress) &#123;</span><br><span class="line">            cv::Mat img_mat(response. <span class="built_in">height</span>, response. <span class="built_in">width</span>, CV_8UC3, (<span class="keyword">void</span>*)response. image_data_uint8. data());</span><br><span class="line">            cv::imshow(response. camera_name + <span class="string">":SurfaceNormals-"</span> + strid, img_mat);</span><br><span class="line">            cv::waitKey(<span class="number">5</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">auto</span> pose = client. simGetVehiclePose();</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Vehicle Pose: "</span> &lt;&lt; pose. <span class="built_in">position</span>. x() &lt;&lt; <span class="string">" "</span> &lt;&lt; pose. <span class="built_in">position</span>. y() &lt;&lt; <span class="string">" "</span> &lt;&lt; pose. <span class="built_in">position</span>. y()</span><br><span class="line">                &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img data-src="image-20200613184934655.png" alt="image-20200613184934655"></p><h3 id="在-Computer-Vision-模式下设置位姿"><a class="header-anchor" href="#在-Computer-Vision-模式下设置位姿">¶</a>在 Computer Vision 模式下设置位姿</h3><p>为了在环境中通过 <code>APIs</code> 移动, 可以用过 <code>simSetVehiclePose</code> API. 这个 API 传入位置和姿态参数, 将不可见的载具设置在 <code>front-center</code> 相机所处的位置. 其他的相机保持相对的位置移动. 如果不想改变位置或者姿态, 只需要将位置和姿态设置为 nan 的浮点数. <code>simGetVehiclePose</code> 可以获取当前位姿, 你可以用 <code>simGetGroundTruthKinematics</code> 来获取 quantities kinematics quantities for the movement (不太明白这意思). 还有很多其他无载具特定的 APIs 也是可用, 比如 分割 APIs, 碰撞 APIs, 相机 APIs.</p><h2 id="相机-APIs"><a class="header-anchor" href="#相机-APIs">¶</a>相机 APIs</h2><p><code>simGetCameraInfo</code> 返回指定相机的位姿 (世界场景, NED 坐标系, 国际标准单位制) 和 FOV (角度) . 可参考例程 <a href="https://github.com/Microsoft/AirSim/tree/master/PythonClient//computer_vision/cv_mode.py" target="_blank" rel="noopener">example usage</a>.</p><p><code>simSetCameraOrientation</code> 设置指定相机在 NED 坐标系下的位姿(四元数). 函数 <code>airsim. to_quaternion()</code> 用来将俯仰, 翻转, 偏航角度转化为四元数, 举个例子, 设置相机 - 0 倾斜角度为 15 度, 可以用 (<strong>PS</strong>: 这个是 Python 版本, C++ 没找到, 可以自己用 Eigen 库实现) :</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">client. simSetCameraOrientation(<span class="number">0</span>, airsim. to_quaternion(<span class="number">0.</span> <span class="number">261799</span>, <span class="number">0</span>, <span class="number">0</span>)); <span class="comment">#radians</span></span><br></pre></td></tr></table></figure><h3 id="Gimbal"><a class="header-anchor" href="#Gimbal">¶</a>Gimbal</h3><p>可以 <a href="https://microsoft.github.io/AirSim/settings/#gimbal" target="_blank" rel="noopener">using settings</a> 将任意相机设置为俯仰, 翻转, 偏航角度.</p><p>请参考 <a href="https://github.com/Microsoft/AirSim/tree/master/PythonClient//computer_vision/cv_mode.py" target="_blank" rel="noopener">example usage</a>.</p><h2 id="修改分辨率和相机参数"><a class="header-anchor" href="#修改分辨率和相机参数">¶</a>修改分辨率和相机参数</h2><p>通过 <a href="https://microsoft.github.io/AirSim/settings/" target="_blank" rel="noopener">settings. json</a> 可以修改分辨率和视场角. 举个例子, 下述 settings. json 的额外部分设置了捕捉场景的参数, 并用前述的 “Computer Version” 模式. 如果你省略了任何设置, 下述默认参数将会被使用. 更多设置参见 <a href="https://microsoft.github.io/AirSim/settings/" target="_blank" rel="noopener">settings doc</a>. 如果你正在使用立体相机, 左右两个相机的固定距离是 25 cm.</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"SettingsVersion"</span>: <span class="number">1.</span> <span class="number">2</span>,</span><br><span class="line">  <span class="attr">"CameraDefaults"</span>: &#123;</span><br><span class="line">    <span class="attr">"CaptureSettings"</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"ImageType"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">"Width"</span>: <span class="number">256</span>,</span><br><span class="line">        <span class="attr">"Height"</span>: <span class="number">144</span>,</span><br><span class="line">        <span class="attr">"FOV_Degrees"</span>: <span class="number">90</span>,</span><br><span class="line">        <span class="attr">"AutoExposureSpeed"</span>: <span class="number">100</span>,</span><br><span class="line">        <span class="attr">"MotionBlurAmount"</span>: <span class="number">0</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"SimMode"</span>: <span class="string">"ComputerVision"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="在不同的图像类型像素值表示什么"><a class="header-anchor" href="#在不同的图像类型像素值表示什么">¶</a>在不同的图像类型像素值表示什么</h2><h3 id="可用的图像类型"><a class="header-anchor" href="#可用的图像类型">¶</a>可用的图像类型</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Scene = <span class="number">0</span>,</span><br><span class="line">DepthPlanner = <span class="number">1</span>,</span><br><span class="line">DepthPerspective = <span class="number">2</span>,</span><br><span class="line">DepthVis = <span class="number">3</span>,</span><br><span class="line">DisparityNormalized = <span class="number">4</span>,</span><br><span class="line">Segmentation = <span class="number">5</span>,</span><br><span class="line">SurfaceNormals = <span class="number">6</span>,</span><br><span class="line">Infrared = <span class="number">7</span></span><br></pre></td></tr></table></figure><h3 id="DepthPlanner-and-DepthPerspective"><a class="header-anchor" href="#DepthPlanner-and-DepthPerspective">¶</a>DepthPlanner and DepthPerspective</h3><p>通常你希望在接收到 float 表示的深度图像 ( 即在<code>ImageRequest</code> 将设置 <code>pixels_as_float = true</code>) 然后指定 <code>ImageType = DepthPlanner</code> 或者 <code>ImageType = DepthPerspective</code> . 对于 <code>ImageType = DepthPlanner</code>, 将获得获得深度, 即所有与相机处于相同距离的点具有相同的深度. 对于 <code>ImageType = DepthPerspective</code>, 通过射向像素点的射线来获取深度. 取决与使用的案例, 平行深度或者透视深度可能是所需的真正图像. 举个例子, 你可能对 ROS 包发布透视深度, 例如 <code>depth_image_proc</code> 来生成点云. 或者平行深度可能通过立体视觉算法, 例如 SGM, 用来估计深度图像的生成.</p><h3 id="DepthVis"><a class="header-anchor" href="#DepthVis">¶</a>DepthVis</h3><p>当在 <code>ImageRequest</code> 指定 <code>ImageType = DepthVis</code>, 将获得一副有助于可视化深度的图像. 在这种请跨下, 每个像素值是米值的根据相机平面从白到黑的插值. 纯白的像素意味着深度超过 100 m, 纯黑意味着深度为 0 m.</p><h3 id="DisparityNormalized"><a class="header-anchor" href="#DisparityNormalized">¶</a>DisparityNormalized</h3><p>通常你希望在接收到 float 表示的深度图像 ( 即在<code>ImageRequest</code> 设置 <code>pixels_as_float = true</code> <code>ImageType = DisparityNormalized</code> ) . 这种情况下, 每个像素值是 <code>(Xl - Xr)/Xmax</code>, 即被归一化为 0 到 1 之间的值.</p><h3 id="Segmentation"><a class="header-anchor" href="#Segmentation">¶</a>Segmentation</h3><p>当在 <code>ImageRequest</code> 指定 <code>ImageType = Segmentation</code> , 将获取到真实场景的分割图. 在启动时, AirSim 给环境中每块网格分配 0 到 255 的值. 这些值将映射 <a href="https://github.com/Microsoft/AirSim/tree/master/Unreal//Plugins/AirSim/Content/HUDAssets/seg_color_pallet.png" target="_blank" rel="noopener">the pallet</a> 中指定的颜色. 每个对象的 ID 可以在 <a href="https://microsoft.github.io/AirSim/seg_rgbs.txt" target="_blank" rel="noopener">this file</a> 找到.</p><p>你可以通过 APIs 给指定的网格分配指定的值 (范围限制在 0-255) . 举个例子, 下述的 Python (PS: C++ 代码相同) 代码给一个对象 ID 为 ”Ground“ 在 Blocks 环境中的值为 20, 所以改变了该对象在分割视图中的颜色:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">success = client. simSetSegmentationObjectID(<span class="string">"Ground"</span>, <span class="number">20</span>);</span><br></pre></td></tr></table></figure><p>返回的布尔值表示是否找到该网格.</p><p>主要, 典型的 Unreal 环境中, 像 Blocks, 通常有很多其他有相同对象组成的网格, 举个例子, “Ground_2”, “Ground_3” 等等. 因为对所有网格设置对象 ID 是很冗杂的, AirSim 也支持正则表达式. 举个例子, 以下只用了一行代码设置了名称以 ”ground“ 开头的所有网格为 21 (忽略大小写) :</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">success = client. simSetSegmentationObjectID(<span class="string">"ground[\w]*"</span>, <span class="number">21</span>, <span class="literal">True</span>);</span><br></pre></td></tr></table></figure><p>如果至少有一个网格被正则表达式匹配, 则返回 true.</p><p>建议通过这个 API 来请求未压缩的分割图像, 确保获取到精确的 RGB 值:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">responses = client. simGetImages([ImageRequest(<span class="number">0</span>, AirSimImageType. Segmentation, <span class="literal">False</span>, <span class="literal">False</span>)])</span><br><span class="line">img1d = np. fromstring(response. image_data_uint8, dtype=np. uint8) <span class="comment">#get numpy array</span></span><br><span class="line">img_rgb = img1d. reshape(response. height, response. width, <span class="number">3</span>) <span class="comment">#reshape array to 3 channel image array H X W X 3</span></span><br><span class="line">img_rgb = np. flipud(img_rgb) <span class="comment">#original image is fliped vertically</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#find unique colors</span></span><br><span class="line">print(np. unique(img_rgb[:, :, <span class="number">0</span>], return_counts=<span class="literal">True</span>)) <span class="comment">#red</span></span><br><span class="line">print(np. unique(img_rgb[:, :, <span class="number">1</span>], return_counts=<span class="literal">True</span>)) <span class="comment">#green</span></span><br><span class="line">print(np. unique(img_rgb[:, :, <span class="number">2</span>], return_counts=<span class="literal">True</span>)) <span class="comment">#blue</span></span><br></pre></td></tr></table></figure><p>完整可运行的程序见 <a href="https://github.com/Microsoft/AirSim/tree/master/PythonClient//computer_vision/segmentation.py" target="_blank" rel="noopener">segmentation. py</a>.</p><h4 id="Unsetting-object-ID"><a class="header-anchor" href="#Unsetting-object-ID">¶</a>Unsetting object ID</h4><p>如果不想在分割图像中显示对象, 可以设置对象 ID 为 -1.</p><h4 id="如何找到网格的名字"><a class="header-anchor" href="#如何找到网格的名字">¶</a>如何找到网格的名字</h4><p>为了获取真实的分割图, 你需要知道在 Unreal 环境中的网格名称. 打开 UE 编辑器中的 Unreal 环境, 然后在世界大纲视图 (World Outliner) 中找到感兴趣的网格. 举个例子, 下述图片我们可以在右侧 Blocks 环境面板中看到 ground 的网格名称:</p><p><img data-src="https://microsoft.github.io/AirSim/images/unreal_editor_blocks.png" alt="record screenshot"></p><p>如果你不知道如何在 Unreal 编辑器中打开 Unreal 环境, 可以参考下列教程 <a href="https://microsoft.github.io/AirSim/build_windows/" target="_blank" rel="noopener">building from source</a>.</p><p>一旦你决定你感兴趣的网格, 几下它们的名称, 然后通过上述的 API 来设置它们的 object IDs. 这里有 <a href="https://microsoft.github.io/AirSim/settings/#segmentation-settings" target="_blank" rel="noopener">few settings</a> 来改变生成 object ID 的行为.</p><h4 id="修改-Object-IDs-的颜色"><a class="header-anchor" href="#修改-Object-IDs-的颜色">¶</a>修改 Object IDs 的颜色</h4><p>目前每个对象 ID 都在 <a href="https://github.com/Microsoft/AirSim/tree/master/Unreal//Plugins/AirSim/Content/HUDAssets/seg_color_pallet.png" target="_blank" rel="noopener">this pallet</a> 被固定. 我们将很快增加改变 object IDs 颜色的功能. 同时, 你将可以在你喜欢的图像编辑器中打开分割图, 然后获取你感兴趣的 RGB 值.</p><h4 id="Startup-Object-IDs"><a class="header-anchor" href="#Startup-Object-IDs">¶</a>Startup Object IDs</h4><p>开始时, AirSim 给能在环境中的<code>UStaticMeshComponent</code> 或者 <code>ALandscapeProxy</code> 类型的每个对象分配了 object id. 然后使用网格名称或者本身的名称 (取决于设置), 转换为小写, 移除所有小于 ASCII 97 的字符以移除数字和一些标点, 对所有字符求和并除以 255 取模来生成 object id. 换句话说, 所具有相同字符的对象将有相同的 object ID. 这个启发对于很多 Unreal 环境很简单也有有效, 但是可能不是你想要的. 这种情况下, 请用上面的 APIs 来修改 object IDs 为你想要的值. 这里可以设置可能修改这些表现 r.</p><h4 id="为网格获取-Object-ID"><a class="header-anchor" href="#为网格获取-Object-ID">¶</a>为网格获取 Object ID</h4><p><code>simGetSegmentationObjectID</code> API 允许你获取一个指定网格名称的 object ID.</p><h3 id="Infrared"><a class="header-anchor" href="#Infrared">¶</a>Infrared</h3><p>目前, 这只是将 object ID 映射为 0-255 灰度域的映射. 所以很多 object ID 42 的网格均已 (42, 42, 42) 的颜色显示. 请参考 <a href="https://microsoft.github.io/AirSim/image_apis/#segmentation" target="_blank" rel="noopener">segmentation section</a> 获取如何设置 object IDs 更多的细节. 通常, 噪声设置可以被运用在这种图像类型, 以获取细微的更加真实效果. 我们依然在增加其他的 infrared artifacts 方面展开工作, 也欢迎任何的 contributions .</p><h2 id="例程代码"><a class="header-anchor" href="#例程代码">¶</a>例程代码</h2><p>设置载具到任意方位和获取图片的代码可以在 <a href="https://github.com/Microsoft/AirSim/tree/master/Examples/DataCollection/StereoImageGenerator.hpp" target="_blank" rel="noopener">GenerateImageGenerator. hpp</a> 找到. 这个例程生成指定数量的立体图像和地面实况视差图像, 并保存为 <a href="https://microsoft.github.io/AirSim/pfm/" target="_blank" rel="noopener">pfm format</a>.</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>自动驾驶</category>
      </categories>
      <tags>
        <tag>自动驾驶</tag>
        <tag>AirSim</tag>
      </tags>
  </entry>
  <entry>
    <title>自动驾驶仿真 - AirSim (4) - 核心 APIs - C++</title>
    <url>/posts/1307933338/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><!-- build time:Sat Nov 13 2021 15:45:21 GMT+0000 (Coordinated Universal Time) --><p>接下去主要介绍一下 <code>AirSim</code> 的 <code>APIs</code> 的使用. <a href="https://microsoft.github.io/AirSim/apis/" target="_blank" rel="noopener">官方</a> 提供了 <code>Python</code> 和 <code>C++</code> 两个版本, 我这里就主要以 <code>C++</code> 来试验.</p><p>这篇文章的 <code>Hello Car</code> 的<a href="https://microsoft.github.io/AirSim/apis_cpp/#hello_car" target="_blank" rel="noopener">源码</a>.</p><a id="more"></a><hr><p>[TOC]</p><hr><h2 id="Hello-Car-源码"><a class="header-anchor" href="#Hello-Car-源码">¶</a><code>Hello Car</code> 源码</h2><p>官方<a href="https://microsoft.github.io/AirSim/apis_cpp/#quick-start" target="_blank" rel="noopener">文档</a>该部分的源码还没有更新, 这里源码为 <a href="https://github.com/Microsoft/AirSim/blob/master/HelloCar/main.cpp" target="_blank" rel="noopener">GitHub</a>上的源码. 如果要用文档的例程, 需要把 <code>两处</code></p><blockquote><p><s><code>CarControllerBase::CarControls</code></s></p></blockquote><p>改为</p><blockquote><p><code>msr::airlib::CarApiBase::CarControls</code></p></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Copyright (c) Microsoft Corporation. All rights reserved.</span></span><br><span class="line"><span class="comment">// Licensed under the MIT License.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"common/common_utils/StrictMode.hpp"</span></span></span><br><span class="line">STRICT_MODE_OFF</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> RPCLIB_MSGPACK</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RPCLIB_MSGPACK clmdep_msgpack</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// !RPCLIB_MSGPACK</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"rpc/rpc_error.h"</span></span></span><br><span class="line">STRICT_MODE_ON</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"vehicles/car/api/CarRpcLibClient.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"common/common_utils/FileSystem.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> msr::airlib;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Make sure settings.json has \"SimMode\"=\"Car\" at root. Press Enter to continue."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="built_in">std</span>::<span class="built_in">cin</span>.<span class="built_in">get</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This assumes you are running DroneServer already on the same machine.</span></span><br><span class="line">    <span class="comment">// DroneServer must be running first.</span></span><br><span class="line">    msr::airlib::CarRpcLibClient client;</span><br><span class="line">    <span class="keyword">typedef</span> ImageCaptureBase::ImageRequest ImageRequest;</span><br><span class="line">    <span class="keyword">typedef</span> ImageCaptureBase::ImageResponse ImageResponse;</span><br><span class="line">    <span class="keyword">typedef</span> ImageCaptureBase::ImageType ImageType;</span><br><span class="line">    <span class="keyword">typedef</span> common_utils::<span class="built_in">FileSystem</span> <span class="built_in">FileSystem</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        client.confirmConnection();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Press Enter to get FPV image"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="built_in">std</span>::<span class="built_in">cin</span>.<span class="built_in">get</span>();</span><br><span class="line">        <span class="built_in">vector</span>&lt;ImageRequest&gt; request = &#123; ImageRequest(<span class="string">"0"</span>, ImageType::Scene), ImageRequest(<span class="string">"1"</span>, ImageType::DepthPlanner, <span class="literal">true</span>) &#125;;</span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">vector</span>&lt;ImageResponse&gt;&amp; response = client.simGetImages(request);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"# of images received: "</span> &lt;&lt; response.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (response.<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter path with ending separator to save images (leave empty for no save)"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">string</span> path;</span><br><span class="line">            <span class="built_in">std</span>::getline(<span class="built_in">std</span>::<span class="built_in">cin</span>, path);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> ImageResponse&amp; image_info : response) &#123;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Image uint8 size: "</span> &lt;&lt; image_info.image_data_uint8.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Image float size: "</span> &lt;&lt; image_info.image_data_float.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (path != <span class="string">""</span>) &#123;</span><br><span class="line">                    <span class="built_in">std</span>::<span class="built_in">string</span> file_path = <span class="built_in">FileSystem</span>::combine(path, <span class="built_in">std</span>::to_string(image_info.time_stamp));</span><br><span class="line">                    <span class="keyword">if</span> (image_info.pixels_as_float) &#123;</span><br><span class="line">                        Utils::writePfmFile(image_info.image_data_float.data(), image_info.<span class="built_in">width</span>, image_info.<span class="built_in">height</span>,</span><br><span class="line">                            file_path + <span class="string">".pfm"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="built_in">std</span>::ofstream file(file_path + <span class="string">".png"</span>, <span class="built_in">std</span>::ios::binary);</span><br><span class="line">                        file.<span class="built_in">write</span>(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt;(image_info.image_data_uint8.data()), image_info.image_data_uint8.<span class="built_in">size</span>());</span><br><span class="line">                        file.<span class="built_in">close</span>();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//enable API control</span></span><br><span class="line">        client.enableApiControl(<span class="literal">true</span>);</span><br><span class="line">        CarApiBase::CarControls controls;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Press enter to drive forward"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="built_in">std</span>::<span class="built_in">cin</span>.<span class="built_in">get</span>();</span><br><span class="line">        controls.throttle = <span class="number">0.5f</span>;</span><br><span class="line">        controls.steering = <span class="number">0.0f</span>;</span><br><span class="line">        client.setCarControls(controls);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Press Enter to activate handbrake"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="built_in">std</span>::<span class="built_in">cin</span>.<span class="built_in">get</span>();</span><br><span class="line">        controls.handbrake = <span class="literal">true</span>;</span><br><span class="line">        client.setCarControls(controls);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Press Enter to take turn and drive backward"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="built_in">std</span>::<span class="built_in">cin</span>.<span class="built_in">get</span>();</span><br><span class="line">        controls.handbrake = <span class="literal">false</span>;</span><br><span class="line">        controls.throttle = <span class="number">-0.5</span>;</span><br><span class="line">        controls.steering = <span class="number">1</span>;</span><br><span class="line">        controls.is_manual_gear = <span class="literal">true</span>;</span><br><span class="line">        controls.manual_gear = <span class="number">-1</span>;</span><br><span class="line">        client.setCarControls(controls);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Press Enter to stop"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="built_in">std</span>::<span class="built_in">cin</span>.<span class="built_in">get</span>();</span><br><span class="line">        client.setCarControls(CarApiBase::CarControls());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (rpc::rpc_error&amp;  e) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> msg = e.get_error().as&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;();</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Exception raised by the API, something went wrong."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span> &lt;&lt; msg &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="built_in">std</span>::<span class="built_in">cin</span>.<span class="built_in">get</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Common-APIS"><a class="header-anchor" href="#Common-APIS">¶</a><code>Common APIS</code></h2><p>以下方法均在类： <code>msr::airlib::CarRpcLibClient</code></p><ul><li><p><code>reset</code>: 重置汽车回初始状态 (PS: 调用这个方法, 汽车会重新出现在出生点, 状态均重置) . 你必须在调用 <code>reset</code> 之后再次调用 <code>enableApiControl</code> 和 <code>armDisarm</code></p><p>(<strong>PS</strong>: 好像不调用这两个函数, 其他方法依然生效, 不晓得是不是版本更新过的缘故) .</p></li><li><p><code>confirmConnection</code>: 每隔 1 秒检查链接状态, 并且在控制台输出连接进展.</p></li><li><p><code>enableApiControl</code>: 处于安全原因, 默认禁止 API 控制自动驾驶汽车, 完全人工控制的 (通常通过 RC 或者 手柄模拟) . 用户必须调用这个函数去请求通过 API 控制. 这就像人工驾驶汽车可能禁止 API 控制, 意味着<code>enableApiControl</code> 是不起作用的. 这个可以通过<code>isApiControlEnabled</code> 来检查.</p></li><li><p><code>isApiControlEnabled</code>: 返回 true 如果 API 控制被建立了. 如果是 false (默认设置), API 调用将会被忽略. 当成功调用<code>enableApiControl</code>, <code>isApiControlEnabled</code> 将返回 true.</p><p><strong>PS</strong>: 默认好像是 true.</p></li><li><p><code>ping</code>: 如果建立连接, 这个调用将会返回 true, 否则会阻塞知道直到超时.</p></li><li><p><code>simPrintLogMessage</code>: 在仿真窗口输出指定的 <code>message</code>. 如果 <code>message_param</code>也被提供, 那么也将输出. 如果这个 API 被调用时使用相同的 <code>message</code>值, 但是 <code>message_param</code>不同, 那么前一行将会被新行覆盖 (而不是创建新行来显示) . 举个例子, 当使用不同的 i 值调用 <code>simPrintLogMessage(&quot;Iteration: &quot;, to_string(i))</code> 时, 将在同一行保持更新. 合法的 severity 参数是 0 到 3, 分别以不同的颜色.</p><p><strong>PS</strong>: 不知道在哪儿看到这些输出日志).</p></li><li><p><code>simGetObjectPose</code>, <code>simSetObjectPose</code>: 获取和设置 Unreal 环境中指定对象的位姿. 这里的对象表示 Unreal 术语中的 ”actor”. 它们通过标签 (tag) 和名称 (name) 来搜索. 请记住这些显示在 UE Editor 中的名称是每次运行时 <em>自动生成 (auto-generated)</em> 的, 并非永久的. 所以, 如果你想通过名称来引用 actor, 你必须在 UE Editor 中修改自动生成的名称. 你也可以在 Unreal Editor 中, 通过点击 actor 来完成对它添加一个标签. 然后去 <a href="https://answers.unrealengine.com/questions/543807/whats-the-difference-between-tag-and-tag.html" target="_blank" rel="noopener">Tags property</a> , 点击 “+” 号, 添加一些字符串值. 如果多个 actors 有相同的标签, 那么第一个符合的将会被返回. 如果没有符合的对象被找到, 那么将会返回 NaN. 返回的位姿值是在以玩家出生点为原点的 NED 坐标系下的国际标准单位值. 对于<code>simSetObjectPose</code>, 指定的 actor 必须将 <a href="https://docs.unrealengine.com/en-us/Engine/Actors/Mobility" target="_blank" rel="noopener">Mobility</a> 设置为可移动, 否则你将得到未定义行为. <code>simSetObjectPose</code> 有一个 <code>teleport</code> 参数, 表示对象正在 <a href="https://www.unrealengine.com/en-US/blog/moving-physical-objects" target="_blank" rel="noopener">moved through other objects</a> (<strong>PS</strong>： 瞬移？) , 如果移动成功, 则返回 true.</p><p><strong>PS:</strong> 见下图，如果要获取这辆车的位姿，调用的参数名应该是 <code>PhysXCar</code>, 调用 <code>SuvCarPawn-1</code> (自动生成的名称) 位姿值是 <code>NaN</code></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">msr::airlib::Pose pose_car = client.simGetObjectPose(<span class="string">"PhysXCar"</span>);</span><br></pre></td></tr></table></figure><p><img data-src="image-20200609012940736.png" alt="image-20200609012940736"></p></li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>自动驾驶</category>
      </categories>
      <tags>
        <tag>自动驾驶</tag>
        <tag>AirSim</tag>
      </tags>
  </entry>
  <entry>
    <title>自动驾驶仿真 - AirSim (3) - 配置 Visual Studio 工程</title>
    <url>/posts/531482360/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><!-- build time:Sat Nov 13 2021 15:45:21 GMT+0000 (Coordinated Universal Time) --><p>接下来的文章主要开始记录 AirSim 提供的 APIs 的学习。但是在自己新建一个工程的时候发现，配置有很多问题，这里先解决一下。</p><a id="more"></a><p>在第一篇文章【AirSim 仿真 (1) - Windows 10 下安装仿真平台 AirSim - v1.3.1】，跑了一下示例工程 <code>Hello Car</code> . 因为工程配置的关系，发现吧这个工程拷贝出来后，在打开编译不了。但是自己码工程的时候，目录不一定非得限制到 AirSim 的工程目录下吧，总归自己有个文件夹的。</p><p>其实看一下 <code>Hello Car</code> 的工程属性配置可以看到其实编译不了的原因，无非是包含目录、依赖库的关系。因此，这里主要解决一下这些配置问题。</p><hr><p>[TOC]</p><hr><h2 id="新建工程"><a class="header-anchor" href="#新建工程">¶</a>新建工程</h2><ol><li><p>创建一个控制台应用，指定一个自己的归档路径。过程不叙述了。这里，我新建了一个<code>car-controller</code> 文件夹（和 <code>AirSim</code> 项目不在一起）。工程就叫做 <code>CarController</code>.</p><p><img data-src="image-20200607165137306.png" alt="image-20200607165137306"></p></li><li><p>把示例程序 <code>HelloCar</code> 的源码拷贝过来，不用想，这里肯定都是满屏的错误。</p></li><li><p>整个过程其实和配置 <code>OpenCV</code>的过程差不多，开始配置项目工程属性，进入 <code>项目</code> -&gt; <code>属性</code>。</p></li></ol><h2 id="添加附加包含目录"><a class="header-anchor" href="#添加附加包含目录">¶</a>添加附加包含目录</h2><ol><li><p><code>配置属性</code> -&gt; <code>C/C++</code> -&gt; <code>常规</code> -&gt; <code>附加包含目录</code></p></li><li><p>添加如下三个包含目录，在 <code>AirSim</code> 工程内。我这里是 <code>D:\dev\airsim_ws\airsim</code></p><blockquote><p><code>$(airsim项目目录)\AirLib\deps\rpclib\include</code></p><p><code>$(airsim项目目录)\AirLib\deps\eigen3</code></p><p><code>$(airsim项目目录)\AirLib\include</code></p></blockquote><p><img data-src="image-20200607170319035.png" alt="image-20200607170319035"></p></li></ol><h2 id="添加附加库目录"><a class="header-anchor" href="#添加附加库目录">¶</a>添加附加库目录</h2><ol><li><p><code>配置属性</code> -&gt; <code>链接器</code> -&gt; <code>常规</code> -&gt; <code>附加库目录</code></p></li><li><p>添加如下三个包含库目录，在 <code>AirSim</code> 工程内。</p><blockquote><p><code>$(airsim项目目录)\AirLib\lib\$(Platform)\$(Configuration)</code></p><p><code>$(airsim项目目录)\AirLib\deps\rpclib\lib\$(Platform)\$(Configuration)</code></p><p><code>$(airsim项目目录)\AirLib\deps\MavLinkCom\lib\$(Platform)\$(Configuration)</code></p></blockquote></li><li><p><strong>PS</strong>: 因为 <code>Windows</code> 下的库区分 <code>Debug</code> 和 <code>Release</code>模式，还有 <code>x86</code> 和 <code>x64</code> 连个平台。</p><blockquote><p><code>$(Platform)</code> : 这个就是区分 <code>Debug</code> 和 <code>Release</code>的</p><p><code>$(Configuration)</code> : 这个区分 <code>x86</code>还是 <code>x64</code>的</p></blockquote></li></ol><p><img data-src="image-20200607171024035.png" alt="image-20200607171024035"></p><h2 id="配置附加依赖项"><a class="header-anchor" href="#配置附加依赖项">¶</a>配置附加依赖项</h2><p>完成上一步，这时候代码应该不会冒红了，但是编译还是过不了的。会包 <code>LNK2019</code> 无法解析的外部符号的错误，因为依赖库找不到。</p><ol><li><p><code>配置属性</code> -&gt; <code>链接器</code> -&gt; <code>输入</code> -&gt; <code>附加依赖项</code></p></li><li><p>添加库，上一步的三个 <code>lib</code> 文件夹下的库都需要添加进去。<strong>PS</strong>: 还有一种方法针对很多库的，比如 <code>OpenCV</code> 是不是在这里要添加很多库，有些时候还会漏掉导致工程编译失败。这里也又一个小技巧，就是用通配符，把指定目录下的所有 lib 都添加进来。</p><blockquote><p><code>$(airsim项目目录)\AirLib\deps\rpclib\lib\$(Platform)\$(Configuration)\*.lib</code> &gt; <code>$(airsim项目目录)\AirLib\deps\MavLinkCom\lib\$(Platform)\$(Configuration)\*.lib</code> &gt; <code>$(airsim项目目录)\AirLib\lib\$(Platform)\$(Configuration)\*.lib</code></p></blockquote></li></ol><p><img data-src="image-20200607175949310.png" alt="image-20200607175949310"></p><h2 id="编译运行"><a class="header-anchor" href="#编译运行">¶</a>编译运行</h2><p>工程配置： <code>Debug</code>, <code>x64</code>。例程再次跑起来了。</p><p><img data-src="image-20200607182009709.png" alt="image-20200607182009709"></p><h2 id="其他"><a class="header-anchor" href="#其他">¶</a>其他</h2><p>其实到这里，如果有编译好的库和插件，其实都不需要下载 UE （除非要自定义场景）或者源码编译。</p><p>这里把我编译好的库文件和插件上传了，可自行下载:</p><blockquote><p>AirLib-v1.3.1-vs2019.zip</p><p>Plugins-AirSim-v1.3.1-ue2.25.1.zip</p></blockquote><p>地图的话，在官方的 <code>github</code> 上可以自己<a href="https://github.com/microsoft/AirSim/releases" target="_blank" rel="noopener">下载</a>: <a href="https://github.com/microsoft/AirSim/releases" target="_blank" rel="noopener">https://github.com/microsoft/AirSim/releases</a>，里面是打包好的应用程序，双击就可以运行，可以下载一个小地图试试。</p><p><strong>PS</strong>：如果是汽车的话就不要下载 <code>ZhangJiaJie</code>那幅图了，给无人机用的，车开不了。</p><p><img data-src="image-20200607183454753.png" alt="image-20200607183454753"></p><h2 id="最后"><a class="header-anchor" href="#最后">¶</a>最后</h2><p>接下去就要开始正真的开发使用了……</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>自动驾驶</category>
      </categories>
      <tags>
        <tag>自动驾驶</tag>
        <tag>AirSim</tag>
      </tags>
  </entry>
  <entry>
    <title>自动驾驶仿真 - AirSim (1) - Windows 10 下安装仿真平台 AirSim - v1.3.1</title>
    <url>/posts/4243726933/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><!-- build time:Sat Nov 13 2021 15:45:21 GMT+0000 (Coordinated Universal Time) --><p>最近在学习自动驾驶相关的知识，看很多公司都是基于百度 <code>Apollo</code> 平台的，不过因为基于 Linux。手头电脑上只有虚拟机，显卡什么不能用，跑起来有点费劲。然后找到了微软开放的一个仿真平台 <code>AirSim</code>。因为微软加持，所以在 <code>Windows</code>平台就很方便，另外也有 <code>Linux</code>版本。（等买一个新硬盘再装个 <code>Linux</code>系统再用下 <code>Apollo</code> 和 <code>AirSim</code> ）。本文主要记录了 <code>Windows 10</code> 下安装 <code>AirSim - v1.3.1</code>的步骤。</p><a id="more"></a><hr><p>[TOC]</p><hr><h2 id="AirSim-简介"><a class="header-anchor" href="#AirSim-简介">¶</a>AirSim 简介</h2><p><code>AirSim</code> 是一个建立在虚幻引擎之上用于仿真飞行器和汽车驾驶的仿真器（也有 <code>Unity</code> 的试验版本）。它是开源的、跨平台的，并支持飞行控制器(如 PX4) <code>hardware-in-loop</code> ，用于物理和视觉上的真实模拟。它被开发为一个 <code>Unreal</code> 的插件，可以简单地扔到任何 <code>Unreal</code> 的环境。目标是 <code>AirSim</code> 开发成一个人工智能研究的平台，以实验深度学习、计算机视觉和增强自主学习算法。</p><h2 id="安装环境"><a class="header-anchor" href="#安装环境">¶</a>安装环境</h2><ul><li>Windows 10</li><li>AirSim - v1.3.1</li><li>Visual Studio 2019</li><li>Unreal Engine 4.25.1</li></ul><h2 id="安装步骤"><a class="header-anchor" href="#安装步骤">¶</a>安装步骤</h2><p>提前备注下：安装之前保证磁盘可用空间足够大，因为安装 VS 以及 UE 都挺占用磁盘空间的。至少预留 50G + 吧，保险点，免得后面出现磁盘不足的尴尬。</p><h3 id="安装-Visual-Studio-2019"><a class="header-anchor" href="#安装-Visual-Studio-2019">¶</a>安装 Visual Studio 2019</h3><p>巨硬官网<a href="https://visualstudio.microsoft.com/zh-hans/vs/" target="_blank" rel="noopener">下载</a> <code>vs_community</code>安装包，执行在线安装，比较耗时。没办法，vs 2017 之后没有提供离线安装包了。必须安装的组件 <code>使用C++的桌面开发</code> 和 <code>Windows 10 SDK</code> 。我这里直接安装了 <code>使用C++的桌面开发</code> ，和 <code>使用C++的游戏开发</code> ，基本上和 C++ 相关的开发组件都有了。其他的就根据自己的需求来。我这里就安装的这几个工作负载，具体的组件都是默认选项。</p><p><img data-src="image-20200606121633117.png" alt="image-20200606121633117"></p><h3 id="安装-Unreal-Engine"><a class="header-anchor" href="#安装-Unreal-Engine">¶</a>安装 Unreal Engine</h3><ul><li><p><a href="https://www.unrealengine.com/zh-CN/get-now" target="_blank" rel="noopener">下载</a> 安装 Epic Games Launcher。( <strong>PS</strong>：这段时间 Epic 正在免费送游戏呢，白嫖了 GTA 5 ，文明 6， 无主之地等，哈哈哈)。</p></li><li><p>安装登陆器的时候可能会注册账号之类的。</p></li><li><p>登陆器完成，接下去就安装引擎了。</p></li><li><p>首先登录。未安装 UE 的时候，在右上角是灰色的按钮。进入到 <strong><code>库</code></strong> ，选择安装的 UE 版本。这里我就选择最新的引擎版本安装了 <strong><code>4.25.1</code></strong>。</p><p><img data-src="image-20200606123115428.png" alt="image-20200606123115428"></p></li><li><p>引擎下载比较大，大概 11 G 左右（<strong>PS</strong>：相比于游戏动辄五六十 G 来说，还是比较矜持的.如果下载比较慢，可以试下挂加速器下载。没错，就是打游戏用的那个加速器。我这里用的是挂的是鹅厂的加速器（非广告）。选择 Epic 游戏加速下载，反正是被拉满速了，不过其实我也不知道有没有用，因为我没试过不挂加速器是咋样的速度）</p><p><img data-src="image-20200606123716438.png" alt="image-20200606123716438"></p></li></ul><p><strong>PS</strong>：手册上建议<code>AirSim v1.3.1</code> 建议安装的 UE 版本 <strong>4.24</strong>，虽然 &gt;=4.22 也可以正常工作。所以我这里建议就直接安装最新的吧。</p><ul><li><p>文明打几个回合的功夫，应该就下载好了。这时候，登陆器左上角的就会出现可点击的 <code>启动 Unreal Engine 4.25.1</code>。</p></li><li><p>引擎安装先到这。</p></li></ul><h3 id="构建-AirSim"><a class="header-anchor" href="#构建-AirSim">¶</a>构建 AirSim</h3><ul><li><p>先 <code>Clone</code> 仓库吧：<a href="https://github.com/Microsoft/AirSim" target="_blank" rel="noopener">官方仓库地址</a>： <a href="https://github.com/Microsoft/AirSim%E3%80%82" target="_blank" rel="noopener">https://github.com/Microsoft/AirSim。</a></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/Microsoft/AirSim.git</span><br></pre></td></tr></table></figure></li><li><p>咳咳，国内网络从 <code>github</code>拉代码都比较……慢……我这百兆电信也就……几十 kb……所以这里就用 <a href="https://gitee.com/troxyz/airsim" target="_blank" rel="noopener">码云</a> 同步了一下：<a href="https://gitee.com/troxyz/airsim" target="_blank" rel="noopener">https://gitee.com/troxyz/airsim</a> （同步日期：2020.6.6）。</p></li><li><p>接下去就 <code>git clone</code> 吧，基本能拉满速。我这里拉了 v1.3.1 的最新的代码，历史代码我也暂时用不到。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -b v1.3.1-windows  https://gitee.com/troxyz/airsim.git --depth 1</span><br></pre></td></tr></table></figure></li><li><p>然后就正式构建 <code>AirSim</code> 。</p><ul><li><p>从 <code>开始</code> 菜单启动 <code>Developer Command Prompt for VS 2019</code> 或者 <code>Developer Powershell for VS 2019</code>. 一下子找不到就在开始菜单搜索下。</p><p><img data-src="image-20200606130910725.png" alt="image-20200606130910725"></p></li><li><p><code>cd</code> 切换到 <code>airsim</code> 的源码目录下.</p></li><li><p>运行 <code>build.cmd</code> 脚本</p><ul><li><strong>PS:</strong> 这里会下载一个库 <a href="https://github.com/rpclib/rpclib/archive/v2.2.1.zip" target="_blank" rel="noopener"><code>rpclib-2.2.1.zip</code></a> 和一个 <a href="https://github.com/Microsoft/AirSim/releases/download/v1.2.0/car_assets.zip" target="_blank" rel="noopener"><code>car_assert.zip</code></a>（就是一辆默认配置好的小车），打开这个脚本搜索一下能看到这两个文件都是放在 <code>github</code>上的，所以下载慢就不奇怪了。我这里就离线下载放到仓库里去了。</li><li>重命名一下 <code>rpclib.zip</code> 扔到 <code>external\rpclib.zip</code> 下</li><li>解压 <code>car_assert.zip</code> 的 <code>SUV</code> 文件夹到 <code>Unreal\Plugins\AirSim\Content\VehicleAdv\</code></li></ul></li><li><p>如果没有错误，那这里就算构建完成了</p></li></ul></li></ul><h3 id="如何使用-AirSim"><a class="header-anchor" href="#如何使用-AirSim">¶</a>如何使用 AirSim</h3><p>在 <code>Unreal/Environments/Blocks</code> 文件夹里面有个轻量级的环境。</p><ul><li><p>切换到 <code>AirSim\Unreal\Environments\Blocks</code> 运行 <code>update_from_git.bat</code> 脚本。</p></li><li><p>打开生成的 <code>.sln</code> 工程文件，项目配置为 <code>DebugGame_Editor</code> ，<code>Win64</code>.</p><p><img data-src="image-20200606140541011.png" alt="image-20200606140541011"></p></li><li><p>运行，这时候会启动 UE，点击运行按钮，可以看到小车出现，方向键即可控制小车运动。</p><p><img data-src="image-20200606140845322.png" alt="image-20200606140845322"></p></li><li><p>按 <code>F1</code> 可看到帮助提示，可以看到深度图、分割图、相机窗口</p><p><img data-src="image-20200606141232221.png" alt="image-20200606141232221"></p></li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>自动驾驶</category>
      </categories>
      <tags>
        <tag>自动驾驶</tag>
        <tag>AirSim</tag>
      </tags>
  </entry>
  <entry>
    <title>自动驾驶仿真 - AirSim (2) - 创建并设置 Unreal Engine 环境</title>
    <url>/posts/2194771931/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><!-- build time:Sat Nov 13 2021 15:45:21 GMT+0000 (Coordinated Universal Time) --><p>对自定义 UE 环境导入 AirSim 插件小车。本文主要参考官方文档 <a href="https://microsoft.github.io/AirSim/unreal_custenv/" target="_blank" rel="noopener">Creating and Setting Up Unreal Environment</a>。</p><a id="more"></a><hr><p>[TOC]</p><hr><h2 id="地图准备"><a class="header-anchor" href="#地图准备">¶</a>地图准备</h2><p>因为原文使用的一个免费环境在 UE 商城没有找到。不过官方在 <code>github</code> 上提供了几个<a href="https://github.com/Microsoft/AirSim/releases" target="_blank" rel="noopener">地图</a>可用，不过下载速度太慢了。所以，本文直接从 UE 的 <strong>学习</strong> tab 下载了一个免费的赛车游戏项目，大概一个 G 左右。官方提供的几个地图等下载好之后再试试。</p><p><img data-src="image-20200607112530427.png" alt="image-20200607112530427"></p><h2 id="创建-UE-工程"><a class="header-anchor" href="#创建-UE-工程">¶</a>创建 UE 工程</h2><ol><li><p>点击 <code>创建工程</code> 按钮，输入名称和保存的文件夹，<code>创建</code> 工程。这里 <strong>不要出现中文路径</strong>， 貌似后面编译老出问题，换成英文之后就过了。</p><p><img data-src="image-20200607113118716.png" alt="image-20200607113118716"></p></li><li><p>打开项目所在文件夹，打开 ue 项目，这里是 <code>cargame.uproject</code>. 首次打开估计要编译一会儿，这个看电脑配置，我大概花了 10 分钟 (i7 8700 + GTX 1070Ti + 固态)。</p><p><strong>PS</strong>：如果使用官方示例中的那个地图，因为没有源码文件，所以触发不了编译。所以官方的那份文档有一步骤是建立一个新的 C++ 的空类。这里不需要，也不能，否则该项目模块编译不了。</p><p><img data-src="image-20200607113756907.png" alt="image-20200607113756907"></p></li><li><p>效果如下图所示，这个是个完整的游戏，如果点击 <code>运行</code> 会出来一辆小车，是可以玩的。不过这辆车不是我们要的那辆。</p><p><img data-src="image-20200607115242368.png" alt="image-20200607115242368"></p></li></ol><h2 id="生成-Visual-Studio-项目"><a class="header-anchor" href="#生成-Visual-Studio-项目">¶</a>生成 Visual Studio 项目</h2><ol><li><p>在 <code>UnReal Editor</code> 中点击 <code>文件</code>，<code>生成Visual Studio项目</code>。之后，会在项目文件夹下看到一个 vs 项目文件 <code>cargame.sln</code>，这里暂时不要打开。先关闭编辑器。</p><p><img data-src="image-20200607115730099.png" alt="image-20200607115730099"></p></li><li><p>把 <code>AirSim</code> 项目下的 <code>AirSim</code> 插件拷贝（路径 <code>Unreal/Plugins</code>）到 <code>cargame</code> 项目根目录下，如图。</p><p>![image-20200607121222918](AirSim 仿真 (2) - 创建并设置 Unreal Engine 环境.assets/image-20200607121222918.png)</p></li><li><p>右键编辑 <code>cargame.uproject</code>, 找到 <code>&quot;Plugins&quot;</code> 字段，把 <code>AirSim</code> 插件添加进去. 保存。</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">"Plugins": [</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="attr">"Name"</span>: <span class="string">"PhysXVehicles"</span>,</span><br><span class="line">      <span class="attr">"Enabled"</span>: <span class="literal">true</span></span><br><span class="line">   &#125;,</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="attr">"Name"</span>: <span class="string">"RawInput"</span>,</span><br><span class="line">      <span class="attr">"Enabled"</span>: <span class="literal">true</span></span><br><span class="line">   &#125;,</span><br><span class="line">   &#123;</span><br><span class="line">         <span class="attr">"Name"</span>: <span class="string">"AirSim"</span>,</span><br><span class="line">         <span class="attr">"Enabled"</span>: <span class="literal">true</span></span><br><span class="line">     &#125;</span><br><span class="line">],</span><br></pre></td></tr></table></figure></li><li><p>右键 <code>cargame.uproject</code>，选择 <code>Generate Visual Studio project fiels</code>. 这时候，目录下会出现 vs 的工程文件 <code>cargame.sln</code>.</p><p><img data-src="image-20200607121001231.png" alt="image-20200607121001231"></p></li><li><p>打开 vs 工程文件 <code>cargame.sln</code>，工程配置为 <code>DSebugGame Editor</code>, <code>Win64</code>。</p><p><img data-src="image-20200607121426792.png" alt="image-20200607121426792"></p></li><li><p>编译运行工程，成功后，会自动打开 ue 编辑器的，和运行 <code>Blocks</code> 示例工程一样。</p></li></ol><h2 id="加载-AirSim-插件"><a class="header-anchor" href="#加载-AirSim-插件">¶</a>加载 <code>AirSim</code> 插件</h2><ol><li><p>打开 <code>世界场景设置</code> 窗口。如果没有的话，点击 <code>窗口</code>，勾选 <code>世界场景设置</code> ，即可。效果如下图。</p><p><strong>PS</strong>: 这里我找了好久，官方文档说默认有的，我这里没有，一直怀疑我安装有啥问题。</p><p><img data-src="image-20200607122150090.png" alt="image-20200607122150090"></p></li><li><p>在 <code>世界场景设置</code> 中的 <code>游戏模式</code> 的 <code>游戏模式重载</code> 下拉框选择 <code>AirSimGameMode</code>. 至此所有配置均完成。</p><p><img data-src="image-20200607122408176.png" alt="image-20200607122408176"></p></li></ol><h2 id="运行仿真"><a class="header-anchor" href="#运行仿真">¶</a>运行仿真</h2><p>在编辑器中点击 <code>运行</code> ，然后就出现了我们熟悉的车了，把几个视图窗口调出来。</p><p><img data-src="image-20200607122806805.png" alt="image-20200607122806805"></p><h2 id="其他"><a class="header-anchor" href="#其他">¶</a>其他</h2><ol><li><p>在编辑器的 <code>细节</code> 窗口可以看到选中的 对象的一些信息。比如这里我选中了小车，小车运动时，一些数据能实时变化。</p><p><img data-src="image-20200607123344712.png" alt="image-20200607123344712"></p></li><li><p>如果鼠标切换不出来， 按快捷键 <code>shift + F1</code>.</p></li><li><p>鼠标切出时，可能仿真视图界面会出现卡顿的现象。点击 <code>编辑</code> -&gt; <code>编辑器偏好设置……</code>。搜索一下 <code>cpu</code>，把 <code>编辑器性能</code> 下的 <code>处于背景中时占用较少CPU</code> 的勾勾去掉即可。</p><p><img data-src="image-20200607123712008.png" alt="image-20200607123712008"></p><p><img data-src="image-20200607123910639.png" alt="image-20200607123910639"></p></li></ol><h2 id="最后"><a class="header-anchor" href="#最后">¶</a>最后</h2><p>愉快地继续折腾吧。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>自动驾驶</category>
      </categories>
      <tags>
        <tag>自动驾驶</tag>
        <tag>AirSim</tag>
      </tags>
  </entry>
  <entry>
    <title>路径规划-RRT_Star</title>
    <url>/posts/3092301982/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><!-- build time:Sat Nov 13 2021 15:45:21 GMT+0000 (Coordinated Universal Time) --><h1>路径规划之 RRT_Star</h1><p>RRT_Connect 相对于 RRT 虽然增加了启发式策略和贪婪思想，但他们的路径都不是最优的。搜索路径都是基于随机采样，缺少评价函数。RRT_Star 算法在 RRT 的基础上，基于代价函数来重新选择新父节点，重新布线新子节点，保证算法渐进最优解。</p><a id="more"></a><p><img data-src="rrt_star.gif" alt="rrt_star.gif"></p><h2 id="算法描述"><a class="header-anchor" href="#算法描述">¶</a>算法描述</h2><p>RRT* 构造方式和 RRT 类似，区别在于重新选择父节点和重新布线这个过程。在寻找到新节点 $q_{new}$ 时，先进行碰撞检测，若 ($q_{near}$， $q_{new}$) 没有碰撞，并不立即将新节点和新边加入到树中。而是首先<strong>重新选择父节点</strong>：寻找以 $q_{new}$ 为圆心，以半径$r$内的所有邻接节点，作为$q_{new}$ 的潜在父节点 $q_{proential_parents}$ 。然后遍历所有潜在父节点，若 $q_{protential_parents}$ 到 $q_{new}$ 无碰撞，则计算从起点 $q_{start}$ 到潜在父节点$q_{protential_parents}$，再到新节点$q_{new}$的总路径长。选择最短路径的潜在父节点(假设记为$q_{min_parent}$)作为$q_{new}$的父节点，添加边 ($q_{min_parent}, q_{new}$) 到树中。 在完成父节点的重新选择后，再对该邻域<strong>重新布线</strong>：再次遍历该邻接节点集合中除 $q_{min_parent}$ 之外的剩余节点，作为 $q_{new}$ 的潜在子节点 $q_{proential_children}$，若 $q_{new}$ 到 $q_{protential_children}$ 无碰撞，则计算从起点 $q_{start}$ 到新节点 $q_{new}$ ，再到潜在子节点 $q_{protential_children}$ 的总路径长。选择最短路径的潜在子节点 (假设记为 $q_{min_child}$ )，将该节点的父节点设置为 $q_{new}$ 的新节点，删除边 ($q_{parent_of_min_child}$, $q_{min_child}$) 添加边 ($q_{new}$, $q_{min_parent}$) 到树中。因为我们通过链表来构建树，所以设置父节点也相当于添加边；更改父节点，相当于删除了原来的边并添加新边。通过上述两次选择，使得 RRT* 达到渐进最优，并且构造树的节点和边大大减少，提高的搜索效率。</p><h3 id="伪码"><a class="header-anchor" href="#伪码">¶</a>伪码</h3><p><img data-src="algorithm_rrt_star.png" alt="Algorithms RRT_Connect"></p><h2 id="实现"><a class="header-anchor" href="#实现">¶</a>实现</h2><h3 id="数据结构"><a class="header-anchor" href="#数据结构">¶</a>数据结构</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, pos=[<span class="number">0</span>, <span class="number">0</span>])</span>:</span></span><br><span class="line">        self.pos = pos</span><br><span class="line">        self.parent = <span class="literal">None</span></span><br></pre></td></tr></table></figure><h3 id="接口"><a class="header-anchor" href="#接口">¶</a>接口</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">map_path: 地图图片路径</span></span><br><span class="line"><span class="string">qstart: 起点坐标 [row, col]</span></span><br><span class="line"><span class="string">qgoal: 目标点坐标 [row, col]</span></span><br><span class="line"><span class="string">grid_size: 网格大小（用来碰撞检测）</span></span><br><span class="line"><span class="string">step_size: 扩展步长</span></span><br><span class="line"><span class="string">neighbor_radius: 邻域半径，有公式计算的，这里为简单起见，选择定制</span></span><br><span class="line"><span class="string">max_steps: 最大扩展节点数</span></span><br><span class="line"><span class="string">goal_prob: 增加趋向目标点概率（贪婪）</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">rrt_star = RRT_STAR(map_path, qstart, qgoal, grid_size,</span><br><span class="line">                    step_size, parent_radius, max_steps, goal_prob)</span><br></pre></td></tr></table></figure><h3 id="Planning"><a class="header-anchor" href="#Planning">¶</a>Planning</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Planning</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    RRT_STAR planning</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 初始化树，添加起点</span></span><br><span class="line">    vertices = []</span><br><span class="line">    self.AddVertices(self.qstart, vertices)</span><br><span class="line">    self.AddEdges(<span class="literal">None</span>, self.qstart)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 开始扩展</span></span><br><span class="line">    k = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> k &lt;= self.max_steps:</span><br><span class="line">        k += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 随机采样节点qrand，</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 扩展新节点qnew</span></span><br><span class="line">        qrand = self.GenerateRandomNode(</span><br><span class="line">            [<span class="number">0</span>, self.map_shape[<span class="number">0</span>]], [<span class="number">0</span>, self.map_shape[<span class="number">1</span>]],</span><br><span class="line">            self.qgoal, self.goal_prob)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 遍历树节点 vertices，选择距离最近的节点 qnear</span></span><br><span class="line">        _, qnear = self.FindNearestNode(qrand, vertices)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 扩展新节点 qnew</span></span><br><span class="line">        qnew = self.ExtendTree(qnear, qrand, self.step_size)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 判断 qnew 扩展成功，且(qnear, qnew)无碰撞</span></span><br><span class="line">        <span class="keyword">if</span> qnew <span class="keyword">and</span> self.CollsionFree(qnear, qnew, self.grid_size):</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 寻找以qnew为圆心，parent_radius为半径的圆内邻接节点neighbors_free</span></span><br><span class="line">            neighbors_free = self.FindNeighbors(</span><br><span class="line">                qnew, vertices, self.parent_radius)</span><br><span class="line"></span><br><span class="line">            <span class="string">'''</span></span><br><span class="line"><span class="string">            neighbors = list(filter(lambda qnode: self.Distance(</span></span><br><span class="line"><span class="string">                qnode.pos, qnew.pos) &lt; self.parent_radius, vertices))</span></span><br><span class="line"><span class="string">            neighbors_free = []</span></span><br><span class="line"><span class="string">            for parent in neighbors:</span></span><br><span class="line"><span class="string">                if self.CollsionFree(parent, qnew, self.grid_size):</span></span><br><span class="line"><span class="string">                    neighbors_free.append(parent)</span></span><br><span class="line"><span class="string">            '''</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 重新选择父节点：</span></span><br><span class="line">            <span class="comment"># 计算路径代价Cost(qstart, neighbors_free, qnew),</span></span><br><span class="line">            <span class="comment"># 选择最短路径的潜在父节点作为qnew的新父节点qnew_parent，并将新边加入到树中</span></span><br><span class="line">            len_qnew_path, qnew_parent = self.RewireNewParent(</span><br><span class="line">                qnew, vertices, neighbors_free)</span><br><span class="line"></span><br><span class="line">            <span class="string">'''</span></span><br><span class="line"><span class="string">            len_qnew_path = float('inf')</span></span><br><span class="line"><span class="string">            qnew_parent = None</span></span><br><span class="line"><span class="string">            for parent in neighbors_free:</span></span><br><span class="line"><span class="string">                parent_path = self.FindPathByParentPointer(parent)</span></span><br><span class="line"><span class="string">                len_parent_path = self.CalculatePathLength(parent_path)</span></span><br><span class="line"><span class="string">                tmp_len_path = len_parent_path + \</span></span><br><span class="line"><span class="string">                    self.Distance(qnew.pos, parent.pos)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                if tmp_len_path &lt; len_qnew_path:</span></span><br><span class="line"><span class="string">                    len_qnew_path = tmp_len_path</span></span><br><span class="line"><span class="string">                    qnew_parent = parent</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            self.AddVertices(qnew, vertices)</span></span><br><span class="line"><span class="string">            self.AddEdges(qnew_parent, qnew)</span></span><br><span class="line"><span class="string">            self.DrawEdges(self.src_map, qnew_parent, qnew)</span></span><br><span class="line"><span class="string">            '''</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 重新布线：</span></span><br><span class="line">            <span class="comment"># 计算neighbors_free中除qnew_parent外的路径代价Cost(qstart, qnew, neighbors_free),</span></span><br><span class="line">            <span class="comment"># 选择最短路径的节点qnew_children，设置其父节点为qnew，并将新边加入到树中</span></span><br><span class="line">            <span class="keyword">if</span> qnew_parent:</span><br><span class="line">                neighbors_free.remove(qnew_parent)</span><br><span class="line">            self.RewireNewChild(qnew, len_qnew_path, neighbors_free)</span><br><span class="line">            <span class="string">'''</span></span><br><span class="line"><span class="string">            qnew_children = None</span></span><br><span class="line"><span class="string">            for child in neighbors_free:</span></span><br><span class="line"><span class="string">                tmp_len_path = len_qnew_path + \</span></span><br><span class="line"><span class="string">                    self.Distance(qnew.pos, child.pos)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                if self.CollsionFree(child, qnew, self.grid_size):</span></span><br><span class="line"><span class="string">                    child_path = self.FindPathByParentPointer(child)</span></span><br><span class="line"><span class="string">                    if tmp_len_path &lt; self.CalculatePathLength(child_path):</span></span><br><span class="line"><span class="string">                        qnew_children = child</span></span><br><span class="line"><span class="string">                        self.AddEdges(qnew, qnew_children)</span></span><br><span class="line"><span class="string">                        self.DrawEdges(self.src_map, qnew,</span></span><br><span class="line"><span class="string">                                       qnew_children)</span></span><br><span class="line"><span class="string">            '''</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 检查两棵树是否相连,若相连，则完成路径规划</span></span><br><span class="line">            <span class="keyword">if</span> self.IsArrival(qnew, self.qgoal, self.step_size):</span><br><span class="line">                print(<span class="string">"Found"</span>)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 如果两棵树连上了，说明找到路径了，把最后一个节点添加到树中。</span></span><br><span class="line">                self.AddVertices(self.qgoal, vertices)</span><br><span class="line">                self.AddEdges(qnew, self.qgoal)</span><br><span class="line">                self.DrawEdges(self.src_map, qnew, self.qgoal)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 构建路径</span></span><br><span class="line">                path = self.FindPath(vertices)</span><br><span class="line">                self.DrawPath(self.src_map, path)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 圆滑路径</span></span><br><span class="line">                smooth_path = self.SmoothPath(path, self.grid_size)</span><br><span class="line">                self.DrawPath(self.src_map, smooth_path)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">"NotFound"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h2 id="参考资料"><a class="header-anchor" href="#参考资料">¶</a>参考资料</h2><p>[1]: Karaman S, Frazzoli E. Sampling-based algorithms for optimal motion planning[J]. The international journal of robotics research, 2011, 30(7): 846-894.<br>[2]: Choset. Principles of Robot Motion: Theory, Algorithms, and Implementations[J]. Proceedings of the Society for Experimental Biology &amp; Medicine Society for Experimental Biology &amp; Medicine, 2005, 147(1):512-512.<br>[3]: <a href="https://blog.csdn.net/weixin_43795921/article/details/88557317" target="_blank" rel="noopener">https://blog.csdn.net/weixin_43795921/article/details/88557317</a><br>[4]: <a href="https://www.cnblogs.com/guojun-junguo/p/10198144.html" target="_blank" rel="noopener">https://www.cnblogs.com/guojun-junguo/p/10198144.html</a></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>路径规划</category>
      </categories>
      <tags>
        <tag>路径规划</tag>
        <tag>motion planning</tag>
        <tag>RRT*</tag>
      </tags>
  </entry>
  <entry>
    <title>路径规划-RRT_Connect</title>
    <url>/posts/2708526344/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><!-- build time:Sat Nov 13 2021 15:45:21 GMT+0000 (Coordinated Universal Time) --><h1>路径规划之 RRT_Connect (平衡双向快速扩展随机树)</h1><p>单颗 RRT 树每次搜索只从初始节点开始在状态空间中快速随机扩展节点，带有一定的盲目性。RRT_Connect 算法是一种基于双向扩展平衡的连结型双树(Balanced Bidirectional RRT)：两颗 RRTs 分别基于 $q_{init}$ 和 $q_{goal}$ 扩展；贪心启发式的连接方法使每棵树扩展时一次移动更长的距离。<a href="https://ieeexplore.ieee.org/document/844730" target="_blank" rel="noopener">作者</a>原文中举例了平面地图以及 6-DOF 的机械臂来验证 RRT_Connect.</p><a id="more"></a><p><img data-src="rrt_connect.gif" alt="rrt_connect.gif"></p><h2 id="算法描述"><a class="header-anchor" href="#算法描述">¶</a>算法描述</h2><p>分别在起点 $q_{init}$ 和终点 $q_{goal}$ 构造两棵树 $T_1$ 和 $T_2$，扩展节点方式同 RRT。首先 $T_1$ 从 $q_{init}$ 随机采样 $q_{rand}$ 作为目标点扩展一个新节点 $𝑞_{𝑛𝑒𝑤}$ ，以这个新节点 $𝑞_{𝑛𝑒𝑤}$ 作为第二棵树 $T_2$ 的目标点来扩展新节点 $𝑞_{𝑛𝑒𝑤}^′$。如果 $𝑞_{𝑛𝑒𝑤}^′$ 没有碰撞，继续以$𝑞_{𝑛𝑒𝑤}$作为目标点扩展$T_2$，直到扩展失败(遇到障碍，进行下一次循环扩展或者 $𝑞_{𝑛𝑒𝑤}^′=𝑞_{𝑛𝑒𝑤}$ 两棵树相连，即 connect，整个算法结束)。每次扩展需要考虑两棵树的平衡性，节点多少或总路径的长度。交换次序，选择较短的树进行扩展。<br>首先，RRT_Connect 算法以另一棵树的新节点作为目标点扩展，直到扩展失败。每次扩展更加贪婪，步长更长，使得树的生长更快；其次，两棵树不断朝向对方交替扩展，相比于随机扩展的方式具有一定的启发性质，特别当起始位姿和目标位姿处于约束区域时，两棵树可以通过朝向对方快速扩展而逃离各自的约束区域。</p><h3 id="伪码"><a class="header-anchor" href="#伪码">¶</a>伪码</h3><p><img data-src="algorithm_rrt_connect.png" alt="Algorithms RRT_Connect"></p><h2 id="算法实现"><a class="header-anchor" href="#算法实现">¶</a>算法实现</h2><h3 id="数据结构"><a class="header-anchor" href="#数据结构">¶</a>数据结构</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, pos=[<span class="number">0</span>, <span class="number">0</span>])</span>:</span></span><br><span class="line">        self.pos = pos</span><br><span class="line">        self.parent = <span class="literal">None</span></span><br></pre></td></tr></table></figure><h3 id="接口"><a class="header-anchor" href="#接口">¶</a>接口</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">map_path: 地图图片路径</span></span><br><span class="line"><span class="string">qstart: 起点坐标 [row, col]</span></span><br><span class="line"><span class="string">qgoal: 目标点坐标 [row, col]</span></span><br><span class="line"><span class="string">grid_size: 网格大小（用来碰撞检测）</span></span><br><span class="line"><span class="string">step_size: 扩展步长</span></span><br><span class="line"><span class="string">max_steps: 最大扩展节点数</span></span><br><span class="line"><span class="string">goal_prob: 增加趋向目标点概率（贪婪）</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">rrt_connect = RRT_CONNECT(map_path, qstart, qgoal, grid_size,</span><br><span class="line">                          step_size, max_steps, goal_prob)</span><br></pre></td></tr></table></figure><h3 id="Planning"><a class="header-anchor" href="#Planning">¶</a>Planning</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Planning</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    RRT_CONNECT planning</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    # 初始化两颗树：分别在起点qstart和终点qgoal构造两棵树,</span></span><br><span class="line"><span class="string">    # 节点树分别记为vertices_t1和vetices_t2.</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    vertices_t1 = []</span><br><span class="line">    self.AddVertices(self.qstart, vertices_t1)</span><br><span class="line">    self.AddEdges(<span class="literal">None</span>, self.qstart)</span><br><span class="line"></span><br><span class="line">    vertices_t2 = []</span><br><span class="line">    self.AddVertices(self.qgoal, vertices_t2)</span><br><span class="line">    self.AddEdges(<span class="literal">None</span>, self.qgoal)</span><br><span class="line"></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    # 开始迭代</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    k = <span class="number">0</span></span><br><span class="line">    new_qgoal = self.qgoal</span><br><span class="line">    <span class="keyword">while</span> k &lt;= self.max_steps:</span><br><span class="line">        k += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        # 随机采样qrand_t1作为目标点，沿(qnear_t1, qrand_t1)方向,</span></span><br><span class="line"><span class="string">        # 以step_size步长扩展第一棵树的节点qnew_t1.</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        qrand_t1 = self.GenerateRandomNode(</span><br><span class="line">            [<span class="number">0</span>, self.map_shape[<span class="number">0</span>]], [<span class="number">0</span>, self.map_shape[<span class="number">1</span>]],</span><br><span class="line">            new_qgoal, self.goal_prob)</span><br><span class="line"></span><br><span class="line">        _, qnear_t1 = self.FindNearestNode(qrand_t1, vertices_t1)</span><br><span class="line">        qnew_t1 = self.ExtendTree(qnear_t1, qrand_t1, self.step_size)</span><br><span class="line"></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        # 检查qnew_t1是否扩展成功且没有碰撞</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="keyword">if</span> qnew_t1 <span class="keyword">and</span> self.CollsionFree(qnear_t1, qnew_t1, self.grid_size):</span><br><span class="line">            <span class="string">'''</span></span><br><span class="line"><span class="string">            将qnew_t1加入到第一颗树vertices_t1中</span></span><br><span class="line"><span class="string">            '''</span></span><br><span class="line">            self.AddVertices(qnew_t1, vertices_t1)</span><br><span class="line">            self.AddEdges(qnear_t1, qnew_t1)</span><br><span class="line"></span><br><span class="line">            self.DrawEdges(self.src_map, qnear_t1, qnew_t1)</span><br><span class="line"></span><br><span class="line">            <span class="string">'''</span></span><br><span class="line"><span class="string">            # 以qnew_t1为目标点，沿(qnear_t2, qnew_t1)方向</span></span><br><span class="line"><span class="string">            # 以step_size步长扩展第二棵树的节点qnew_t2.</span></span><br><span class="line"><span class="string">            '''</span></span><br><span class="line">            k += <span class="number">1</span></span><br><span class="line">            _, qnear_t2 = self.FindNearestNode(qnew_t1, vertices_t2)</span><br><span class="line">            qnew_t2 = self.ExtendTree(qnear_t2, qnew_t1, self.step_size)</span><br><span class="line"></span><br><span class="line">            <span class="string">'''</span></span><br><span class="line"><span class="string">            # 检查qnew_t1是否扩展成功且没有碰撞</span></span><br><span class="line"><span class="string">            '''</span></span><br><span class="line">            <span class="keyword">if</span> qnew_t2 <span class="keyword">and</span> self.CollsionFree(qnear_t2, qnew_t2, self.grid_size):</span><br><span class="line">                <span class="string">'''</span></span><br><span class="line"><span class="string">                # 将qnew_t1加入到第一颗树vertices_t1中</span></span><br><span class="line"><span class="string">                '''</span></span><br><span class="line">                self.AddVertices(qnew_t2, vertices_t2)</span><br><span class="line">                self.AddEdges(qnear_t2, qnew_t2)</span><br><span class="line"></span><br><span class="line">                self.DrawEdges(self.src_map, qnear_t2, qnew_t2)</span><br><span class="line"></span><br><span class="line">                <span class="string">'''</span></span><br><span class="line"><span class="string">                # 这里一直以qnew_t1为目标点，扩展qnew_t2，</span></span><br><span class="line"><span class="string">                # 除非qnew_t2扩展失败或qnew_t2到达qnew_t1。</span></span><br><span class="line"><span class="string">                # 扩展qnew_t2带有一定的贪婪特性，所以扩展树相比RRT更快速</span></span><br><span class="line"><span class="string">                '''</span></span><br><span class="line">                <span class="keyword">while</span> k &lt;= self.max_steps <span class="keyword">and</span> self.IsArrival(qnew_t2, qnew_t1, self.step_size) == <span class="literal">False</span>:</span><br><span class="line">                    k += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                    <span class="string">'''</span></span><br><span class="line"><span class="string">                    # 以qnew_t1为目标点，沿(qnew_t2, qnew_t1)方向</span></span><br><span class="line"><span class="string">                    # 以step_size步长扩展新节点qnew_mid.</span></span><br><span class="line"><span class="string">                    '''</span></span><br><span class="line">                    qnew_mid = self.ExtendTree(</span><br><span class="line">                        qnew_t2, qnew_t1, self.step_size)</span><br><span class="line"></span><br><span class="line">                    <span class="string">'''</span></span><br><span class="line"><span class="string">                    # 检查qnew_mid是否扩展成功且没有碰撞</span></span><br><span class="line"><span class="string">                    '''</span></span><br><span class="line">                    <span class="keyword">if</span> qnew_mid <span class="keyword">and</span> self.CollsionFree(qnew_t2, qnew_mid, self.grid_size):</span><br><span class="line">                        <span class="string">'''</span></span><br><span class="line"><span class="string">                        # 如果qnew_mid扩展成功，则将其加入到第二棵树中.</span></span><br><span class="line"><span class="string">                        '''</span></span><br><span class="line">                        self.AddVertices(qnew_mid, vertices_t2)</span><br><span class="line">                        self.AddEdges(qnew_t2, qnew_mid)</span><br><span class="line"></span><br><span class="line">                        self.DrawEdges(self.src_map, qnew_t2, qnew_mid)</span><br><span class="line"></span><br><span class="line">                        <span class="string">'''</span></span><br><span class="line"><span class="string">                        # 将第二棵树新扩展的节点qnew_mid作为qnew_t2继续扩展</span></span><br><span class="line"><span class="string">                        '''</span></span><br><span class="line">                        qnew_t2 = qnew_mid</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="string">'''</span></span><br><span class="line"><span class="string">                        # 如果qnew_mid扩展失败，则跳出该循环.</span></span><br><span class="line"><span class="string">                        '''</span></span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">            <span class="string">'''</span></span><br><span class="line"><span class="string">            检查两棵树是否相连,若相连，则完成路径规划</span></span><br><span class="line"><span class="string">            '''</span></span><br><span class="line">            <span class="keyword">if</span> self.IsArrival(qnew_t2, qnew_t1, self.step_size):</span><br><span class="line">                print(<span class="string">"Found"</span>)</span><br><span class="line">                <span class="string">'''</span></span><br><span class="line"><span class="string">                # 如果两棵树连上了，说明找到路径了，把最后一个节点添加到树中。</span></span><br><span class="line"><span class="string">                '''</span></span><br><span class="line">                copy_qnew_t1 = copy.deepcopy(qnew_t1)</span><br><span class="line">                self.AddVertices(copy_qnew_t1, vertices_t2)</span><br><span class="line">                self.AddEdges(qnew_t2, copy_qnew_t1)</span><br><span class="line"></span><br><span class="line">                <span class="string">'''</span></span><br><span class="line"><span class="string">                # 合并两棵树，注意终点树的节点指针与起点树反向</span></span><br><span class="line"><span class="string">                '''</span></span><br><span class="line">                path = self.MergeTree(vertices_t1, vertices_t2)</span><br><span class="line">                self.DrawPath(self.src_map, path)</span><br><span class="line"></span><br><span class="line">                <span class="string">'''</span></span><br><span class="line"><span class="string">                # 路径圆滑</span></span><br><span class="line"><span class="string">                '''</span></span><br><span class="line">                smooth_path = self.SmoothPath(path, self.grid_size)</span><br><span class="line">                self.DrawPath(self.src_map, smooth_path)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        # 当第二棵树扩展失败后，回到第一棵树扩展时，检查两棵树的节点个数，</span></span><br><span class="line"><span class="string">        # 选择较短树进行扩展，使两棵树保持相对平衡。新的目标点为较长树的最后一个节点</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="keyword">if</span> (len(vertices_t2) &lt; len(vertices_t1)):</span><br><span class="line">            vertices_t2, vertices_t1 = vertices_t1, vertices_t2</span><br><span class="line">            <span class="comment"># edges_t2, edges_t1 = edges_t1, edges_t2</span></span><br><span class="line"></span><br><span class="line">            new_qgoal = vertices_t2[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"NotFound"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h2 id="参考资料"><a class="header-anchor" href="#参考资料">¶</a>参考资料</h2><p>[1]: Kuffner J J , Lavalle S M . RRT-connect: An efficient approach to single-query path planning[C]// Proceedings 2000 ICRA. Millennium Conference. IEEE International Conference on Robotics and Automation. Symposia Proceedings (Cat. No.00CH37065). IEEE, 2002.</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>路径规划</category>
      </categories>
      <tags>
        <tag>路径规划</tag>
        <tag>motion planning</tag>
        <tag>RRT_Connect</tag>
      </tags>
  </entry>
  <entry>
    <title>路径规划-LPA_Star</title>
    <url>/posts/367356294/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><!-- build time:Sat Nov 13 2021 15:45:21 GMT+0000 (Coordinated Universal Time) --><h1>路径规划之 LPA_Star (LPA*)</h1><p>LPA*是 A*的增量版本. 相比于 A*算法, 首次规划时, 两者过程类似. 假如地图发生变化, A*算法需要重新规划路径. 而 LPA*算法可以通过在当前搜索期间内更新前一次搜索的 g 值（距起始距离）来适应地图变化而无需重新计算整个地图。</p><a id="more"></a><p><img data-src="lpa_star.gif" alt="lpa_star.gif"></p><h2 id="算法描述"><a class="header-anchor" href="#算法描述">¶</a>算法描述</h2><p>局部连续（Locally Consistent）：$g(s)=rhs(s)$。当所有节点均为局部连续状态时，g(s)的值等于 s 到起始点的最短距离（注意，反向不成立）。这个概念很重要，当上述条件满足时，我们可以找到任意一点 u 到起始点的最短路径，假设当前位置为 s,父辈节点 s’(向着起始点前进的下一个节点)通过最小化(g(s’)+c(s,s’))来获得，不断重复直到到达 sStart。然而，LPA*并不需要使所有节点均为局部连续状态，它通过启发式搜索将关注点放在搜索上，并且只更新那些与计算最短路径相关的节点的 g 值。</p><p>局部过连续（Locally Overconsistent）：$g(s)&gt;rhs(s)$。当优先队列 U 中取出的节点为局部过连续状态时，意味着 g(s)可以通过父辈节点使自己到起点的路径更短，此时将设置 g(s)=rhs(s)，节点状态变为局部连续状态。</p><p>局部欠连续(Locally Underconsistent)：$g(s)&lt;rhs(s)$。这种情况通常出现在父辈的某一节点突然变为障碍的情况下，造成父辈节点到起点的路径变大，从而需要修改 g(s)的值，如果节点处于这种状态，则当它由优先队列中取出时，将其 g 值设置为无穷大，即将该节点状态变为局部过连续，而局部过连续的点将会被再次添加到优先队列中，这样就可以在它下次被取出时将其作为局部过连续状态处理，最终达到局部连续状态（如果这一节点与我们要搜索的最短路径相关的话）。</p><p>LPA*维持着每个节点的到起点的估计距离: <a href="algorithm_lpa_star_g.png">$g(s)$</a> 首次搜索时, $g(s)$ 的计算方式和 A*相同, 并将这个值带到下次搜索过程中.<br><img data-src="algorithm_lpa_star_g.png" alt="algorithm_lpa_star_g"></p><p>此外 LPA*还维护着一个基于 $g(s)$ 的前瞻估计距离: <a href="algorithm_lpa_star_rhs.png">$rhs(s)$</a>.<br><img data-src="algorithm_lpa_star_rhs.png" alt="algorithm_lpa_star_rhs"></p><p>A*算法维护着 OPEN 和 CLOSED 列表来避免节点被重复搜索. LPA*通过检查局部一致性来避免节点重复搜索, 不需要维护 COLSED 列表. OPEN 列表是一个优先队列, 使得 A*可以通过队列中具有最小 $f(s)$ 值的节点来进行边的扩展. LPA*也维持着一个只包含局部欠一致(locally inconsistent)节点的优先队列. 优先队列根据节点的 keys 值排列(相当于 A*的 $f(s)$ 值排列). 该 keys 是一个二维变量:</p><blockquote><p>$k(s)=[k1(s),k2(s)]$</p></blockquote><p>其中:</p><blockquote><p>$k1(s)=min(g(s),rhs(s)+h(s))$, 相当于 A*的$f(s)$ &gt; $k2(s)=min(g(s),rhs(s))$, 相当于 A*的$g(s)$</p></blockquote><p>定义: $k(s1) \leq (s2)$ 为 $k1(s1) \leq k1(s2)$ 或者 $(k1(s1)=k1(s2) \text{ and }k2(s1) \leq k2(s2))$</p><h3 id="伪码"><a class="header-anchor" href="#伪码">¶</a>伪码</h3><p>算法伪码如下图所示 <a href="algorithm_lpa_star.png">Algorithms LAP*</a><br><img data-src="algorithm_lpa_star.png" alt="3"></p><h3 id="图解"><a class="header-anchor" href="#图解">¶</a>图解</h3><p><a href="algorithm_lpa_star_first_search.png">第一次搜索</a><br><img data-src="algorithm_lpa_star_first_search.png" alt="4"></p><p><a href="algorithm_lpa_star_secord_search.png">第二次搜索</a><br><img data-src="algorithm_lpa_star_secord_search.png" alt="5"></p><h2 id="流程"><a class="header-anchor" href="#流程">¶</a>流程</h2><ul><li><p>初始化<code>LPA_STAR.__init__</code>: 初始化地图，对地图图片二值化处理，网格节点划分，若网格内包含障碍物，则该网格节点标记为障碍物: <code>Node.is_obs = True</code></p></li><li><p>输入需要随机产生的障碍物网格个数(可选);</p></li><li><p><code>Initialize()</code>: 初始化所有节点的$g(s)=\infin$, $rhs(s)=\infin$, 实际实现中，不需要初始化所有节点，只需要在遇到一个新节点时初始化该节点. 起点$s_{start}$是一个局部欠一致节点, 计算$keys(s_{start})$, 并将节点$s_{start}$放入优先队列中.</p></li><li><p>初始化<code>Initialize()</code>保证了首次调用<code>ComputeShortestPath()</code>是一个 A*算法。</p></li><li><p>等待地图更新， 这里通过用户输入障碍物网格数来模拟地图更新。</p></li><li><p>地图更新时，导致节点之间的距离<code>DistanceCost</code>发生变化, 调用<code>UpdateVertex(s)</code>更新受影响节点参数<code>rhs</code>和<code>keys</code>。这也这些节点和优先队列之间的联系也发生变化，可能成为局部一致或者局部不一致状态。</p></li><li><p>重新调用<code>ComputeShortestPath()</code>来根据优先队列顺序展开局部不一致的节点。</p><ul><li><p>如果展开的节点处于局部过一致(<code>locally overconsistent</code>)状态, 即$g(s)&gt;rhs(s)$, 那么将该节点设置为局部一致(<code>locally consistent</code>), 即$g(s)=rhs(s)$。</p></li><li><p>如果展开的节点处于局部欠一致(<code>locally underconsistent</code>)状态，即$g(s)&lt;rhs(s)$, 那么将该节点的<code>g</code>值设置为无穷大， 即$g(s)=\infin$</p></li><li><p>上述两种情况中受该展开节点的<code>g</code>值变化会影响后置节点，所以还需要更新受其影响的节点，调用<code>UpdateVertex(s)</code>来更新。</p></li></ul></li><li><p>LPA*扩展停止条件为：目标节点$s_{goal}$处于局部一致并且下一个待展开的节点<code>keys</code>值不小于$s_{goal}$的<code>keys</code>值。若搜索结束之后目标节点$s_{goal}$的<code>g</code>值为无穷大，那路径不存在。</p></li><li><p>将目标节点$s_{goal}$的后置链表反转即可得到$s_{start}$到$s_{goal}$的路径</p></li></ul><h2 id="实现"><a class="header-anchor" href="#实现">¶</a>实现</h2><h3 id="数据结构"><a class="header-anchor" href="#数据结构">¶</a>数据结构</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, pos)</span>:</span></span><br><span class="line">        self.pos = pos          <span class="comment"># 当前节点的位置坐标</span></span><br><span class="line">        self.g = float(<span class="string">'inf'</span>)   <span class="comment"># 当前节点的g(s),g_score</span></span><br><span class="line">        self.h = float(<span class="string">'inf'</span>)   <span class="comment"># 当前节点的的h(s),h_score</span></span><br><span class="line">        self.rhs = float(<span class="string">'inf'</span>) <span class="comment"># rhs(s)</span></span><br><span class="line">        self.keys = [float(<span class="string">'inf'</span>), float(<span class="string">'inf'</span>)]    <span class="comment"># 优先队列keys(s)值</span></span><br><span class="line">        self.p = <span class="literal">None</span>           <span class="comment"># 当前节点的父节点</span></span><br><span class="line">        self.is_obs = <span class="literal">False</span>     <span class="comment"># 当前节点是否是障碍物</span></span><br></pre></td></tr></table></figure><h3 id="接口"><a class="header-anchor" href="#接口">¶</a>接口</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">map_path:   地图图片路径</span></span><br><span class="line"><span class="string">qstart:     起点坐标 [row, col]</span></span><br><span class="line"><span class="string">qgoal:      目标点坐标 [row, col]</span></span><br><span class="line"><span class="string">grid_size:  网格大小（用来碰撞检测）</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">lpa_star = LPA_STAR(map_path, qstart, qgoal, grid_size)</span><br></pre></td></tr></table></figure><h3 id="Planning"><a class="header-anchor" href="#Planning">¶</a>Planning</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">CalculateKey</span><span class="params">(self, s)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    the priority queue ordered by k1(f_score used in A*), then k2</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    key2 = min([s.g, s.rhs])</span><br><span class="line">    <span class="keyword">return</span> [key2 + s.h, key2]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Initialize</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    init</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    self.U = []</span><br><span class="line">    self.qstart.rhs = <span class="number">0</span></span><br><span class="line">    self.qstart.keys = [self.qstart.h, <span class="number">0</span>]</span><br><span class="line">    self.U.append(self.qstart)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">UpdateVertex</span><span class="params">(self, u)</span>:</span></span><br><span class="line">    <span class="comment"># u = copy.deepcopy(u)</span></span><br><span class="line">    <span class="keyword">if</span> u.pos != self.qstart.pos:</span><br><span class="line">        new_rhs = float(<span class="string">'inf'</span>)</span><br><span class="line">        <span class="comment"># predessors = self.Predessors(u)</span></span><br><span class="line">        predessors = self.SuccessorsCollisionFree(u)</span><br><span class="line">        <span class="keyword">for</span> pred <span class="keyword">in</span> predessors:</span><br><span class="line">            tmp_rhs = pred.g + self.DistanceCost(pred, u)</span><br><span class="line">            <span class="keyword">if</span> tmp_rhs &lt; new_rhs:</span><br><span class="line">                new_rhs = tmp_rhs</span><br><span class="line">                u.p = pred</span><br><span class="line">        u.rhs = new_rhs</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> node_index, node <span class="keyword">in</span> enumerate(self.U):</span><br><span class="line">        <span class="keyword">if</span> node.pos == u.pos:</span><br><span class="line">            self.U.pop(node_index)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> u.g != u.rhs:</span><br><span class="line">        u.keys = self.CalculateKey(u)</span><br><span class="line">        self.UInsert(u)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ComputeShortestPath</span><span class="params">(self)</span>:</span></span><br><span class="line"></span><br><span class="line">    color_close = (random.randint(<span class="number">0</span>, <span class="number">255</span>),</span><br><span class="line">                   random.randint(<span class="number">0</span>, <span class="number">255</span>),</span><br><span class="line">                   random.randint(<span class="number">0</span>, <span class="number">255</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (len(self.U) != <span class="number">0</span>) <span class="keyword">and</span> ((self.TopKey() &lt; self.CalculateKey(self.qgoal)) <span class="keyword">or</span> (self.qgoal.rhs != self.qgoal.g)):</span><br><span class="line"></span><br><span class="line">        u = self.U.pop(<span class="number">0</span>)</span><br><span class="line">        self.DrawGrid(u.pos, color_close)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> u.g &gt; u.rhs:</span><br><span class="line">            u.g = u.rhs</span><br><span class="line">            successors = self.SuccessorsCollisionFree(u)</span><br><span class="line">            <span class="keyword">for</span> succ <span class="keyword">in</span> successors:</span><br><span class="line">                self.UpdateVertex(succ)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            u.g = float(<span class="string">'inf'</span>)</span><br><span class="line">            self.UpdateVertex(u)</span><br><span class="line">            successors = self.SuccessorsCollisionFree(u)</span><br><span class="line">            <span class="keyword">for</span> succ <span class="keyword">in</span> successors:</span><br><span class="line">                self.UpdateVertex(succ)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> self.qgoal.rhs == self.qgoal.g <span class="keyword">and</span> self.qgoal.rhs != float(<span class="string">'inf'</span>):</span><br><span class="line">        self.FindPath()</span><br><span class="line">        print(<span class="string">'Found Path'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">'Not Found Path'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Planning</span><span class="params">(self)</span>:</span></span><br><span class="line"></span><br><span class="line">    num = input(<span class="string">"input obstacle numbers: "</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        input_num = eval(num)</span><br><span class="line">        <span class="keyword">if</span> type(input_num) == int:</span><br><span class="line">            self.AddObstacle(input_num)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> self.ComputeShortestPath() == <span class="literal">False</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        num = input(<span class="string">"input obstacle numbers: "</span>)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            input_num = eval(num)</span><br><span class="line">            <span class="keyword">if</span> type(input_num) == int:</span><br><span class="line">                obstacle_set = self.AddObstacle(input_num)</span><br><span class="line">                <span class="keyword">for</span> obs <span class="keyword">in</span> obstacle_set:</span><br><span class="line">                    successors = self.SuccessorsExcludeObstacle(obs)</span><br><span class="line">                    <span class="keyword">for</span> succ <span class="keyword">in</span> successors:</span><br><span class="line">                        self.UpdateVertex(succ)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>路径规划</category>
      </categories>
      <tags>
        <tag>路径规划</tag>
        <tag>motion planning</tag>
        <tag>LPA*</tag>
      </tags>
  </entry>
  <entry>
    <title>路径规划-A_Star</title>
    <url>/posts/1627378678/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><!-- build time:Sat Nov 13 2021 15:45:21 GMT+0000 (Coordinated Universal Time) --><h1>路径规划之 A_Star (A*)</h1><p>A*算法是一种基于启发式搜索的算法，该算法综合了 BFS(最佳优先搜索)和 Dijkstra 算法的优点：在进行启发式搜索提高算法效率的同时，可以保证找到一条最优路径。</p><a id="more"></a><p><img data-src="a_star.gif" alt="a_star.gif"></p><h2 id="算法描述"><a class="header-anchor" href="#算法描述">¶</a>算法描述</h2><p>A*算法扩展路径时，在主循环的每次迭代中，基于路当前节点到起点的成本以及将路径一直扩展到目标所需的估计成本来执行此操作。即选择最小化路径:</p><blockquote><p>$f(n)=g(n)+h(n)$</p></blockquote><p>随着路径的扩展，以扩展到的但未计算的节点放入列表 $open_table$ , 完成计算的节点放入列表 $close_table$。算法每次从 $open_table$ 中选择 $f(n)$ 最小的节点作为当前节点开始扩展。一直到找到目标点或者达到最大搜索次数而终止。</p><p>该公式包含有一下特征：</p><blockquote><p>如果$g(n)=0$, 即只计算当前节点<code>n</code>到目标节点<code>goal</code>的估计函数$h(n)$, 而不计算起点<code>start</code>到当前节点<code>n</code>的距离，算法转换为使用贪心策略的最佳优先搜索(BFS), 搜索速度提高，但是路径不是最优的<br>如果$h(n)$不大于当前节点<code>n</code>到目标节点<code>goal</code>的实际距离，则一定能得到最优解， 且$h(n)$越小，需要计算的节点越多，算法速度降低。<br>如果$h(n)=0$, 即只需求出起点<code>start</code>到当前节点<code>n</code>的最短路径$g(n)$，而不计算任何评估函数$h(n)$，则转化为单源最短路径问题，即 Dijkstra 算法，此时需要计算最多的顶点.</p></blockquote><p>其中：</p><blockquote><p>$f(n)$: 目标函数, 规划过程即最小化 f(n)；<br>$g(n)$: 起点$start$到当前节点$n$的实际距离；<br>$h(n)$: 启发函数, 当前节点$n$到终点$goal$的估计距离；<br>$open_table$: 记录需要搜寻过的节点列表<br>$close_table$: 记录已经被搜寻过的节点列表</p></blockquote><p>常用的启发函数$h(n)$一般有:</p><ul><li><p>曼哈顿距离:</p><blockquote><p>$d_{mahattan}=|p1.x-p2.x|+|p1.y-p2.y|$</p></blockquote></li><li><p>切比雪夫距离:</p><blockquote><p>$d_{chebyshev}=max(|p1.x-p2.x|,|p1.y-p2.y|)$</p></blockquote></li><li><p>欧式距离:</p><blockquote><p>$d_{euclidean}=\sqrt{(p1.x-p2.x)<sup>2+(p1.y-p2.y)</sup>2}$</p></blockquote></li><li><p>对角距离:</p><blockquote><p>$d_{diagonal}=(|p1.x-p2.x|+|p1.y-p2.y|)+\sqrt{2}-2\times min(|p1.x-p2.x|,|p1.y-p2.y|)$</p></blockquote></li></ul><h2 id="流程"><a class="header-anchor" href="#流程">¶</a>流程</h2><ul><li><p>初始化<code>A_STAR.__init__</code>: 初始化地图，对地图图片二值化处理，网格节点划分，若网格内包含障碍物，则该网格节点标记为障碍物: <code>Node.is_obs = True</code></p></li><li><p>输入需要随机产生的障碍物网格个数(可选);</p></li><li><p>计算起点<code>qstart</code>的$h$,$g$,$f$值,这里选择 $h=d_{mahattan}$, $g=d_{diagonal}$计算.将节点放入<code>open_table</code></p></li><li><p>开始迭代, 若迭代次数达到上限或者<code>open_table</code>为空, 则退出迭代：</p><ul><li><p>从<code>open_table</code>列表中选择<code>f</code>值最小的节点作为当前节点,记为<code>best_node</code></p></li><li><p>若<code>best_node</code>为目标节点<code>goal</code>, 即找到目标, 遍历<code>best_node</code>的父节点链表并逆序, 得到完整路径, 退出算法. 否则继续下一步:</p></li><li><p>将<code>best_node</code>从<code>open_table</code>列表弹出, 并放入<code>close_table</code>列表中.</p></li><li><p>搜索<code>best_node</code>的 8 个邻接节点<code>Neighbors</code>,对其中每个邻接节点<code>neighbor</code>:</p><ul><li><p>若该<code>neighbor</code>在<code>close_table</code>中,或者不可达, 则跳过该<code>neighbor</code>,检查下一个邻接节点, 否则继续下一步:</p></li><li><p>计算该<code>neighbor</code>的新<code>g</code>值(<code>tentative_g</code>), 即为当前节点<code>best_node</code>的<code>g</code>值加上, 当前节点<code>best_node</code>到该邻接节点<code>neighbor</code>的实际距离:<br><code>tentative_g = best_node.g + Distance(best_node, neighbor)</code></p></li><li><p>若该<code>neighbor</code>不在<code>open_table</code>中, 计算该<code>neighbor</code>的<code>g</code>, <code>h</code>, <code>f</code>值, 并放入<code>open_table</code>中</p></li><li><p>若该<code>neighbor</code>在<code>open_table</code>中:</p><ul><li><p>若该邻接节点<code>neighbor</code>新的<code>tentative_g</code>值比已有的<code>g</code>值小, 意味着当前节点<code>best_node</code>通过该<code>neighbor</code>可以更快的到达终点.</p></li><li><p>更新该<code>neighbor</code>节点的<code>g</code>值为<code>tentative_g</code>,并更新<code>f</code>值</p></li><li><p>更新该该<code>neighbor</code>节点的父节点为当前节点<code>best_node</code>.</p></li></ul></li></ul></li></ul></li></ul><h2 id="实现"><a class="header-anchor" href="#实现">¶</a>实现</h2><h3 id="数据结构"><a class="header-anchor" href="#数据结构">¶</a>数据结构</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, pos)</span>:</span></span><br><span class="line">        self.pos = pos          <span class="comment"># 当前节点的位置坐标</span></span><br><span class="line">        self.g = float(<span class="string">'inf'</span>)   <span class="comment"># 当前节点的g(n),g_score</span></span><br><span class="line">        self.h = float(<span class="string">'inf'</span>)   <span class="comment"># 当前节点的的h(n),h_score</span></span><br><span class="line">        self.f = float(<span class="string">'inf'</span>)   <span class="comment"># 当前节点的的f(n), f_score</span></span><br><span class="line">        self.p = <span class="literal">None</span>           <span class="comment"># 当前节点的父节点</span></span><br><span class="line">        self.is_obs = <span class="literal">False</span>     <span class="comment"># 当前节点是否是障碍物</span></span><br></pre></td></tr></table></figure><h3 id="接口"><a class="header-anchor" href="#接口">¶</a>接口</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">map_path:   地图图片路径</span></span><br><span class="line"><span class="string">qstart:     起点坐标 [row, col]</span></span><br><span class="line"><span class="string">qgoal:      目标点坐标 [row, col]</span></span><br><span class="line"><span class="string">grid_size:  网格大小（用来碰撞检测）</span></span><br><span class="line"><span class="string">max_steps:  最大扩展节点数</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">a_star = A_STAR(map_path, qstart, qgoal, grid_size, max_steps)</span><br></pre></td></tr></table></figure><h3 id="Planning"><a class="header-anchor" href="#Planning">¶</a>Planning</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Planning</span><span class="params">(self)</span>:</span></span><br><span class="line"></span><br><span class="line">    color_close = (random.randint(<span class="number">0</span>, <span class="number">255</span>),</span><br><span class="line">                   random.randint(<span class="number">0</span>, <span class="number">255</span>),</span><br><span class="line">                   random.randint(<span class="number">0</span>, <span class="number">255</span>))</span><br><span class="line"></span><br><span class="line">    color_open = (random.randint(<span class="number">0</span>, <span class="number">255</span>),</span><br><span class="line">                  random.randint(<span class="number">0</span>, <span class="number">255</span>),</span><br><span class="line">                  random.randint(<span class="number">0</span>, <span class="number">255</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># input numbers of obstacle grid if necessary</span></span><br><span class="line">    num = input(<span class="string">"input obstacle numbers: "</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        input_num = eval(num)</span><br><span class="line">        <span class="keyword">if</span> type(input_num) == int:</span><br><span class="line">            obstacle_set = self.AddObstacle(input_num)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># init qstart node</span></span><br><span class="line">    self.qstart.g = <span class="number">0</span></span><br><span class="line">    self.qstart.h = self.HScore(self.qstart)</span><br><span class="line">    self.qstart.f = self.FScore(self.qstart)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># init open_table and close_table</span></span><br><span class="line">    self.open_table = set()</span><br><span class="line">    self.close_table = set()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># add start node into open_table</span></span><br><span class="line">    self.open_table.add(self.qstart)</span><br><span class="line"></span><br><span class="line">    k = <span class="number">-1</span></span><br><span class="line">    <span class="keyword">while</span> k &lt; self.max_steps <span class="keyword">or</span> len(self.open_table) != <span class="number">0</span>:</span><br><span class="line"></span><br><span class="line">        <span class="comment"># get the node in open_table having the lowest f_score value</span></span><br><span class="line">        best_node = min(self.open_table, key=<span class="keyword">lambda</span> node: node.f)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># reach the goal node</span></span><br><span class="line">        <span class="keyword">if</span> best_node.pos == self.qgoal.pos:</span><br><span class="line">            print(<span class="string">"Found"</span>)</span><br><span class="line">            self.FindPath()</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># remove the best node in open table and add it into close table</span></span><br><span class="line">        self.open_table.remove(best_node)</span><br><span class="line">        self.close_table.add(best_node)</span><br><span class="line">        self.DrawGrid(best_node.pos, color_close)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># traversal the neighbors of best node</span></span><br><span class="line">        <span class="keyword">for</span> neighbor <span class="keyword">in</span> self.Neighbors(best_node):</span><br><span class="line"></span><br><span class="line">            <span class="comment"># if neighbor is in close table or is collision, skip</span></span><br><span class="line">            <span class="keyword">if</span> neighbor <span class="keyword">in</span> self.close_table <span class="keyword">or</span> self.CollisionFree(best_node, neighbor) == <span class="literal">False</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># calculate the tentative_g which is the distance from start to the neighbor through best_node</span></span><br><span class="line">            tentative_g = self.GScore(best_node, neighbor)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># check the neighbor is in open table or not</span></span><br><span class="line">            <span class="keyword">if</span> neighbor <span class="keyword">not</span> <span class="keyword">in</span> self.open_table:</span><br><span class="line">                <span class="comment"># if neighbor not in open table,</span></span><br><span class="line">                <span class="comment"># then calculate the g, h, f values and add it into open table</span></span><br><span class="line">                neighbor.g = tentative_g</span><br><span class="line">                neighbor.h = self.HScore(neighbor)</span><br><span class="line">                neighbor.f = self.FScore(neighbor)</span><br><span class="line">                neighbor.p = best_node</span><br><span class="line">                self.open_table.add(neighbor)</span><br><span class="line">                self.DrawGrid(neighbor.pos, color_open)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># if neighbor in open table,</span></span><br><span class="line">                <span class="comment"># then compare the tentative_g and neighbor.g</span></span><br><span class="line">                <span class="keyword">if</span> tentative_g &lt; neighbor.g:</span><br><span class="line">                    <span class="comment"># the path from best_node to neighbor is better than previous</span></span><br><span class="line">                    neighbor.g = tentative_g</span><br><span class="line">                    neighbor.f = self.FScore(neighbor)</span><br><span class="line">                    neighbor.p = best_node</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"Not Found"</span>)</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>路径规划</category>
      </categories>
      <tags>
        <tag>路径规划</tag>
        <tag>motion planning</tag>
        <tag>A*</tag>
      </tags>
  </entry>
  <entry>
    <title>路径规划-RRT</title>
    <url>/posts/2955947163/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><!-- build time:Sat Nov 13 2021 15:45:21 GMT+0000 (Coordinated Universal Time) --><h1>路径规划之 Rapidly-Exploring Random Trees (快速扩展随机树)</h1><p>RRTs 作为一种 single-query 的规划算法被引入，它有效地覆盖了 q<sub>init</sub> 和 q<sub>goal</sub> 之间的空间。该规划器最初也是为 kinodynamic 运动规划而开发的，就像在 ESTs 中一样，只构建一棵树。RRTs 的适用范围超出了 kinodynamic 规划问题。RRT 算法已被证明是概率完备的。</p><a id="more"></a><p><img data-src="rrt.gif" alt="rrt.gif"></p><h2 id="算法描述"><a class="header-anchor" href="#算法描述">¶</a>算法描述</h2><p>$T$表示一颗树。 $T_{init}$ 和 $T_{goal}$ 根节分别为 $q_{init}$ 和 $q_{goal}$ 的树。每棵树$T$都是增量扩展的。在每次迭代中，在 $Q_{free}$ 中随机均匀采样一点 $q_{rand}$ 。在$T$中找到距离 $q_{rand}$ 最近的节点 $q_{near}$ ，并尝试从 $q_{near}$ 向 $q_{rand}$ 方向移动一段距离 $step_size$ ，生成一个新节点 $q_{new}$ 。若该节点是无碰撞的(collision-free)，则添加节点 $q_{new}$ 到 $T$ 的顶点集合(vertices)中，添加 $(q_{near}, q_{new})$ 到 $T$ 的边集合(edges)中。下图展示了 RRT 在二维欧式空间扩展一个点的过程。</p><p><img data-src="algorithm_rrt_extension.png" alt="Figure 7.14"></p><h3 id="伪码"><a class="header-anchor" href="#伪码">¶</a>伪码</h3><p><img data-src="algorithm_rrt.png" alt="Algorithms RRT"></p><h2 id="流程"><a class="header-anchor" href="#流程">¶</a>流程</h2><ol><li>初始化随机树，树结点和边只包含起点 $q_{start}$（根节点）。边和书中有一点区别，因为这里的节点用了一个链表结构，这里每个扩展节点 ($q_{new}$) 包含有一个后向指针，指向源节点 ($q_{near}$)，所以不需要单独定义边。只要构造出树，最后反向遍历即可完成路径的构造。</li><li>起始点 start 加入到树节点和边中</li><li>开始迭代</li><li><code>GenerateRandomNode()</code>: 在状态空间（机械臂的关节空间或者笛卡尔空间；小车可达的二维地图空间）中随机采样一个点 $q_{rand}$ 。为加快 RRT 到达目标点 $q_{goal}$ 的速度，在随机采样过程中，加随机的概率 p 来决定，此次扩展的目标点 $q_{goal}$ 是随机点还是目标点 $q_{goal}$ 。当 $0\ltp prob$ 时，取随机采样点；否则取目标点 $q_{goal}$ 。这个概率不宜过大，否则容易陷入障碍物包围圈中不容易跳出。</li><li><code>FindNearestNode(qrand)</code>: 遍历 RRT 树节点，返回距离 $q_{rand}$ 最近的一个节点 $q_{near}$</li><li><code>ExtendTree(qnear, qrand)</code>: 沿着 $(q_{near}, q_{rand})$ 方向，以一定的步长 $step_size$ 扩展一个新节点 $q_{new}$, 如果扩展不成功（超出地图范围），返回 None，放弃这次扩展。</li><li><code>CollsionFree(qnear, qnew)</code>: 对 $(q_{near}, q_{new})$ 路径进行碰撞检查，包括路径过程中及起始点是否有障碍物。这里采用等间距采样，检查路径中位置点所处网格是否包络障碍物。如果发生碰撞，则放弃扩展。</li><li>如果新节点 $q_{new}$ 被接受（新节点不为<code>None</code>且与 $(q_{near}, q_{new})$ 之间的路径无碰撞），则将该点加入到树中，并将该节点的后向指针 $q_{new}.parent$ 指向 $q_{near}$ 。这样，在找到目标点时，根据该指针，可遍历得到完整的路径。为了防止树节点过多，可以再检查$q_{new}$是否与树中某个节点过于接近（一般取小于扩展步长），如果是，则也可以放弃此次扩展。但是这也会导致算法时间增长，毕竟要遍历树节点计算距离。</li><li><code>IsArrival(qnew)</code>: 检查是否到达目标点 $q_{goal}$ , 如果新节点 $q_{new}$ 距离目标点 $q_{goal}$ 小于扩展步长 $step_size$ ，且无碰撞，则认为找到，将目标点 $q_{goal}$ 作为树的最后一个节点添加到 RRT 树中。</li><li><code>FindPath()</code>: 根据目标节点 $q_{goal}$ 的反向指针，遍历至起点 $q_{start}$ ，即完成路径的构造。</li><li><code>SmoothPath(path)</code>: 上一步的路径是按照步长一个节点一个节点扩展的，因此这里可以对路径进行圆滑，遍历路径的节点，取最长不碰撞的节点构造新路径。</li></ol><h2 id="算法实现"><a class="header-anchor" href="#算法实现">¶</a>算法实现</h2><h3 id="数据结构"><a class="header-anchor" href="#数据结构">¶</a>数据结构</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, pos=[<span class="number">0</span>, <span class="number">0</span>])</span>:</span></span><br><span class="line">        self.pos = pos</span><br><span class="line">        self.parent = <span class="literal">None</span></span><br></pre></td></tr></table></figure><h3 id="接口"><a class="header-anchor" href="#接口">¶</a>接口</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">map_path: 地图图片路径</span></span><br><span class="line"><span class="string">qstart: 起点坐标 [row, col]</span></span><br><span class="line"><span class="string">qgoal: 目标点坐标 [row, col]</span></span><br><span class="line"><span class="string">grid_size: 网格大小（用来碰撞检测）</span></span><br><span class="line"><span class="string">step_size: 扩展步长</span></span><br><span class="line"><span class="string">max_steps: 最大扩展节点数</span></span><br><span class="line"><span class="string">goal_prob: 增加趋向目标点概率（贪婪）</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">rrt = RRT(map_path, qstart, qgoal, grid_size,</span><br><span class="line">          step_size, max_steps, goal_prob)</span><br></pre></td></tr></table></figure><h3 id="Planning"><a class="header-anchor" href="#Planning">¶</a>Planning</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Planning</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    rrt planning</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    self.AddVertices(self.qstart)</span><br><span class="line">    self.AddEdges(<span class="literal">None</span>, self.qstart)</span><br><span class="line"></span><br><span class="line">    k = <span class="number">-1</span></span><br><span class="line">    <span class="keyword">while</span> k &lt; self.max_steps:</span><br><span class="line">        k += <span class="number">1</span></span><br><span class="line">        qrand = self.GenerateRandomNode()</span><br><span class="line">        _, qnear = self.FindNearestNode(qrand)</span><br><span class="line">        qnew = self.ExtendTree(qnear, qrand)</span><br><span class="line">        <span class="keyword">if</span> qnew <span class="keyword">and</span> self.CollsionFree(qnear, qnew):</span><br><span class="line">            self.AddVertices(qnew)</span><br><span class="line">            self.AddEdges(qnear, qnew)</span><br><span class="line"></span><br><span class="line">            self.DrawEdges(qnear, qnew)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.IsArrival(qnew):</span><br><span class="line">                print(<span class="string">"Found"</span>)</span><br><span class="line">                self.AddVertices(self.qgoal)</span><br><span class="line">                self.AddEdges(qnew, self.qgoal)</span><br><span class="line"></span><br><span class="line">                path = self.FindPath()</span><br><span class="line">                self.DrawPath(path)</span><br><span class="line">                smooth_path = self.SmoothPath(path)</span><br><span class="line">                self.DrawPath(smooth_path)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    print(<span class="string">'Not Found'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>路径规划</category>
      </categories>
      <tags>
        <tag>路径规划</tag>
        <tag>motion planning</tag>
        <tag>RRT</tag>
      </tags>
  </entry>
  <entry>
    <title>ROS学习-controller_manager</title>
    <url>/posts/1366633795/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><!-- build time:Sat Nov 13 2021 15:45:21 GMT+0000 (Coordinated Universal Time) --><p><code>controller_manager</code>提供硬实时兼容的环来控制的机械手,由一个<code>hardware_interface::RobotHW</code>实例代表(参见<code>hardware_interface</code>包).该<code>controller_manager</code>提供了加载,卸载,启动和停止控制器的基本结构.</p><a id="more"></a><p>当加载一个控制器时,<code>controller_manager</code>将使用控制器名作为所有控制器特定参数的<code>root</code>,最重要的是,<code>type</code>用于标识要加载哪个插件.</p><h2 id="控制器运行的工具-Tools-for-running-controllers"><a class="header-anchor" href="#控制器运行的工具-Tools-for-running-controllers">¶</a>控制器运行的工具(<code>Tools for running controllers</code>)</h2><p>控制器管理器提供的与控制器进行交互的基本结构.根据控制器从启动文件,命令行,或者<code>ROS</code>节点运行,控制管理器提供不同的工具来运行控制器.</p><p><a href="http://wiki.ros.org/controller_manager?action=AttachFile&amp;do=get&amp;target=controller+state.png">controller_manager</a></p><h2 id="命令行工具-Command-line-tools"><a class="header-anchor" href="#命令行工具-Command-line-tools">¶</a>命令行工具(<code>Command-line tools</code>)</h2><h3 id="控制管理器-controller-manager"><a class="header-anchor" href="#控制管理器-controller-manager">¶</a>控制管理器(<code>controller_manager</code>)</h3><p>使用<code>controller_manager</code>工具与从命令行运行的控制器交互.要与特定的控制器进行交互,可以使用:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ rosrun controller_manager controller_manager &lt;<span class="built_in">command</span>&gt; &lt;controller_name&gt;</span><br></pre></td></tr></table></figure><p>以下命令可用:</p><table><thead><tr><th style="text-align:left"></th><th style="text-align:left"></th></tr></thead><tbody><tr><td style="text-align:left"><strong><code>load</code></strong>:</td><td style="text-align:left">加载控制器 (construct and initialize)</td></tr><tr><td style="text-align:left"><strong><code>unload</code></strong>:</td><td style="text-align:left">卸载控制器 (destruct)</td></tr><tr><td style="text-align:left"><strong><code>start</code></strong>:</td><td style="text-align:left">启动控制器</td></tr><tr><td style="text-align:left"><strong><code>stop</code></strong>:</td><td style="text-align:left">结束控制器</td></tr><tr><td style="text-align:left"><strong><code>spawn</code></strong>:</td><td style="text-align:left">加载并启动控制器</td></tr><tr><td style="text-align:left"><strong><code>kill</code></strong>:</td><td style="text-align:left">停止并卸载控制器</td></tr></tbody></table><p>想获得控制器状态, 用:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ rosrun controller_manager controller_manager &lt;<span class="built_in">command</span>&gt;</span><br></pre></td></tr></table></figure><p>以下命令可用:</p><table><thead><tr><th style="text-align:left"></th><th style="text-align:left"></th></tr></thead><tbody><tr><td style="text-align:left"><strong><code>list</code></strong>:</td><td style="text-align:left">根据执行顺序,列出所有控制器,并给出每个控制器的状态</td></tr><tr><td style="text-align:left"><strong><code>list-types</code></strong>:</td><td style="text-align:left">列出所有控制器管理知道的控制器类型.如果控制器不在此列表中,将无法加载并启动.</td></tr><tr><td style="text-align:left"><strong><code>list-joints</code></strong>:</td><td style="text-align:left">列出所有控制器管理使用的的关节和驱动器的名称.</td></tr><tr><td style="text-align:left"><strong><code>reload-libraries</code></strong>:</td><td style="text-align:left">重新加载所有可作为插件的控制器库.当我们正在开发控制器时,可以方便的测试控制器代码,而 不用每次都重新启动机器人.</td></tr><tr><td style="text-align:left"><strong><code>reload-libraries --restore</code></strong>:</td><td style="text-align:left">重新加载所有可作为插件的的控制器库,并把所有控制器恢复到初始状态.</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td></tr></tbody></table><h3 id="加载并启动控制器-spawner"><a class="header-anchor" href="#加载并启动控制器-spawner">¶</a>加载并启动控制器(<code>spawner</code>)</h3><p>为了立刻自动加载并启动一系列控制器以及立刻停止并卸载这些控制器,使用<code>spawner</code>工具:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ rosrun controller_manager spawner [--stopped] name1 name2 name3</span><br></pre></td></tr></table></figure><p>当运行<code>spawner</code>时,列表中控制器将被载入和启动(除非指定<code>--stopped</code>). 当控制器已开启(<code>controllers are up</code>),<code>spawner</code>将保持运行.当你杀死<code>spawner</code>进程(<code>CTRL-C</code>),会自动停止并卸载所有它最开始启动的控制器.</p><h3 id="卸载控制器-unspawner"><a class="header-anchor" href="#卸载控制器-unspawner">¶</a>卸载控制器(<code>unspawner</code>)</h3><p>想要自动停止一组控制器,然后重新启动,可使用<code>unspawner</code>工具:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ rosrun controller_manager unspawner name1 name2 name3</span><br></pre></td></tr></table></figure><p>列表中的控制器将被停止,但没有卸载.一旦<code>spawner</code>关闭,该控制器将重新启动.</p><h3 id="控制器组-controller-group"><a class="header-anchor" href="#控制器组-controller-group">¶</a>控制器组(<code>controller_group</code>)</h3><p><code>controller_group</code>允许开发者在运行时切换控制器,但是出于一些特殊意图,当你想从一组控制器切换到另一组时,这就不是很方便.<code>controller_group</code>脚本对于那些在<code>ROS parameter controller_groups</code>已经定义的分组的切换就很容易实现.它知道所有包含的控制器,当它切换控制器组时,控制器需要被停止或者被启动.所以,不同的控制器组可以共享某些控制器.</p><p><code>controller_groups</code>的一个例子:</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">controller_groups:</span></span><br><span class="line">  <span class="attr">production:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">prod_controller_1</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">prod_controller_2</span></span><br><span class="line">  <span class="attr">development:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">devel_controller_1</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">devel_controller_2</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">shared_controller_3</span></span><br><span class="line">  <span class="attr">diagnostics:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">diag_controller_1</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">diag_controller_2</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">shared_controller_3</span></span><br></pre></td></tr></table></figure><p>启动<code>controller_groups</code>的脚本:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ rosrun controller_manager controller_group &lt;<span class="built_in">command</span>&gt; &lt;args&gt;</span><br></pre></td></tr></table></figure><p>以下命令可用:</p><table><thead><tr><th style="text-align:left"></th><th style="text-align:left"></th></tr></thead><tbody><tr><td style="text-align:left"><strong><code>list</code></strong>:</td><td style="text-align:left">列出所有能在<code>controler_groups</code>参数中找到的组定义</td></tr><tr><td style="text-align:left"><strong><code>spawn &lt;group&gt;</code></strong>:</td><td style="text-align:left">载入和启动所有包含在名称为<code>&lt;group&gt;</code>组内的所有控制器,通常在<code>ROS launch</code>文件中使用</td></tr><tr><td style="text-align:left"><strong><code>switch &lt;group&gt;</code></strong>:</td><td style="text-align:left">切换到<code>&lt;group&gt;</code>组.这意味着将停止其他组内正在运行的控制器,但是定在在本组内的不会被停止,然后启动在本组内的未运行的控制器器</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td></tr></tbody></table><h2 id="创建启动文件-Creating-launch-files"><a class="header-anchor" href="#创建启动文件-Creating-launch-files">¶</a>创建启动文件(<code>Creating launch files</code>)</h2><p>我们可以运行<code>controller_manager</code>,从启动文件(<code>launch file</code>)内启动控制器.然而,即使启动文件被撤下,控制器仍会保持.而<code>spawner</code>工具会从启动文件中自动加载,启动,停止和卸载控制器.当启动<code>spawner</code>工具时,它会加载并启动控制器.当你停止<code>spawner</code>(当启动文件被撤下),它将停止并卸载控制器.启动文件可能如下:</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">"controller_manager"</span> <span class="attr">type</span>=<span class="string">"spawner"</span> <span class="attr">args</span>=<span class="string">"controller_name1 controller_name2"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>或者,只是想加载控制器,但是还没有启动:</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">"controller_manager"</span> <span class="attr">type</span>=<span class="string">"spawner"</span> <span class="attr">args</span>=<span class="string">"--stopped controller_name1 controller_name2"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="图形工具-Graphical-tools"><a class="header-anchor" href="#图形工具-Graphical-tools">¶</a>图形工具(Graphical tools)</h2><p><code>rqt_controller_manager</code>是一个<code>rqt</code>插件,该插件以图形化方式加载,卸载,启动和停止控制器;同时用来显示加载的控制器的信息.</p><p>它可以从<code>rqt</code>的<code>Plugin</code>菜单中启动,或者通过命令行单独执行:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rosrun rqt_controller_manager rqt_controller_manager</span><br></pre></td></tr></table></figure><h2 id="ROS应用程序接口-ROS-API"><a class="header-anchor" href="#ROS应用程序接口-ROS-API">¶</a><code>ROS</code>应用程序接口(<code>ROS API</code>)</h2><p>为了与另一个<code>ROS</code>节点的控制器交互,控制管理器提供了五种服务调用:</p><h2 id="控制管理器-controller-manager-v2"><a class="header-anchor" href="#控制管理器-controller-manager-v2">¶</a>控制管理器 (<code>controller_manager</code>)</h2><h3 id="服务-Services"><a class="header-anchor" href="#服务-Services">¶</a>服务(Services)</h3><p><code>controller_manager/load_controller (controller_manager_msgs/LoadController)</code></p><blockquote><p>服务请求包含了要加载的控制器的名字,响应包含了一个表示成功或失败的布尔值.</p></blockquote><p><code>controller_manager/unload_controller (controller_manager_msgs/UnloadController)</code></p><blockquote><p>服务请求中包含要卸载的控制器的名称,响应包含了一个表示成功或失败的布尔值.控制器只能在当其处于停止状态的时候被卸载.</p></blockquote><p><code>controller_manager/switch_controller (controller_manager_msgs/SwitchController)</code></p><blockquote><p>服务请求包含了要开始的控制器的名称列表,要停止的控制器名称列表和一个表明规范性 (<code>strictness: BEST_EFFORT or STRICT</code>)的整型值(<code>int</code>).<code>STRICT</code>表示如果出现任何错误(无效的控制器名称,控制器启动失败,<code>etc</code>),控制器的切换(<code>switching</code>)将会失败并导致空操作(<code>no-op</code>).<code>BEST_EFFORT</code>表示,即使控制器出现了一些问题,该服务仍然会尝试启动/停止余下的控制器.服务响应包含了一个表示成功或失败的布尔值.如果只是停止或者只是启动控制器,控制器启动或停止的列表可能为空.</p></blockquote><p><code>controller_manager/list_controllers (controller_manager_msgs/ListControllers)</code></p><blockquote><p>该服务返回所有当前加载的控制器.响应包括以下信息:控制器的名称,状态(运行或停止),类型,硬件接口,和占用的资源.</p></blockquote><p><code>controller_manager/list_controller_types (controller_manager_msgs/ListControllerTypes)</code></p><blockquote><p>该服务返回<code>controller_manager</code>已知的所有控制器类型.只有已知的控制器类型可以构建.</p></blockquote><p><code>controller_manager/reload_controller_libraries (controller_manager_msgs/ReloadControllerLibraries)</code></p><blockquote><p>服务重新加载所有可作为插件的控制器库.当我们正在开发控制器时,无需每次重新启动机器人 就可以方便的测试控制器代码.此服务只在控制器没有加载情况下工作.</p></blockquote><p>Translated by Ms Wang 2014-8-19</p><p>Wiki: controller_manager (last edited 2014-03-10 15:22:46 by AdolfoRodriguez)</p><hr><p>参考来源:</p><ul><li><a href="http://wiki.ros.org/cn/controller_manager" target="_blank" rel="noopener">http://wiki.ros.org/cn/controller_manager</a></li><li><a href="http://wiki.ros.org/controller_manager?distro=kenetic" target="_blank" rel="noopener">http://wiki.ros.org/controller_manager?distro=kenetic</a></li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>ROS学习</category>
      </categories>
      <tags>
        <tag>ROS</tag>
        <tag>controller_manager</tag>
      </tags>
  </entry>
  <entry>
    <title>ROS学习-ur5机器人的gazebo仿真以及controller的使用</title>
    <url>/posts/1500545740/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><!-- build time:Sat Nov 13 2021 15:45:21 GMT+0000 (Coordinated Universal Time) --><p>这篇文章主要介绍了如何在<code>gazebo</code>中对<code>ur5</code>进行仿真和<code>controller</code>的使用，包括<code>controller_manager</code>的使用和控制器<code>command</code>的主题数据发布。</p><a id="more"></a><ul><li><p>ur 机器人的下载编译可以参考官方的帮助文档，下载源码，然后<code>catkin_make</code>，然后<code>source devel/setup.bash</code>载入资源文件。</p></li><li><p>在<code>gazebo</code>中启动 <code>ur5</code> 模型，终端输入：</p></li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">roslaunch ur_gazebo ur5.launch limited:=<span class="literal">true</span></span><br></pre></td></tr></table></figure><ul><li>ur5 模型的参数服务器中包含两个控制器, <code>position_controllers/JointTrajectoryController</code>和<code>position_controllers/JointGroupPositionController</code>这里先用位置控制模式<code>JointGroupPositionController</code>，就是单独控制关节轴，这样我们可以直观看到关节轴响应了下发的位置指令。</li></ul><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">arm_controller:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">position_controllers/JointTrajectoryController</span></span><br><span class="line">  <span class="attr">joints:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">shoulder_pan_joint</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">shoulder_lift_joint</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">elbow_joint</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">wrist_1_joint</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">wrist_2_joint</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">wrist_3_joint</span></span><br><span class="line">  <span class="attr">constraints:</span></span><br><span class="line">    <span class="attr">goal_time:</span> <span class="number">0.6</span></span><br><span class="line">    <span class="attr">stopped_velocity_tolerance:</span> <span class="number">0.05</span></span><br><span class="line">    <span class="attr">shoulder_pan_joint:</span> <span class="string">&#123;</span> <span class="attr">trajectory:</span> <span class="number">0.1</span><span class="string">,</span> <span class="attr">goal:</span> <span class="number">0.1</span> <span class="string">&#125;</span></span><br><span class="line">    <span class="attr">shoulder_lift_joint:</span> <span class="string">&#123;</span> <span class="attr">trajectory:</span> <span class="number">0.1</span><span class="string">,</span> <span class="attr">goal:</span> <span class="number">0.1</span> <span class="string">&#125;</span></span><br><span class="line">    <span class="attr">elbow_joint:</span> <span class="string">&#123;</span> <span class="attr">trajectory:</span> <span class="number">0.1</span><span class="string">,</span> <span class="attr">goal:</span> <span class="number">0.1</span> <span class="string">&#125;</span></span><br><span class="line">    <span class="attr">wrist_1_joint:</span> <span class="string">&#123;</span> <span class="attr">trajectory:</span> <span class="number">0.1</span><span class="string">,</span> <span class="attr">goal:</span> <span class="number">0.1</span> <span class="string">&#125;</span></span><br><span class="line">    <span class="attr">wrist_2_joint:</span> <span class="string">&#123;</span> <span class="attr">trajectory:</span> <span class="number">0.1</span><span class="string">,</span> <span class="attr">goal:</span> <span class="number">0.1</span> <span class="string">&#125;</span></span><br><span class="line">    <span class="attr">wrist_3_joint:</span> <span class="string">&#123;</span> <span class="attr">trajectory:</span> <span class="number">0.1</span><span class="string">,</span> <span class="attr">goal:</span> <span class="number">0.1</span> <span class="string">&#125;</span></span><br><span class="line">  <span class="attr">stop_trajectory_duration:</span> <span class="number">0.5</span></span><br><span class="line">  <span class="attr">state_publish_rate:</span> <span class="number">25</span></span><br><span class="line">  <span class="attr">action_monitor_rate:</span> <span class="number">10</span></span><br><span class="line"><span class="attr">joint_group_position_controller:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">position_controllers/JointGroupPositionController</span></span><br><span class="line">  <span class="attr">joints:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">shoulder_pan_joint</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">shoulder_lift_joint</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">elbow_joint</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">wrist_1_joint</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">wrist_2_joint</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">wrist_3_joint</span></span><br></pre></td></tr></table></figure><ul><li><p>ur5 的<code>launch</code>文件中，默认启动的控制器是关节轨迹控制，所以这里涉及到如何切换控制器的操作，详细内容可以参考<code>controller_manager</code>这篇文章。一下给出实际的操作。</p></li><li><p>首先查看已载入的控制器：可以看到 ur 内部载入了两个控制器，就是在参数文件中显示的两个，<code>arm_controller</code>和<code>joint_group_position_controller</code>。</p></li></ul><blockquote><p><code>rosrun controller_manager controller_manager list</code></p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">arm_controller - hardware_interface::PositionJointInterface ( stopped )</span><br><span class="line">joint_state_controller - hardware_interface::JointStateInterface ( running )</span><br><span class="line">joint_group_position_controller - hardware_interface::PositionJointInterface ( running )</span><br></pre></td></tr></table></figure><ul><li>暂停<code>arm_controller</code>，执行成功后会显示成功执行信息：</li></ul><blockquote><p><code>rosrun controller_manager controller_manager stop arm_controller</code></p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Stopped [<span class="string">'arm_controller'</span>] successfully</span><br></pre></td></tr></table></figure><ul><li>启动<code>joint_group_position_controller</code>，同样也有执行成功与否的信息输出：</li></ul><blockquote><p><code>rosrun controller_manager controller_manager start joint_group_position_controller</code></p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Started [<span class="string">'joint_group_position_controller'</span>] successfully</span><br></pre></td></tr></table></figure><ul><li><code>controller_manager</code>的详细指令如下：</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ rosrun controller_manager controller_manager &lt;<span class="built_in">command</span>&gt; &lt;controller_name&gt;</span><br></pre></td></tr></table></figure><p>以下<code>command</code>可用:</p><table><thead><tr><th style="text-align:left"></th><th style="text-align:left"></th></tr></thead><tbody><tr><td style="text-align:left"><strong><code>load</code></strong>:</td><td style="text-align:left">加载控制器 (construct and initialize)</td></tr><tr><td style="text-align:left"><strong><code>unload</code></strong>:</td><td style="text-align:left">卸载控制器 (destruct)</td></tr><tr><td style="text-align:left"><strong><code>start</code></strong>:</td><td style="text-align:left">启动控制器</td></tr><tr><td style="text-align:left"><strong><code>stop</code></strong>:</td><td style="text-align:left">结束控制器</td></tr><tr><td style="text-align:left"><strong><code>spawn</code></strong>:</td><td style="text-align:left">加载并启动控制器</td></tr><tr><td style="text-align:left"><strong><code>kill</code></strong>:</td><td style="text-align:left">停止并卸载控制器</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td></tr></tbody></table><ul><li><p>开始输入关节位置控制指令</p></li><li><p>这里可以先查看一下关节位置指令的数据结构</p></li><li><p>输入:</p></li></ul><blockquote><p><code>rostopic list</code></p></blockquote><ul><li>可以看到有控制器的一个主题:</li></ul><blockquote><p><code>/joint_group_position_controller/command</code></p></blockquote><ul><li>查看主题信息：该<code>topic</code>的<code>type</code>是<code>std_msgs/Float64MultiArray</code>。因此我们<code>pub</code>这个<code>topic</code>时就需要发送这个数据结构。</li></ul><blockquote><p><code>rostopic info /joint_group_position_controller/command</code></p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Type: std_msgs/Float64MultiArray</span><br><span class="line"></span><br><span class="line">Publishers: None</span><br><span class="line"></span><br><span class="line">Subscribers:</span><br><span class="line"> * /rostopic_120258_1572071888740 (http://localhost:42655/)</span><br><span class="line"> * /gazebo (http://localhost:35425/)</span><br></pre></td></tr></table></figure><ul><li>发布主题。因为这里<code>Float64MultiArray</code>是一个数组，如果是单个数据类型，那在数据结构后面直接跟具体的数据即可。如果是数组，那需要以<code>python list</code>的方式发送。这里<code>-r 50</code>表示这个<code>topic</code>的发布速率是<code>50hz</code>。然后就可以在<code>gazebo</code>中看到机器人五轴转了一个角度。</li></ul><blockquote><p><code>rostopic pub -r 50 /joint_group_position_controller/command std_msgs/Float64MultiArray '{data: [0,0,0,0,10,30]}'</code></p></blockquote><ul><li>同时可以打开另一个终端，看到发布的<code>topic</code>的详细信息</li></ul><blockquote><p><code>rostopic echo /joint_group_position_controller/command</code></p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">layout:</span><br><span class="line">  dim: []</span><br><span class="line">  data_offset: 0</span><br><span class="line">data: [0.0, 0.0, 0.0, 0.0, 10.0, 30.0]</span><br><span class="line">---</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>ROS学习</category>
      </categories>
      <tags>
        <tag>ROS</tag>
        <tag>gazebo</tag>
        <tag>controller-manager</tag>
        <tag>ur5</tag>
      </tags>
  </entry>
  <entry>
    <title>ROS学习-xacro</title>
    <url>/posts/2389657244/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><!-- build time:Sat Nov 13 2021 15:45:21 GMT+0000 (Coordinated Universal Time) --><p>Xacro(XML Macros)Xacro 是一种 XML 宏语言. 使用 xacro, 可以通过使用宏命令构建更精悍短小但又具有更高可读性的 XML 文件, 这种宏命令可以扩展达到更大的 XML 表达范围. 此包在处理大型 XML 文档(如机器人说明)时最为有用. 它在如 urdf 的包中大量使用. 本文主要来源于<a href="http://wiki.ros.org/xacro" target="_blank" rel="noopener">官方教程</a>.</p><a id="more"></a><h2 id="目录"><a class="header-anchor" href="#目录">¶</a>目录</h2><p><a href="#1-%e6%a1%88%e4%be%8b">1. 案例</a><br><a href="#2-%e5%b1%9e%e6%80%a7%e5%92%8c%e5%b1%9e%e6%80%a7%e5%9d%97">2. 属性和属性块</a><br><a href="#3-%e6%95%b0%e5%ad%a6%e8%a1%a8%e8%be%be%e5%bc%8f">3. 数学表达式</a><br><a href="#4-%e6%9d%a1%e4%bb%b6%e5%9d%97">4. 条件块</a><br><a href="#4-%e6%9d%a1%e4%bb%b6%e5%9d%97">5. <code>Rospack</code>命令</a><br><a href="#5-rospack%e5%91%bd%e4%bb%a4">6. 宏命令</a><br><a href="#61-%e9%bb%98%e8%ae%a4%e5%8f%82%e6%95%b0">6.1 默认参数</a><br><a href="#62-%e5%b1%80%e9%83%a8%e5%b1%9e%e6%80%a7">6.2 局部属性</a><br><a href="#7-%e5%8c%85%e5%90%ab%e5%85%b6%e4%bb%96xacro%e6%96%87%e4%bb%b6">7. 包含其他<code>xacro</code>文件</a><br><a href="#8-yaml%e8%af%ad%e8%a8%80%e6%94%af">8. <code>YAML</code>语言支持</a><br><a href="#9-%e7%94%a8cmakeliststxt%e8%bf%9b%e8%a1%8c%e6%9e%84%e5%bb%ba">9. 用<code>CMakeLists.txt</code>进行构建</a><br><a href="#10-%e5%85%83%e7%b4%a0%e4%b8%8e%e5%b1%9e%e6%80%a7">10. 元素和属性</a><br><a href="#11-%e5%a4%84%e7%90%86%e9%a1%ba%e5%ba%8f">11. 处理顺序</a><br><a href="#12-%e5%b7%b2%e5%bc%83%e7%94%a8%e7%9a%84%e8%af%ad%e6%b3%95">12. 已弃用的语法</a></p><h2 id="案例"><a class="header-anchor" href="#案例">¶</a>案例</h2><p>参考以下的<code>Xacro XML</code>片段:</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xacro:macro</span> <span class="attr">name</span>=<span class="string">"pr2_arm"</span> <span class="attr">params</span>=<span class="string">"suffix parent reflect"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">pr2_upperarm</span> <span class="attr">suffix</span>=<span class="string">"$&#123;suffix&#125;"</span> <span class="attr">reflect</span>=<span class="string">"$&#123;reflect&#125;"</span> <span class="attr">parent</span>=<span class="string">"$&#123;parent&#125;"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">pr2_forearm</span> <span class="attr">suffix</span>=<span class="string">"$&#123;suffix&#125;"</span> <span class="attr">reflect</span>=<span class="string">"$&#123;reflect&#125;"</span> <span class="attr">parent</span>=<span class="string">"elbow_flex_$&#123;suffix&#125;"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xacro:macro</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">xacro:pr2_arm</span> <span class="attr">suffix</span>=<span class="string">"left"</span> <span class="attr">reflect</span>=<span class="string">"1"</span> <span class="attr">parent</span>=<span class="string">"torso"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">xacro:pr2_arm</span> <span class="attr">suffix</span>=<span class="string">"right"</span> <span class="attr">reflect</span>=<span class="string">"-1"</span> <span class="attr">parent</span>=<span class="string">"torso"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>上面的片段扩展成为下面的样子:</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">pr2_upperarm</span> <span class="attr">suffix</span>=<span class="string">"left"</span> <span class="attr">reflect</span>=<span class="string">"1"</span> <span class="attr">parent</span>=<span class="string">"torso"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">pr2_forearm</span> <span class="attr">suffix</span>=<span class="string">"left"</span> <span class="attr">reflect</span>=<span class="string">"1"</span> <span class="attr">parent</span>=<span class="string">"elbow_flex_left"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">pr2_upperarm</span> <span class="attr">suffix</span>=<span class="string">"right"</span> <span class="attr">reflect</span>=<span class="string">"-1"</span> <span class="attr">parent</span>=<span class="string">"torso"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">pr2_forearm</span> <span class="attr">suffix</span>=<span class="string">"right"</span> <span class="attr">reflect</span>=<span class="string">"-1"</span> <span class="attr">parent</span>=<span class="string">"elbow_flex_right"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>如果我们还定义了<code>pr2_upperarm</code>和<code>pr2_forearm</code>的宏, 那么这个片段可以扩展以描述整个机器人臂.</p><p>本文的其余部分描述了<code>xacro</code>的功能.</p><h2 id="属性和属性块"><a class="header-anchor" href="#属性和属性块">¶</a>属性和属性块</h2><p>属性是可以插入到<code>XML</code>文档中的任何位置的值. 属性块是<code>XML</code>的名称片段, 可以插入允许<code>XML</code>的任何位置. 两者都使用属性标签来定义值. 属性标签不能在<code>xacro:macro</code>中声明. 以下示例将显示如何声明和使用属性:</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">"the_radius"</span> <span class="attr">value</span>=<span class="string">"2.1"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">"the_length"</span> <span class="attr">value</span>=<span class="string">"4.5"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">geometry</span> <span class="attr">type</span>=<span class="string">"cylinder"</span> <span class="attr">radius</span>=<span class="string">"$&#123;the_radius&#125;"</span> <span class="attr">length</span>=<span class="string">"$&#123;the_length&#125;"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>通过将名称放在<code>dollared-braces</code> (<strong><code>${}</code></strong>)中, 你可以将两个属性值插入到几何表达式中. 如果你想要一个文本<code>&quot;{&quot;</code>, 你应该将其转义为<code>&quot;$${&quot;</code>.<br>下面是使用属性块的示例:</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">"front_left_origin"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">"0.3 0 0"</span> <span class="attr">rpy</span>=<span class="string">"0 0 0"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xacro:property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">pr2_wheel</span> <span class="attr">name</span>=<span class="string">"front_left_wheel"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">xacro:insert_block</span> <span class="attr">name</span>=<span class="string">"front_left_origin"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">pr2_wheel</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="数学表达式"><a class="header-anchor" href="#数学表达式">¶</a>数学表达式</h2><p>在<code>dollared-braces</code> (<strong><code>${}</code></strong>)中, 您还可以编写简单的数学表达式. 目前, 该结构支持基本算术和变量替换. 下面是一个例子:</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">"pi"</span> <span class="attr">value</span>=<span class="string">"3.1415926535897931"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">circle</span> <span class="attr">circumference</span>=<span class="string">"$&#123;2.5 * pi&#125;"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>在<code>Jade</code>版本的<code>ROS</code>中更新的地方:<br>自<code>ROS Jade</code>以来, <code>Xacro</code>使用<code>python</code>来评估包含在<code>dollared-braces</code> (<strong><code>${}</code></strong>)中的表达式. 这允许用户使用更复杂的算术表达式. 此外, 一些基本常数, 例如<code>pi</code>, 已经被预定义过了:</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">"R"</span> <span class="attr">value</span>=<span class="string">"2"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">"alpha"</span> <span class="attr">value</span>=<span class="string">"$&#123;30/180*pi&#125;"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">circle</span> <span class="attr">circumference</span>=<span class="string">"$&#123;2 * pi * R&#125;"</span> <span class="attr">pos</span>=<span class="string">"$&#123;sin(alpha)&#125; $&#123;cos(alpha)&#125;"</span> /&gt;</span></span><br></pre></td></tr></table></figure><h2 id="条件块"><a class="header-anchor" href="#条件块">¶</a>条件块</h2><p>在<code>Hydro</code>版本的<code>ROS</code>中更新的地方:<br>自从<code>ROS Hydro</code>以来, <code>Xacro</code>有类似于<code>roslaunch</code>的条件块. 这对于可配置的机器人或加载不同的<code>Gazebo</code>插件等事情很有用. 它遵循以下语法:</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xacro:if</span> <span class="attr">value</span>=<span class="string">"&lt;expression&gt;"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- &lt;... some xml code here ...&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xacro:if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">xacro:unless</span> <span class="attr">value</span>=<span class="string">"&lt;expression&gt;"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- &lt;... some xml code here ...&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xacro:unless</span>&gt;</span></span><br></pre></td></tr></table></figure><p>表达式需要计算结果为<code>&quot;0&quot;</code>, <code>&quot;1&quot;</code>, <code>&quot;true&quot;</code>或<code>&quot;false&quot;</code>, 否则将抛出错误.</p><p>在<code>Jade</code>版本的<code>ROS</code>中更新的地方:<br><code>ROS Jade</code>中更强大的评估功能允许使用更复杂的表达式. 几乎任何<code>python</code>表达式的计算结果都是可行的:</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">"var"</span> <span class="attr">value</span>=<span class="string">"useit"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">xacro:if</span> <span class="attr">value</span>=<span class="string">"$&#123;var == 'useit'&#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">xacro:if</span> <span class="attr">value</span>=<span class="string">"$&#123;var.startswith('use') and var.endswith('it')&#125;"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">"allowed"</span> <span class="attr">value</span>=<span class="string">"[1,2,3]"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">xacro:if</span> <span class="attr">value</span>=<span class="string">"$&#123;1 in allowed&#125;"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Rospack命令"><a class="header-anchor" href="#Rospack命令">¶</a><code>Rospack</code>命令</h2><p><code>Xacro</code>允许你使用某些<code>rospack</code>命令和<code>dollared-braces</code> (<strong><code>${}</code></strong>).</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">foo</span> <span class="attr">value</span>=<span class="string">"$(find xacro)"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">foo</span> <span class="attr">value</span>=<span class="string">"$(arg myvar)"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p><code>Xacro</code>目前支持使用<code>substitution args</code>的<code>roslaunch</code>支持的所有<code>rospack</code>命令. 参数需要在命令行中使用<code>myvar := true</code>语法指定.</p><p>在<code>Indigo</code>版本的<code>ROS</code>中更新的地方:<br>自从<code>ROS Indigo</code>, 它也可以像如下定义默认值:</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xacro:arg</span> <span class="attr">name</span>=<span class="string">"myvar"</span> <span class="attr">default</span>=<span class="string">"false"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>通过这种方式, 你可以像下面这样运行<code>xacro</code>:</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"robot_description"</span> <span class="attr">command</span>=<span class="string">"$(find xacro)/xacro.py $(arg model) myvar:=true"</span> /&gt;</span></span><br></pre></td></tr></table></figure><h2 id="宏命令"><a class="header-anchor" href="#宏命令">¶</a>宏命令</h2><p><code>xacro</code>的主要特性是它对宏的支持. 使用宏标签定义宏, 并指定宏名称和参数列表. 参数列表应以空格分隔. 它们变成<code>macro-local</code>属性.</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xacro:macro</span> <span class="attr">name</span>=<span class="string">"pr2_caster"</span> <span class="attr">params</span>=<span class="string">"suffix *origin **content **anothercontent"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">joint</span> <span class="attr">name</span>=<span class="string">"caster_$&#123;suffix&#125;_joint"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">axis</span> <span class="attr">xyz</span>=<span class="string">"0 0 1"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">joint</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">name</span>=<span class="string">"caster_$&#123;suffix&#125;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:insert_block</span> <span class="attr">name</span>=<span class="string">"origin"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:insert_block</span> <span class="attr">name</span>=<span class="string">"content"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:insert_block</span> <span class="attr">name</span>=<span class="string">"anothercontent"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xacro:macro</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">xacro:pr2_caster</span> <span class="attr">suffix</span>=<span class="string">"front_left"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">pose</span> <span class="attr">xyz</span>=<span class="string">"0 1 0"</span> <span class="attr">rpy</span>=<span class="string">"0 0 0"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">container</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">color</span> <span class="attr">name</span>=<span class="string">"yellow"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mass</span>&gt;</span>0.1<span class="tag">&lt;/<span class="name">mass</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">container</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">another</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">inertial</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">"0 0 0.5"</span> <span class="attr">rpy</span>=<span class="string">"0 0 0"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">mass</span> <span class="attr">value</span>=<span class="string">"1"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">inertia</span> <span class="attr">ixx</span>=<span class="string">"100"</span>  <span class="attr">ixy</span>=<span class="string">"0"</span>  <span class="attr">ixz</span>=<span class="string">"0"</span> <span class="attr">iyy</span>=<span class="string">"100"</span> <span class="attr">iyz</span>=<span class="string">"0"</span> <span class="attr">izz</span>=<span class="string">"100"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">inertial</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">another</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xacro:pr2_caster</span>&gt;</span></span><br></pre></td></tr></table></figure><p>该示例声明了一个宏<code>&quot;pr2_caster&quot;</code>, 它有两个参数: <code>suffix</code>和<code>origin</code>. <strong><em>请注意, &quot;origin&quot;已加星标. 这表明 origin 是一个块参数, 而不是一个简单的文本参数</em></strong>. 看下<code>pr2_caster</code>的使用. <code>suffix</code>属性(<code>property</code>)在<code>pr2_caster</code>标签中定义为属性(<code>attribute</code>), 但没有定义<code>origin</code>属性. 相反, <code>origin</code>指的是第一个元素(<code>&quot;pose&quot;</code>块). <strong><em>双星号版本(<code>&quot;content&quot;</code>, <code>&quot;anothercontent&quot;</code>)允许插入在随后可用的元素(在上面的示例中分别是<code>&quot;container&quot;</code>, <code>&quot;another&quot;</code>)中传递的任意数量的元素</em></strong>. 此示例扩展为以下内容:</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">joint</span> <span class="attr">name</span>=<span class="string">"caster_front_left_joint"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">axis</span> <span class="attr">xyz</span>=<span class="string">"0 0 1"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">joint</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">name</span>=<span class="string">"caster_front_left"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">pose</span> <span class="attr">xyz</span>=<span class="string">"0 1 0"</span> <span class="attr">rpy</span>=<span class="string">"0 0 0"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">color</span> <span class="attr">name</span>=<span class="string">"yellow"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mass</span>&gt;</span>0.1<span class="tag">&lt;/<span class="name">mass</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">inertial</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">"0 0 0.5"</span> <span class="attr">rpy</span>=<span class="string">"0 0 0"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mass</span> <span class="attr">value</span>=<span class="string">"1"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">inertia</span> <span class="attr">ixx</span>=<span class="string">"100"</span>  <span class="attr">ixy</span>=<span class="string">"0"</span>  <span class="attr">ixz</span>=<span class="string">"0"</span> <span class="attr">iyy</span>=<span class="string">"100"</span> <span class="attr">iyz</span>=<span class="string">"0"</span> <span class="attr">izz</span>=<span class="string">"100"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">inertial</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br></pre></td></tr></table></figure><p>多个块参数将按指定的顺序处理:</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xacro:macro</span> <span class="attr">name</span>=<span class="string">"reorder"</span> <span class="attr">params</span>=<span class="string">"*first *second"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">xacro:insert_block</span> <span class="attr">name</span>=<span class="string">"second"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">xacro:insert_block</span> <span class="attr">name</span>=<span class="string">"first"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xacro:macro</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">reorder</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">first</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">second</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">reorder</span>&gt;</span></span><br></pre></td></tr></table></figure><p>宏可能包含其他宏. 外部宏将首先展开, 然后内部宏将展开. 例如:</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">xacro:macro</span> <span class="attr">name</span>=<span class="string">"foo"</span> <span class="attr">params</span>=<span class="string">"x"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">in_foo</span> <span class="attr">the_x</span>=<span class="string">"$&#123;x&#125;"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">xacro:macro</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">xacro:macro</span> <span class="attr">name</span>=<span class="string">"bar"</span> <span class="attr">params</span>=<span class="string">"y"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">in_bar</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">xacro:foo</span> <span class="attr">x</span>=<span class="string">"$&#123;y&#125;"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">in_bar</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">xacro:macro</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">xacro:bar</span> <span class="attr">y</span>=<span class="string">"12"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>变成:</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">in_bar</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">in_foo</span> <span class="attr">the_x</span>=<span class="string">"12.0"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">in_bar</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="默认参数"><a class="header-anchor" href="#默认参数">¶</a>默认参数</h3><p><code>Indigo</code>中更新<br>宏参数可以有默认值:</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xacro:macro</span> <span class="attr">name</span>=<span class="string">"foo"</span> <span class="attr">params</span>=<span class="string">"x:=$&#123;x&#125; y:=$&#123;2*y&#125; z:=0"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>如果默认值包含评估表达式, 则将在实例化时评估它们.</p><p><code>Jade</code>中更新<br>通常, 您需要将外部变量传递到本地宏参数(如上面的<code>x</code>). 要简化此任务, 可以使用<code>^</code>语法:</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xacro:macro</span> <span class="attr">name</span>=<span class="string">"foo"</span> <span class="attr">params</span>=<span class="string">"p1 p2:=expr_a p3:=^ p4:=^|expr_b"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>插入符号<code>^</code>表示使用外部<code>scope</code>属性(具有相同名称). 管道<code>|</code>表示如果属性未在外部范围中定义, 则使用给定的回退.</p><h2 id="局部属性"><a class="header-anchor" href="#局部属性">¶</a>局部属性</h2><p><code>Jade</code>中更新<br>在宏中定义的属性和宏对于该宏来说是局部的, 即在外部不可见. 使用可选属性<code>scope =&quot;parent | global&quot;</code>, 属性定义可以导出到宏的父作用域(或全局作用域).</p><h2 id="包含其他xacro文件"><a class="header-anchor" href="#包含其他xacro文件">¶</a>包含其他<code>xacro</code>文件</h2><p>您可以使用<code>xacro: include</code>标签来包含其他<code>xacro</code>文件:</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xacro:include</span> <span class="attr">filename</span>=<span class="string">"$(find package)/other_file.xacro"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">xacro:include</span> <span class="attr">filename</span>=<span class="string">"other_file.xacro"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">xacro:include</span> <span class="attr">filename</span>=<span class="string">"$(cwd)/other_file.xacro"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>文件<code>&quot;other_file.xacro&quot;</code>将被<code>xacro</code>包含和扩展. <code>Jade</code>中的新功能: 相对文件名相对于当前处理的文件进行解释. <strong>注意: 当在宏中包含文件时, 包含处理不是宏定义, 而是宏调用文件</strong>! <code>$(cwd)</code>显式的允许访问当前工作目录中的文件.<br>为了避免各种包含文件的属性和宏之间的名称冲突, 可以为包含的文件指定命名空间 - 提供属性<code>ns</code>:</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xacro:include</span> <span class="attr">filename</span>=<span class="string">"other_file.xacro"</span> <span class="attr">ns</span>=<span class="string">"namespace"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>访问命名空间宏和属性是通过预先命名空间来实现的, 用点分隔:</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">$&#123;namespace.property&#125;</span><br></pre></td></tr></table></figure><h2 id="YAML语言支"><a class="header-anchor" href="#YAML语言支">¶</a><code>YAML</code>语言支</h2><p><code>Jade</code>中的新功能<br>属性可以是用<code>python</code>语法声明的字典或列表, 如下所示:</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">"props"</span> <span class="attr">value</span>=<span class="string">"$&#123;dict(a=1, b=2, c=3)&#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">"numbers"</span> <span class="attr">value</span>=<span class="string">"$&#123;[1,2,3,4]&#125;"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>或者从<code>YAML</code>文件中加载, 如下:</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">"props"</span> <span class="attr">value</span>=<span class="string">"$&#123;load_yaml('props.yaml')&#125;"</span>/</span></span><br></pre></td></tr></table></figure><p>注意, 通过<code>evaluation brackets ${}</code>区分评价和纯文本定义. 校准数据是从 YAML 加载的理想候选.</p><h2 id="用CMakeLists-txt进行构建"><a class="header-anchor" href="#用CMakeLists-txt进行构建">¶</a>用<code>CMakeLists.txt</code>进行构建</h2><p>以下代码段显示如何在程序包的申明期间使用<code>xacro</code>:</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Generate .world files from .world.xacro files</span></span><br><span class="line"><span class="keyword">find_package</span>(xacro REQUIRED)</span><br><span class="line"><span class="comment"># You can also add xacro to the list of catkin packages:</span></span><br><span class="line"><span class="comment">#   find_package(catkin REQUIRED COMPONENTS ... xacro)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Xacro files</span></span><br><span class="line"><span class="keyword">file</span>(GLOB xacro_files <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/worlds/*.world.xacro)</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span>(it <span class="variable">$&#123;xacro_files&#125;</span>)</span><br><span class="line">  <span class="comment"># remove .xacro extension</span></span><br><span class="line">  <span class="keyword">string</span>(REGEX MATCH <span class="string">"(.*)[.]xacro$"</span> unused <span class="variable">$&#123;it&#125;</span>)</span><br><span class="line">  <span class="keyword">set</span>(output_filename <span class="variable">$&#123;CMAKE_MATCH_1&#125;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># create a rule to generate $&#123;output_filename&#125; from &#123;it&#125;</span></span><br><span class="line">  xacro_add_xacro_file(<span class="variable">$&#123;it&#125;</span> <span class="variable">$&#123;output_filename&#125;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">list</span>(APPEND world_files <span class="variable">$&#123;output_filename&#125;</span>)</span><br><span class="line"><span class="keyword">endforeach</span>(it)</span><br><span class="line"></span><br><span class="line"><span class="comment"># add an abstract target to actually trigger the builds</span></span><br><span class="line"><span class="keyword">add_custom_target</span>(media_files ALL DEPENDS <span class="variable">$&#123;world_files&#125;</span>)</span><br></pre></td></tr></table></figure><p><code>Jade</code>中的新功能:<br>虽然这个<code>cmake</code>代码提供了对目标名称和构建顺序的完全控制, 但还有一个更简便的宏:</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">file</span>(GLOB xacro_files worlds/*.world.xacro)</span><br><span class="line">xacro_add_files(<span class="variable">$&#123;xacro_files&#125;</span> <span class="keyword">TARGET</span> media_files)</span><br></pre></td></tr></table></figure><h2 id="元素与属性"><a class="header-anchor" href="#元素与属性">¶</a>元素与属性</h2><p><code>Jade</code>中的新功能:<br>要使用动态定义的名称添加元素或属性, 可以使用特殊的<code>xacro</code>标签</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xacro:element</span> <span class="attr">xacro:name</span>=<span class="string">"$&#123;element_name&#125;"</span> [<span class="attr">other</span> <span class="attr">attributes</span>]&gt;</span></span><br><span class="line"> [content]</span><br><span class="line"><span class="tag">&lt;/<span class="name">xacro:element</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">xacro:attribute</span> <span class="attr">name</span>=<span class="string">"$&#123;attribute_name&#125;"</span> <span class="attr">value</span>=<span class="string">"$&#123;attribute_value&#125;"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h2 id="处理顺序"><a class="header-anchor" href="#处理顺序">¶</a>处理顺序</h2><p><code>Classicly Xacro</code>首先加载所有包含项, 然后处理所有属性和宏定义, 最后实例化宏并计算表达式. 因此, <strong>后期定义的属性或宏定义将覆盖先前的定义</strong>. 此外, 条件标签, <code>&lt;if&gt;</code>和<code>&lt;unless&gt;</code>, 对宏或属性定义以及包含的其他文件没有影响.</p><p><code>Jade</code>中的新功能:<br>自<code>ROS Jade</code>以来, <code>Xacro</code>提供了命令行选项<code>–-inorder</code>, 允许以读取的顺序来处理整个文档. 因此, 将使用属性或宏的最新定义. 这是一个更直观的评估过程, 提供了一些不错的新功能:</p><ul><li>如果<code>&lt;include&gt;</code>标签分别放置在宏内或条件标签中, 则可以推迟或完全禁止包含文件.</li><li>包含文件名可以通过属性或宏参数指定.</li><li>通过更改全局范围的属性, 如果在宏中使用这些属性, 则宏的实例化可以产生不同的结果.</li><li>属性定义可以是有条件的.</li><li>宏可以在局部范围内定义属性, 而不会影响外部.</li></ul><p>因为<code>–-inorder</code>处理更强大, 在未来<code>Jade</code>以后的版本, 新的处理风格将成为默认风格, 所以你应该检查你的<code>xacro</code>文件的兼容性. 通常, 两种加工方式应该给出相同的结果. 你可以很容易地像下面这样检查:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rosrun xacro xacro file.xacro &gt; /tmp/old.xml</span><br><span class="line">rosrun xacro xacro --inorder file.xacro &gt; /tmp/new.xml</span><br><span class="line">diff /tmp/old.xml /tmp/new.xml</span><br></pre></td></tr></table></figure><p>如果结果显示出任何差异, 你应检查并调整您的 xacro 文件. 常见的原因是校准数据后期加载了(作为属性). 在这种情况下, 只需将加载行为向前移动, 即在使用之前进行校准数据的加载. 为了方便搜索错误放置的属性定义, 可以使用选项<code>-–check--order</code>运行<code>xacro</code>. 如果任何有问题的属性, 它们将在<code>stderr</code>上列出:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Document is incompatible to --inorder processing.</span><br><span class="line">The following properties were redefined after usage:</span><br><span class="line">foo redefined <span class="keyword">in</span> issues.xacro</span><br></pre></td></tr></table></figure><p>使用命令行选项<code>-vv</code>或<code>-vvv</code>, 可以增加详细程度级别以记录属性的所有定义.</p><h2 id="已弃用的语法"><a class="header-anchor" href="#已弃用的语法">¶</a>已弃用的语法</h2><p><code>Jade</code>中的新功能:<br>虽然在以前的版本中, 没有命名空间前缀的<code>xacro</code>标签能够被接受并使用, 但是这种草率的语法是我们应当强烈反对的, 因为它阻止在最终的<code>XML</code>中使用这些标签. 从<code>Jade</code>开始, 这种语法已被弃用, 你应该相应地更新你的文件. 以下脚本将为您更新文件:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find . -iname <span class="string">"*.xacro"</span> | xargs sed -i <span class="string">'s#&lt;\([/]\?\)\(if\|unless\|include\|arg\|property\|macro\|insert_block\)#&lt;\1xacro:\2#g'</span></span><br></pre></td></tr></table></figure><hr><p>参考链接:</p><ul><li><a href="http://wiki.ros.org/xacro" target="_blank" rel="noopener">http://wiki.ros.org/xacro</a></li><li><a href="https://blog.csdn.net/chishuideyu/article/details/53695392" target="_blank" rel="noopener">https://blog.csdn.net/chishuideyu/article/details/53695392</a></li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>ROS学习</category>
      </categories>
      <tags>
        <tag>ROS</tag>
        <tag>xacro</tag>
      </tags>
  </entry>
  <entry>
    <title>ROS学习-roslaunch_xml</title>
    <url>/posts/73359715/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><!-- build time:Sat Nov 13 2021 15:45:21 GMT+0000 (Coordinated Universal Time) --><p>这个页面描述了用于<code>roslaunch</code>的<code>.launch</code>文件的<code>XML</code>格式. 有关<code>roslaunch</code>的背景、功能和相关工具, 请先访问<code>roslaunch</code>页面.</p><a id="more"></a><p><a href="#%e6%96%87%e4%bb%b6%e8%a7%a3%e6%9e%90%e9%a1%ba%e5%ba%8f">文件解析顺序</a><br><a href="#%e7%bd%ae%e6%8d%a2%e5%8f%82%e6%95%b0">置换参数</a></p><ul><li><a href="#env-environmentvariable">env ENVIRONMENT_VARIABLE</a></li><li><a href="#optenv-environmentvariable%e5%92%8coptenv-environmentvariable-defaultvalue">optenv ENVIRONMENT_VARIABLE / optenv ENVIRONMENT_VARIABLE default_value</a></li><li><a href="#find-pkg">find pkg</a></li><li><a href="#anon-name">anon name</a></li><li><a href="#arg-variblename">arg varible_name</a></li><li><a href="#eval-expression-new-in-kinetic">eval expression</a></li></ul><p><a href="#3-if-%e5%92%8c-unless-%e5%b1%9e%e6%80%a7">IF 和 UNLESS 属性</a></p><p><a href="#%e5%8f%82%e8%80%83%e6%a0%87%e7%ad%be">参考标签</a></p><ul><li><a href="#launch">launch</a></li><li><a href="#node">node</a></li><li><a href="#param">param</a></li><li><a href="#rosparam">rosparam</a></li><li><a href="#remap">remap</a></li><li><a href="#machine">machine</a></li><li><a href="#include">include</a></li><li><a href="#env">env</a></li><li><a href="#test">test</a></li><li><a href="#arg">arg</a></li><li><a href="#group">group</a></li></ul><p><a href="#launch%e6%96%87%e4%bb%b6%e7%9a%84%e4%be%8b%e5%ad%90">launch 文件的例子</a></p><ul><li><a href="#%e4%b8%80%e4%b8%aa%e7%ae%80%e5%8d%95%e7%9a%84%e4%be%8b%e5%ad%90">一个简单的例子</a></li><li><a href="#%e4%b8%80%e4%b8%aa%e5%a4%8d%e6%9d%82%e4%b8%80%e7%82%b9%e7%9a%84%e4%be%8b%e5%ad%90">一个复杂一点的例子</a></li><li><a href="#%e8%ae%be%e7%bd%ae%e5%8f%82%e6%95%b0">设置参数</a></li></ul><h2 id="文件解析顺序"><a class="header-anchor" href="#文件解析顺序">¶</a>文件解析顺序</h2><p><code>roslaunch</code> 以单程的方式解析 XML 格式文件, <code>include</code> 是以深度优先的方式解析内容, 而标签<code>Tag</code>以串行的方式处理, 所以一个参数的最后一次设置被认定为有效值. 也就是说在<code>. launch</code>文件中同样的设置可能存在多处, 比如在开头定义了一个变量, 遵循着尽量节省空间的想法, 在后面的定义中又对这个变量进行了重新赋值, 以便重新利用, 在这种情况下, 在整个<code>launch</code>文件解析完成后, 最终进行的那次设置是有效的, 但也并不保证一定有效, 不排除在其它的文件中对变量进行了重命名, 所以推荐使用<code>$(arg)/&lt;arg&gt;</code>的方式进行覆写.</p><h2 id="置换参数"><a class="header-anchor" href="#置换参数">¶</a>置换参数</h2><p><code>roslaunch</code>标签属性可以使用置换参数, <code>roslaunch</code>将在启动节点之前解析这些置换参数. 目前支持的置换参数是：</p><h3 id="env-ENVIRONMENT-VARIABLE"><a class="header-anchor" href="#env-ENVIRONMENT-VARIABLE">¶</a><code>$(env ENVIRONMENT_VARIABLE)</code></h3><p>其中的<code>$</code>是一个置换处理标志, 类似<code>shell</code>中的<code>$</code>. 从当前环境变量替换变量的值. 如果没有设置环境变量, 启动将失败. 该值不能被<code>&lt;env&gt;</code>标签覆盖. --就是说用环境变量<code>ENVIRONMENT_VARIABLE</code>设置的值来替换目标值. 例子：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"variable_name"</span> <span class="attr">value</span>=<span class="string">"$(env NUM_CPUS)"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p><code>param</code>是<code>launch</code>文件参数定义的标签, <code>name</code>属性表示定义的变量名称, <code>value</code>属性表示对定义变量进行赋值或替代. 类似于<code>variable_name=$(env NUM_CPUS)</code>. 如果没有设置环境变量<code>NUM_CPUS</code>, <code>roslaunch</code>启动时将报错.</p><h3 id="optenv-ENVIRONMENT-VARIABLE-和-optenv-ENVIRONMENT-VARIABLE-default-value"><a class="header-anchor" href="#optenv-ENVIRONMENT-VARIABLE-和-optenv-ENVIRONMENT-VARIABLE-default-value">¶</a><code>$(optenv ENVIRONMENT_VARIABLE)</code>和<code>$(optenv ENVIRONMENT_VARIABLE default_value)</code></h3><p>和上条的区别在于, <code>optenv</code>表示这是一个可选的环境变量(<code>optional environment</code>). 假如没有设置环境变量<code>ENVIRONMENT_VARIABLE</code>, 若提供了<code>default_value</code>值, 则, 则用<code>default_value</code>替代目标变量, 若没有提供该值, 则用空字符串表示(<code>roslaunch</code>启动时, 不会报错). <code>default_value</code>的值可以是包含被空格分隔的多字符.</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 若设置了环境变量 NUM_CPUS, 则 foo = $NUM_CPUS, 否则 foo = "1". 如果没有默认值 1, 那么 foo = "". --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"foo"</span> <span class="attr">value</span>=<span class="string">"$(optenv NUM_CPUS 1)"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 若设置了环境变量 CONFIG_PATH, 则 foo = $CONFIG_PATH, 否则 foo = "/home/marvin/ros_workspace". --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"foo"</span> <span class="attr">value</span>=<span class="string">"$(optenv CONFIG_PATH /home/marvin/ros_workspace)"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 若设置了环境变量 VARIABLE, 则 foo = $VARIABLE, 否则 foo = "ros rocks". 变量可以包含空格字符串. --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"foo"</span> <span class="attr">value</span>=<span class="string">"$(optenv VARIABLE ros rocks)"</span> /&gt;</span></span><br></pre></td></tr></table></figure><h3 id="find-pkg"><a class="header-anchor" href="#find-pkg">¶</a><code>$(find pkg)</code></h3><p>查找包路径. 例如<code>$(find rospy)/manifest.xml</code>指定包相对路径。包目录的完整文件路径将被内联替换。强烈建议使用包相对路径，因为硬编码路径会限制启动配置的可移植性。前斜杠和后斜杠将按惯例被解析为本地文件系统。</p><h3 id="anon-name"><a class="header-anchor" href="#anon-name">¶</a><code>$(anon name)</code></h3><p>产生基于名称的匿名 ID, 主要用于节点名称属性中创建匿名节点, 并检查是否有相同的匿名名字, 因为 ROS 中名字作为标识符要求具有唯一性. 其中的 anon 是 anonymous 的简写. 例如：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">"$(anon talk_01)"</span> <span class="attr">pkg</span>=<span class="string">"rospy_tutorials"</span> <span class="attr">type</span>=<span class="string">"talker.py"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">"$(anon talk_01)"</span> <span class="attr">pkg</span>=<span class="string">"rospy_tutorials"</span> <span class="attr">type</span>=<span class="string">"talker.py"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>则会产生错误, 因为系统检测到了两个节点具有相同的匿名名字.</p><h3 id="arg-varible-name"><a class="header-anchor" href="#arg-varible-name">¶</a><code>$(arg varible_name)</code></h3><p>解析由<code>&lt;arg&gt;</code>标签指定的变量值. 必须在声明<code>arg</code>的同一启动文件中有对应的<code>&lt;arg&gt;</code>标签。 例如：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"foo"</span> <span class="attr">value</span>=<span class="string">"$(arg my_foo)"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>将<code>my_foo</code>的值赋给参数<code>foo</code>. 这样在解析<code>my_foo</code>的值的时候才能正常进行. 就如同你在表达式中用一个变量进行计算, 你必须在计算之前就已经定义过这个变量才可以. 再如：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">"add_two_ints_server"</span> <span class="attr">pkg</span>=<span class="string">"beginner_tutorials"</span> <span class="attr">type</span>=<span class="string">"add_two_ints_server"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">"add_two_ints_client"</span> <span class="attr">pkg</span>=<span class="string">"beginner_tutorials"</span> <span class="attr">type</span>=<span class="string">"add_two_ints_client"</span> <span class="attr">args</span>=<span class="string">"$(arg a) $(arg b)"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>其中的<code>$(arg a)</code>和<code>$(arg b)</code>则是对节点所需要的变量进行声明, 这样你在对节点进行参数传递的时候就可以用以下代码进行：<br><code>roslaunch beginner_tutorials launch_file.launch a:=1 b:=5</code></p><h3 id="eval-expression-New-in-Kinetic"><a class="header-anchor" href="#eval-expression-New-in-Kinetic">¶</a><code>$(eval &lt;expression&gt;)</code> <strong>New in Kinetic</strong></h3><p>允许计算任意复杂的<code>python</code>表达式. 例如：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"circumference"</span> <span class="attr">value</span>=<span class="string">"$(eval 2. * 3. 1415 * arg('radius'))"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>会根据给定的<code>radius</code>进行计算后将结果赋给<code>circumference</code>. 作为限制, <code>$(eval)</code>的作用范围要跨越表示整个表达式的字符串, 如果在其中插入其它属性是不可行的. 例如：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"a_name"</span> <span class="attr">value</span>=<span class="string">"$(arg r_dis) $(eval 6*7) bar"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>是不可行的. 为了弥补这个限制，所有的替换命令都可以作为函数在 eval 中使用:</p><blockquote><p><code>&quot;$(eval arg('sth') + env('PATH') + 'bar' + find('pkg'))&quot;</code></p></blockquote><p>为了方便起见，参数也是隐式解析的，即以下两个表达式是相同的:</p><blockquote><p><code>&quot;$(eval arg('foo'))&quot;</code><br><code>&quot;$(eval foo)&quot;</code></p></blockquote><h2 id="IF-和-UNLESS-属性"><a class="header-anchor" href="#IF-和-UNLESS-属性">¶</a><code>IF</code> 和 <code>UNLESS</code> 属性</h2><p>所有的标签都支持<code>if</code>和<code>unless</code>属性, 此类属性是基于计算的值包含或是排除一个标签的内容.</p><blockquote><p><code>if = value (optional)</code><br>如果 value 的值为真则包含标签及内容.</p><p><code>unless = value (optional)</code><br>如果值为假, 则包括此内容.</p></blockquote><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">group</span> <span class="attr">if</span>=<span class="string">"$(arg foo)"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- stuff that will only be evaluated if foo is true --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">group</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"foo"</span> <span class="attr">value</span>=<span class="string">"bar"</span> <span class="attr">unless</span>=<span class="string">"$(arg foo)"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- This param won't be set when "unless" condition is met --&gt;</span></span><br></pre></td></tr></table></figure><h2 id="参考标签"><a class="header-anchor" href="#参考标签">¶</a>参考标签</h2><h3 id="launch"><a class="header-anchor" href="#launch">¶</a><code>&lt;launch&gt;</code></h3><blockquote><p><code>&lt;launch&gt;</code>标签为所有 roslaunch 文件的根标签, 可以将其理解为所有其它标签的容器. 以下为<code>&lt;launch&gt;</code>标签与其它标签的关系：</p></blockquote><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">remap</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">machine</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rosparam</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">env</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">test</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">arg</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">group</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="node"><a class="header-anchor" href="#node">¶</a><code>&lt;node&gt;</code></h3><p>用来启动节点, 但不保证节点的启动顺序.</p><h4 id="属性"><a class="header-anchor" href="#属性">¶</a>属性</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">pkg="mypackage"</span><br><span class="line"><span class="comment">&lt;!--指定所用的包--&gt;</span></span><br><span class="line"></span><br><span class="line">type="nodetype"</span><br><span class="line"><span class="comment">&lt;!--指定对应的可执行程序的名字--&gt;</span></span><br><span class="line"></span><br><span class="line">name="nodename"</span><br><span class="line"><span class="comment">&lt;!--指定节点名称, 但不能在这里加入命名空间名称--&gt;</span></span><br><span class="line"></span><br><span class="line">args="arg1 arg2 arg3"</span><br><span class="line"><span class="comment">&lt;!--声明或传递参数(optional)--&gt;</span></span><br><span class="line"></span><br><span class="line">machine="machine-name"</span><br><span class="line"><span class="comment">&lt;!--在指定的机器上启动节点(optional)--&gt;</span></span><br><span class="line"></span><br><span class="line">respawn="true"</span><br><span class="line"><span class="comment">&lt;!--如果节点失败则重新启动(optional)--&gt;</span></span><br><span class="line"></span><br><span class="line">respawn_delay="30"</span><br><span class="line"><span class="comment">&lt;!--如果上rospawn属性为真, 则等待一定的时间之后重新启动节点(optional, New in indigo)--&gt;</span></span><br><span class="line"></span><br><span class="line">required="true"</span><br><span class="line"><span class="comment">&lt;!--将节点定义为必需节点, 如果本节点失效, 则关闭整个文件(optional)--&gt;</span></span><br><span class="line"></span><br><span class="line">ns="nnss"</span><br><span class="line"><span class="comment">&lt;!--在一个命名空间中启动节点(optional)--&gt;</span></span><br><span class="line"></span><br><span class="line">clear_params="true|false"</span><br><span class="line"><span class="comment">&lt;!--在节点启动之前是否清空所在命名空间中的变量(optional)--&gt;</span></span><br><span class="line"></span><br><span class="line">output="log|screen"</span><br><span class="line"><span class="comment">&lt;!--指定输出的对象(optional)--&gt;</span></span><br><span class="line"></span><br><span class="line">cwd="ROS_HOME|node"</span><br><span class="line"><span class="comment">&lt;!--指定node则节点工作路径与其可执行程序路径相同(optional)--&gt;</span></span><br><span class="line"></span><br><span class="line">launch-prefix="prefix arguments"</span><br><span class="line"><span class="comment">&lt;!--预先处理指令或参数(optional, 支持多种工具)--&gt;</span></span><br></pre></td></tr></table></figure><h4 id="元素"><a class="header-anchor" href="#元素">¶</a>元素</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">node</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">env</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">remap</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rosparam</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">node</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="param"><a class="header-anchor" href="#param">¶</a><code>&lt;param&gt;</code></h3><p>用于在参数服务器中定义参数. 其属性参数如下所示：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">name="namespace/name"</span><br><span class="line"><span class="comment">&lt;!-- 参数名称. 在这个名称定义中是可以使用命名空间的, 而在node的名称定义中不能使用命名空间, 这个是有区别的. 但是应该避免指定全局的名称.  --&gt;</span></span><br><span class="line"></span><br><span class="line">value="value"</span><br><span class="line"><span class="comment">&lt;!-- 定义参数的值, 如果这一属性忽略掉了, 但必须指定 binfile, textfile or command.  --&gt;</span></span><br><span class="line"></span><br><span class="line">type="str|int|double|bool|yaml"</span><br><span class="line"><span class="comment">&lt;!-- 指定参数的类型(optional), 如果不指定则会自动识别类型, 规则如下：</span></span><br><span class="line"><span class="comment">1. 有“. ”的认为是浮点数, 没有的则认为是整型.</span></span><br><span class="line"><span class="comment">2. ”true” 和 “false” 被认为是逻辑变量 (not case-sensitive).</span></span><br><span class="line"><span class="comment">3. 其它的所有都为string型.  --&gt;</span></span><br><span class="line"></span><br><span class="line">textfile="$(find pkg-name)/path/file.txt"</span><br><span class="line"><span class="comment">&lt;!-- 文件的内容被存储为string类型用以替代目标变量(optional). 该文件必须是本地可访问的, 但是强烈建议使用包相对路径$(find)/file.txt的语法来指定位置。  --&gt;</span></span><br><span class="line"></span><br><span class="line">binfile="$(find pkg-name)/path/file"</span><br><span class="line"><span class="comment">&lt;!-- 内容将被存储为 base64-encoded XML-RPC 二进制对象用以替代目标变量(optional). 同上建议相对路径指定位置 --&gt;</span></span><br><span class="line"></span><br><span class="line">command="$(find pkg-name)/exe '$(find pkg-name)/arg. txt'"(optional)</span><br><span class="line"><span class="comment">&lt;!-- 执行某项命令, 命令的输出将被存储为一个string类型以替代目标变量. 文件的路径变量需要用单引号包括.  --&gt;</span></span><br></pre></td></tr></table></figure><h4 id="例子"><a class="header-anchor" href="#例子">¶</a>例子</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在参数服务器中定义名称为：publish_frequency, 类型为：double, 值为：10.0 的变量.  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"publish_frequency"</span> <span class="attr">type</span>=<span class="string">"double"</span> <span class="attr">value</span>=<span class="string">"10.0"</span> /&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 如果是加载 YAML 文件可以用以下代码，其中的 file 属性要指定路径和文件名.  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">rosparam</span> <span class="attr">command</span>=<span class="string">"load"</span> <span class="attr">file</span>=<span class="string">"FILENAME"</span> /&gt;</span></span><br></pre></td></tr></table></figure><h3 id="rosparam"><a class="header-anchor" href="#rosparam">¶</a><code>&lt;rosparam&gt;</code></h3><p>支持从<code>YAML</code>文件读取与卸载参数.</p><h4 id="属性-v2"><a class="header-anchor" href="#属性-v2">¶</a>属性</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- rosparam的命令, 可以指定 加载|卸载|删除 对应的参数.  --&gt;</span></span><br><span class="line">command="load|dump|delete" (optional, default=load)</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 指定文件所要求的路径.  --&gt;</span></span><br><span class="line">file="$(find pkg-name)/path/my. yaml" (load or dump commands)</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 参数名称 --&gt;</span></span><br><span class="line">param="param-name"</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 设定参数给指定的命名空间（设定参数的作用域） --&gt;</span></span><br><span class="line">ns="namespace" (optional)</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 是否运允许使用YAML文件中置换参数 --&gt;</span></span><br><span class="line">subst_value=true|false (optional)</span><br></pre></td></tr></table></figure><h4 id="例子-v2"><a class="header-anchor" href="#例子-v2">¶</a>例子</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 加载.yaml文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">rosparam</span> <span class="attr">command</span>=<span class="string">"load"</span> <span class="attr">file</span>=<span class="string">"$(find rosparam)/example.yaml"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 卸载.yaml文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">rosparam</span> <span class="attr">command</span>=<span class="string">"delete"</span> <span class="attr">param</span>=<span class="string">"my/param"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 定义一个变量 a_list, 而变量的值即为标签之间的所有内容, 即 a_list = [1, 2, 3, 4, 5] --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">rosparam</span> <span class="attr">param</span>=<span class="string">"a_list"</span>&gt;</span>[1, 2, 3, 4]<span class="tag">&lt;/<span class="name">rosparam</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">rosparam</span>&gt;</span></span><br><span class="line">  a: 1</span><br><span class="line">  b: 2</span><br><span class="line"><span class="tag">&lt;/<span class="name">rosparam</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 参数置换允许您使用 roslaunch args 来表示一个 YAML 字符串的全部或部分 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 如果subst_value为false, 表示不允许使用替代标签, 则输出的blacklist只是一个字符串$(arg whitelist); 但如果为true则表示允许使用替代标签, 则blacklist输出的值为[3, 2].  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">"whitelist"</span> <span class="attr">default</span>=<span class="string">"[3, 2]"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">rosparam</span> <span class="attr">param</span>=<span class="string">"whitelist"</span> <span class="attr">subst_value</span>=<span class="string">"True"</span>&gt;</span>$(arg whitelist)<span class="tag">&lt;/<span class="name">rosparam</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 它们对于在yaml字符串中嵌入$(find…)和其他替换模式也很有用。 --&gt;</span></span><br></pre></td></tr></table></figure><h3 id="remap"><a class="header-anchor" href="#remap">¶</a><code>&lt;remap&gt;</code></h3><p>用来通过名称进行参数之间的映射. 其属性如下：</p><h4 id="属性-v3"><a class="header-anchor" href="#属性-v3">¶</a>属性</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">from="original-name"</span><br><span class="line"><span class="comment">&lt;!-- 指定节点原来要监听的话题的名称.  --&gt;</span></span><br><span class="line"></span><br><span class="line">to="new-name"</span><br><span class="line"><span class="comment">&lt;!-- 指定节点实际要监听的话题的名称.  --&gt;</span></span><br></pre></td></tr></table></figure><h4 id="例子-v3"><a class="header-anchor" href="#例子-v3">¶</a>例子</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">remap</span> <span class="attr">from</span>=<span class="string">"chatter"</span> <span class="attr">to</span>=<span class="string">"hello"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 此行代码表明要将原来应监听chatter话题的节点改到监听hello话题.  --&gt;</span></span><br></pre></td></tr></table></figure><h3 id="machine"><a class="header-anchor" href="#machine">¶</a><code>&lt;machine&gt;</code></h3><p><code>&lt;machine&gt;</code>标签声明一台可以运行<code>ROS</code>节点的机器。如果在本地启动所有节点，则不需要此标签。它主要用于声明远程机器的<code>SSH</code>和<code>ROS</code>环境变量设置，不过您也可以使用它来声明关于本地机器的信息。</p><h4 id="属性-v4"><a class="header-anchor" href="#属性-v4">¶</a>属性</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">name="machine-name"</span><br><span class="line"><span class="comment">&lt;!-- 要分配给机器的名称。这对应于&lt;node&gt;标记的machine属性的名称。 --&gt;</span></span><br><span class="line"></span><br><span class="line">address="blah.willowgarage.com"</span><br><span class="line"><span class="comment">&lt;!-- 机器的远程地址或主机名 --&gt;</span></span><br><span class="line"></span><br><span class="line">env-loader="/opt/ros/fuerte/env.sh"</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- New in Fuerte. 指定远程计算机上的环境文件。环境文件必须是一个设置了所有需要环境变量的shell脚本，并提供参数执行exec --&gt;</span></span><br><span class="line"></span><br><span class="line">default="true|false|never" (optional)</span><br><span class="line"><span class="comment">&lt;!-- 将此机器设置为节点的默认分配机器。默认设置只适用于后续在同一范围内定义的节点。注意:如果没有默认机器，则使用本地机器。可以通过设置default="never"来阻止机器被选中，在这种情况下，只能显式地分配机器。 --&gt;</span></span><br><span class="line"></span><br><span class="line">user="username" (optional)</span><br><span class="line"><span class="comment">&lt;!-- 登录机器的ssh用户名, 如果不需要可以忽略 --&gt;</span></span><br><span class="line"></span><br><span class="line">password="passwhat"(strongly discouraged)</span><br><span class="line"><span class="comment">&lt;!-- ssh登录密码。强烈建议您配置SSH密钥和SSH代理，这样您就可以使用证书登录了 --&gt;</span></span><br><span class="line"></span><br><span class="line">timeout="10.0" (optional)</span><br><span class="line"><span class="comment">&lt;!-- 登录超时检测时间，默认设置为10秒。虽然您可以使用此设置来允许较慢的连接，但需要更改此参数通常是您的整个ROS图将出现通信问题的症状（While you can use this setting to allow for slower connections, needing to change this parameter is generally a symptom that your overall ROS graph will have communication issues.） --&gt;</span></span><br></pre></td></tr></table></figure><h4 id="例子-v4"><a class="header-anchor" href="#例子-v4">¶</a>例子</h4><p>下面的示例显示如何配置节点“footalker”来运行另一台机器。它使用 Fuerte 附带的默认的 env-loader 文件。注：<strong><code>Basic (ROS Fuerte and later) using env-loader</code></strong></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">machine</span> <span class="attr">name</span>=<span class="string">"foo"</span> <span class="attr">address</span>=<span class="string">"foo-address"</span> <span class="attr">env-loader</span>=<span class="string">"/opt/ros/fuerte/env.sh"</span> <span class="attr">user</span>=<span class="string">"someone"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">machine</span>=<span class="string">"foo"</span> <span class="attr">name</span>=<span class="string">"footalker"</span> <span class="attr">pkg</span>=<span class="string">"test_ros"</span> <span class="attr">type</span>=<span class="string">"talker.py"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure><p>下面是一个 ev -loader 脚本示例。如果你想使用不同的环境配置, 将/opt/ros/fuerte/setup.sh 替换为另外的安装文件：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line">./opt/ros/fuerte/setup.sh</span><br><span class="line"><span class="built_in">exec</span> <span class="string">"<span class="variable">$@</span>"</span></span><br></pre></td></tr></table></figure><p>此外，如果要从<code>rosws</code>工作空间中加载源：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> /home/username/path/to/workspace/setup.bash</span><br><span class="line"><span class="built_in">exec</span> <span class="string">"<span class="variable">$@</span>"</span></span><br></pre></td></tr></table></figure><h3 id="include"><a class="header-anchor" href="#include">¶</a><code>&lt;include&gt;</code></h3><p><code>&lt;include&gt;</code>标记允许您将另一个<code>roslaunch XML</code>文件导入当前文件。它将被导入到当前的文档范围，包括<code>&lt;group&gt;</code>和<code>&lt;remap&gt;</code>标签。除了<code>&lt;master&gt;</code>标记外，<code>include</code>文件中的所有内容都将被导入。<code>&lt;master&gt;</code>标签仅在顶级文件中被遵守。</p><h4 id="属性-v5"><a class="header-anchor" href="#属性-v5">¶</a>属性</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">file="$(find pkg-name)/path/filename.xml"</span><br><span class="line"><span class="comment">&lt;!-- 指定要包含的文件路径.  --&gt;</span></span><br><span class="line"></span><br><span class="line">ns="namespace_name" (optional)</span><br><span class="line"><span class="comment">&lt;!-- 指定要导入文件的命名空间.  --&gt;</span></span><br><span class="line"></span><br><span class="line">clear_params="true|false" (optional Default: false)</span><br><span class="line"><span class="comment">&lt;!-- 在文件加载之前删除&lt;include&gt;的命名空间中的所有参数, 缺省为false, 此参数要谨慎使用, 用之前要核对好命名空间名称.  --&gt;</span></span><br><span class="line"></span><br><span class="line">pass_all_args="true|false" (optional Default: false)</span><br><span class="line"><span class="comment">&lt;!-- 如果为true，所有当前上下文的args将被加入到在处理&lt;include&gt;文件时创建的子上下文中.  --&gt;</span></span><br></pre></td></tr></table></figure><h4 id="元素-v2"><a class="header-anchor" href="#元素-v2">¶</a>元素</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">include</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">env</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="env"><a class="header-anchor" href="#env">¶</a><code>&lt;env&gt;</code></h3><p>此标签用来设置将要启动的节点的环境变量, 其可以在<code>&lt;launch&gt;</code>, <code>&lt;include&gt;</code>, <code>&lt;node&gt;</code>和<code>&lt;machine&gt;</code>标签中使用. 当在<code>&lt;launch&gt;</code>中使用时, <code>&lt;env&gt;</code>标签作用于其后声明的所有节点. 但是用此标签声明的环境变量对于<code>$(env …)</code>不可见, 所以并不能用<code>$(env …)</code>对其它变量的值进行置换, 所以<code>&lt;env&gt;</code>标签不能用来参数化 launch 文件.</p><h4 id="属性-v6"><a class="header-anchor" href="#属性-v6">¶</a>属性</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">name="environment-variable-name"</span><br><span class="line"><span class="comment">&lt;!-- 此属性用来设置环境变量名称.  --&gt;</span></span><br><span class="line"></span><br><span class="line">value="environment-variable-value"</span><br><span class="line"><span class="comment">&lt;!-- 此属性用来设置环境变量值.  --&gt;</span></span><br></pre></td></tr></table></figure><h3 id="test"><a class="header-anchor" href="#test">¶</a><code>&lt;test&gt;</code></h3><p><code>&lt;test&gt;</code>标签在语法上类似于<code>&lt;node&gt;</code>标签, 都是指定一个<code>ROS</code>节点运行, 但是<code>&lt;test&gt;</code>标签表明当前要运行的节点是一个测试节点.</p><p><code>&lt;test&gt;</code>与<code>&lt;node&gt;</code>具有大部分相同的属性, 但以下内容是不同的：</p><ul><li>没有 respawn 属性 (测试节点必须要被终止, 所以它们没有重启属性)</li><li>没有输出属性, 因为测试节点有其输出记录机制.</li><li>Machine 属性被忽略.</li></ul><h4 id="属性-v7"><a class="header-anchor" href="#属性-v7">¶</a>属性</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">pkg="mypackage"</span><br><span class="line"><span class="comment">&lt;!-- 这一属性是必需的属性, 指定节点的包名称.  --&gt;</span></span><br><span class="line"></span><br><span class="line">test-name="test_name"</span><br><span class="line"><span class="comment">&lt;!-- 必须的属性, 指定测试节点的名称.  --&gt;</span></span><br><span class="line"></span><br><span class="line">type="nodetype"</span><br><span class="line"><span class="comment">&lt;!-- 必须的属性, 指定测试节点所对应的可执行程序名称.  --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 标签可选择的属性如下： --&gt;</span></span><br><span class="line">name="nodename"</span><br><span class="line"><span class="comment">&lt;!-- 节点名称. PS:名称中不能包含命名空间, 如果要指定要使用ns属性, 如果此属性未指定, 则test-name将被作为节点名称.  --&gt;</span></span><br><span class="line"></span><br><span class="line">args="arg1 arg2 arg3"</span><br><span class="line"><span class="comment">&lt;!-- 用测试节点传递参数.  --&gt;</span></span><br><span class="line"></span><br><span class="line">clear_params="true|false"</span><br><span class="line"><span class="comment">&lt;!-- 如果是true, 则在启动之前清空当前节点私有命名空间中的全部参数.  --&gt;</span></span><br><span class="line"></span><br><span class="line">cwd="ROS_HOME|node"</span><br><span class="line"><span class="comment">&lt;!-- 指定工作路径. 如果是node则节点的工作目录与节点的可执行程序目录相同.  --&gt;</span></span><br><span class="line"></span><br><span class="line">launch-prefix="prefix arguments"</span><br><span class="line"><span class="comment">&lt;!-- 节点启动之前的预置参数或命令.  --&gt;</span></span><br><span class="line"></span><br><span class="line">ns="namespace_name"</span><br><span class="line"><span class="comment">&lt;!-- 在指定的命名空间中启动节点.  --&gt;</span></span><br><span class="line"></span><br><span class="line">retry="0"</span><br><span class="line"><span class="comment">&lt;!-- 用于有时可能失效的随机过程, 设置重新尝试的次数.  --&gt;</span></span><br><span class="line"></span><br><span class="line">time-limit="60. 0"</span><br><span class="line"><span class="comment">&lt;!-- 认定节点启动失败之前要经历的时间, 缺省为60s.  --&gt;</span></span><br></pre></td></tr></table></figure><h4 id="例子-v5"><a class="header-anchor" href="#例子-v5">¶</a>例子</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">test</span> <span class="attr">test-name</span>=<span class="string">"test"</span> <span class="attr">pkg</span>=<span class="string">"mypkg"</span> <span class="attr">type</span>=<span class="string">"test. py"</span> <span class="attr">time-limit</span>=<span class="string">"10. 0"</span> <span class="attr">args</span>=<span class="string">"--test1 --test2"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 上行代码指定要测试的节点的名称, 包名称, 可执行程序名称, 测试时间跨度和要传递的参数 --&gt;</span></span><br></pre></td></tr></table></figure><h4 id="元素-v3"><a class="header-anchor" href="#元素-v3">¶</a>元素</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">test</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">env</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">remap</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rosparam</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">test</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="arg"><a class="header-anchor" href="#arg">¶</a><code>&lt;arg&gt;</code></h3><p><code>&lt;arg&gt;</code>标签允许通过命令行、<code>&lt;include&gt;</code>标签或者更上层的文件传递指定的值，用来创建可以重用或者可配置的的<code>launch</code>文件. 但<code>&lt;arg&gt;</code>标签是非全局的, 一个声明只针对一个<code>launch</code>文件, 如同局部变量一样。如果要在一个包含文件<code>include file</code>中使用, 则必须要显式的值传递.</p><p><code>&lt;arg&gt;</code>可以通过以下三种方式使用:</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">"foo"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 声明了一个foo变量。foo必须通过命令行传递或通过&lt;include&gt;标签进行传递.  --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">"foo"</span> <span class="attr">default</span>=<span class="string">"1"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 声明变量foo, 并赋予一个缺省值1. foo可以通过命令行覆写或&lt;include&gt;标签进行值传递使用.  --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">"foo"</span> <span class="attr">value</span>=<span class="string">"bar"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 声明了一个值为bar的常量foo。foo的值不能被覆写。此用法支持启动文件的内部参数化，而无需在更高级别暴露该参数。 --&gt;</span></span><br></pre></td></tr></table></figure><h4 id="属性-v8"><a class="header-anchor" href="#属性-v8">¶</a>属性</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">name="arg_name"</span><br><span class="line"><span class="comment">&lt;!-- 指定变量名.  --&gt;</span></span><br><span class="line"></span><br><span class="line">default="default value" (optional)</span><br><span class="line"><span class="comment">&lt;!-- 指定变量缺省值, 不能与value属性一起使用.  --&gt;</span></span><br><span class="line"></span><br><span class="line">value="value" (optional)</span><br><span class="line"><span class="comment">&lt;!-- 指定变量值, 不能与default属性一起使用.  --&gt;</span></span><br><span class="line"></span><br><span class="line">doc="description for this arg" (optional) New in Indigo</span><br><span class="line"><span class="comment">&lt;!-- 变量描述.  --&gt;</span></span><br></pre></td></tr></table></figure><h4 id="例子-v6"><a class="header-anchor" href="#例子-v6">¶</a>例子</h4><ul><li>传递一个参数到包含文件中</li></ul><p><code>my_file.launch</code>:</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">include</span> <span class="attr">file</span>=<span class="string">"included.launch"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- all vars that included.launch requires must be set --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">"hoge"</span> <span class="attr">value</span>=<span class="string">"fuga"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>included.launch</code>:</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- declare arg to be passed in --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">"hoge"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- read value of arg --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"param"</span> <span class="attr">value</span>=<span class="string">"$(arg hoge)"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure><p>则当运行<code>my_file.launch</code>文件时, <code>hoge</code>参数会从<code>my_file.launch</code>的<code>&lt;include&gt;</code>标签中传递进入<code>included.launch</code>文件中, 产生一个变量名为<code>param</code>, 值为<code>fuga</code>的变量. 但是由于<code>&lt;arg&gt;</code>定义的为一个文件内部的局部变量(类似于类内的私有变量), 无法从更高一级或外部进行访问, 即不能通过命令行进行赋值, 所以, 当运行：</p><blockquote><p><code>roslaunch %YOUR_ROS_PKG% my_file.launch hoge:=my_value</code></p></blockquote><p>时, <code>hoge</code>的值还是原来设定的<code>fuga</code>值, 而不管你在局部的<code>&lt;arg&gt;</code>属性中是用<code>value</code>属性还是<code>default</code>属性. 如果想用自己的定义值在命令行中进行覆盖, 则<code>&lt;arg&gt;</code>标签要使用更高一层级的<code>default</code>属性指定<code>my_file.launch</code>如下所示：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 即定义一个更高一层次的&lt;arg&gt;标签来执行值传递, 从更高一层级传递到局部再传递到included.launch文件中.  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">"temp"</span>  <span class="attr">default</span>=<span class="string">"fuga"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">file</span>=<span class="string">"$(find your_pkg)/launch/included.launch"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">"param"</span> <span class="attr">value</span>=<span class="string">"$(arg temp)"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>通过命令行传递变量<br><code>roslaunch</code>使用与<code>ROS</code>映射参数相同的语法来指定<code>arg</code>值</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ roslaunch my_file.launch hoge:=my_value  (.launch file is available at the current dir)</span><br><span class="line"></span><br><span class="line">$ roslaunch %YOUR_ROS_PKG% my_file.launch hoge:=my_value</span><br></pre></td></tr></table></figure><h3 id="group"><a class="header-anchor" href="#group">¶</a><code>&lt;group&gt;</code></h3><p>可以对一组节点进行设置, 并且可以通过 ns 属性将一组节点放到一个隔离开的命名空间中.</p><h4 id="属性-v9"><a class="header-anchor" href="#属性-v9">¶</a>属性</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">ns="namespace" (optional)</span><br><span class="line"><span class="comment">&lt;!-- 将一组节点指定到一个特定的命名空间中, 命名空间可以是全局的或是局部的, 但并有推荐使用全局的命名空间.  --&gt;</span></span><br><span class="line"></span><br><span class="line">clear_params="true|false" (optional)</span><br><span class="line">在节点启动之前清空<span class="tag">&lt;<span class="name">group</span>&gt;</span>命名空间中的所有参数, 谨慎使用.</span><br><span class="line"><span class="comment">&lt;!-- 内部可使用的标签如下所示： --&gt;</span></span><br></pre></td></tr></table></figure><h4 id="元素-v4"><a class="header-anchor" href="#元素-v4">¶</a>元素</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">group</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">remap</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">machine</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rosparam</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">env</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">test</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">group</span>/&gt;</span></span><br></pre></td></tr></table></figure><h2 id="launch-文件的例子"><a class="header-anchor" href="#launch-文件的例子">¶</a>launch 文件的例子</h2><h3 id="一个简单的例子"><a class="header-anchor" href="#一个简单的例子">¶</a>一个简单的例子</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">"talker"</span> <span class="attr">pkg</span>=<span class="string">"rospy_tutorials"</span> <span class="attr">type</span>=<span class="string">"talker"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 在本地使用当前ros环境启动rospy_tutorials包中的可执行程序为talker的节点, 节点名称定义为talker.  --&gt;</span></span><br></pre></td></tr></table></figure><h3 id="一个复杂一点的例子"><a class="header-anchor" href="#一个复杂一点的例子">¶</a>一个复杂一点的例子</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">machine</span> <span class="attr">name</span>=<span class="string">"local_alt"</span> <span class="attr">address</span>=<span class="string">"localhost"</span> <span class="attr">default</span>=<span class="string">"true"</span> <span class="attr">ros-root</span>=<span class="string">"/u/user/ros/ros/"</span> <span class="attr">ros-package-path</span>=<span class="string">"/u/user/ros/ros-pkg"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 本地的机器已经进行了缺省定义, 这个标签的作用是用指定的ROS_ROOT和ROS_PACKAGE_PATH值对其重新赋值--&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">"listener-1"</span> <span class="attr">pkg</span>=<span class="string">"rospy_tutorials"</span> <span class="attr">type</span>=<span class="string">"listener"</span> /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 启动一个收听节点 --&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">"listener-2"</span> <span class="attr">pkg</span>=<span class="string">"rospy_tutorials"</span> <span class="attr">type</span>=<span class="string">"listener"</span> <span class="attr">args</span>=<span class="string">"-foo arg2"</span> /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 向监听节点中传递参数 --&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">"listener-3"</span> <span class="attr">pkg</span>=<span class="string">"rospy_tutorials"</span> <span class="attr">type</span>=<span class="string">"listener"</span> <span class="attr">respawn</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 一个可以重新启动的节点 --&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">ns</span>=<span class="string">"wg1"</span> <span class="attr">name</span>=<span class="string">"listener-wg1"</span> <span class="attr">pkg</span>=<span class="string">"rospy_tutorials"</span> <span class="attr">type</span>=<span class="string">"listener"</span> <span class="attr">respawn</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 在 'wg1' 命名空间中启动一个节点 --&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">group</span> <span class="attr">ns</span>=<span class="string">"wg2"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 在 'wg2' 命名空间中启动一组节点 --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">remap</span> <span class="attr">from</span>=<span class="string">"chatter"</span> <span class="attr">to</span>=<span class="string">"hello"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- remap在group范围内作用于在其后声明的所有节点 --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">"rospy_tutorials"</span> <span class="attr">type</span>=<span class="string">"listener"</span> <span class="attr">name</span>=<span class="string">"listener"</span> <span class="attr">args</span>=<span class="string">"--test"</span> <span class="attr">respawn</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">"rospy_tutorials"</span> <span class="attr">type</span>=<span class="string">"talker"</span> <span class="attr">name</span>=<span class="string">"talker"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"talker_1_param"</span> <span class="attr">value</span>=<span class="string">"a value"</span> /&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 设置局部变量 --&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">remap</span> <span class="attr">from</span>=<span class="string">"chatter"</span> <span class="attr">to</span>=<span class="string">"hello-1"</span>/&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 节点可以有其自己私有的remap指令 --&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">env</span> <span class="attr">name</span>=<span class="string">"ENV_EXAMPLE"</span> <span class="attr">value</span>=<span class="string">"some value"</span> /&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 为节点设置环境变量 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">node</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">group</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="设置参数"><a class="header-anchor" href="#设置参数">¶</a>设置参数</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"somestring1"</span> <span class="attr">value</span>=<span class="string">"bar"</span> /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 值类型为string类型 --&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"somestring2"</span> <span class="attr">value</span>=<span class="string">"10"</span> <span class="attr">type</span>=<span class="string">"str"</span> /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 强制使用string类型而不是整型定义参数 --&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"someinteger1"</span> <span class="attr">value</span>=<span class="string">"1"</span> <span class="attr">type</span>=<span class="string">"int"</span> /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 指定为整型 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"someinteger2"</span> <span class="attr">value</span>=<span class="string">"2"</span> /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 自动识别为整型 --&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"somefloat1"</span> <span class="attr">value</span>=<span class="string">"3. 14159"</span> <span class="attr">type</span>=<span class="string">"double"</span> /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 指定为浮点型数据 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"somefloat2"</span> <span class="attr">value</span>=<span class="string">"3. 0"</span> /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 自动识别为浮点型数据 --&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"wg/childparam"</span> <span class="attr">value</span>=<span class="string">"a child namespace parameter"</span> /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 在子命名空间中设置参数 --&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"configfile"</span> <span class="attr">textfile</span>=<span class="string">"$(find roslaunch)/example. xml"</span> /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 向参数服务器中加载文本文件内容 --&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"binaryfile"</span> <span class="attr">binfile</span>=<span class="string">"$(find roslaunch)/example. xml"</span> /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 向参数服务器中加载二进制文件内容 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><p>参考链接：</p><ul><li><a href="http://wiki.ros.org/roslaunch/XML" target="_blank" rel="noopener">http://wiki.ros.org/roslaunch/XML</a></li><li><a href="https://blog.csdn.net/u012424737/article/details/78854536" target="_blank" rel="noopener">https://blog.csdn.net/u012424737/article/details/78854536</a></li><li><a href="https://blog.csdn.net/weixin_41995979/article/details/81784987" target="_blank" rel="noopener">https://blog.csdn.net/weixin_41995979/article/details/81784987</a></li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>ROS学习</category>
      </categories>
      <tags>
        <tag>ROS</tag>
        <tag>roslaunch</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序开发-input正则</title>
    <url>/posts/1318413979/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><!-- build time:Sat Nov 13 2021 15:45:21 GMT+0000 (Coordinated Universal Time) --><p>检查 <code>input</code>输入框是否输入限制字符。如果是，则丢弃；否则，正常输入。</p><a id="more"></a><p><code>input</code> 标签具有 <code>bindinput</code> 属性，支持输入数据的双向绑定，类似 <code>Vue</code> 中的 <code>v-model</code>。</p><blockquote><p>键盘输入时触发，<code>event.detail = {value, cursor, keyCode}，keyCode</code> 为键值，2.1.0 起支持，处理函数可以直接 return 一个字符串，将替换输入框的内容。</p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"digit"</span> <span class="attr">bindinput</span>=<span class="string">"regInput"</span> <span class="attr">maxlength</span>=<span class="string">"15"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>匹配正则通过则返回所有字符，不通过则去掉最后一个不匹配的字符返回。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*正则匹配*/</span></span><br><span class="line">regInput(e)&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="regexp">/^(\d?)+(\.\d&#123;0,2&#125;)?$/</span>.test(e.detail.value))&#123;</span><br><span class="line">    <span class="keyword">return</span> e.detail.value;</span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> e.detail.value.substring(<span class="number">0</span>,e.detail.value.length<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考链接"><a class="header-anchor" href="#参考链接">¶</a>参考链接</h2><p><a href="https://www.jb51.net/article/145878.htm" target="_blank" rel="noopener">https://www.jb51.net/article/145878.htm</a></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>微信小程序开发</category>
      </categories>
      <tags>
        <tag>wechat-dev</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序开发-布局flex</title>
    <url>/posts/208261819/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><!-- build time:Sat Nov 13 2021 15:45:21 GMT+0000 (Coordinated Universal Time) --><p>微信小程序开发-布局 flex</p><a id="more"></a><h2 id="flex布局"><a class="header-anchor" href="#flex布局">¶</a><strong><code>flex</code>布局</strong></h2><p>微信小程序 <code>View</code> 支持两种布局方式：<code>Block</code> 和 <code>Flex</code><br>所有 <code>View</code> 默认都是 <code>block</code>。要使用 flex 布局的话需要显式的声明。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">"main"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">"item item1"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">"item item2"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">"item item3"</span>&gt;</span>3<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>1) 未设置 <code>flex</code>，竖向布局</strong></p><pre><code>1
2
3
</code></pre><p><strong>2) <code>flex</code> 布局，在样式中加入 <code>display: flex;</code></strong></p><pre><code>123
</code></pre><h2 id="flex-direction"><a class="header-anchor" href="#flex-direction">¶</a><strong><code>flex-direction</code></strong></h2><h3 id="横向布局"><a class="header-anchor" href="#横向布局">¶</a>横向布局</h3><ul><li><code>flex-direction: row</code>：从左到右的水平方向为主轴</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">123</span><br></pre></td></tr></table></figure><ul><li><code>flex-direction: row-reverse</code>：从右到左的水平方向为主轴</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">321</span><br></pre></td></tr></table></figure><h2 id="justify-content"><a class="header-anchor" href="#justify-content">¶</a><strong><code>justify-content</code></strong></h2><p>横向的布局属性</p><ul><li><code>lex-start</code>：主轴起点对齐(默认值)</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">123</span><br></pre></td></tr></table></figure><ul><li><code>flex-end</code>：主轴结束点对齐</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">123</span><br></pre></td></tr></table></figure><ul><li><code>center</code>：在主轴中居中对齐</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">123</span><br></pre></td></tr></table></figure><ul><li><code>space-between</code>：两端对齐，除了两端的子元素分别靠向两端的容器之外，其他子元素之间的间隔都相等</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1        2        3</span><br></pre></td></tr></table></figure><ul><li><code>space-around</code>：每个子元素之间的距离相等，两端的子元素距离容器的距离也和其它子元素之间的距离相同</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1      2      3</span><br></pre></td></tr></table></figure><h3 id="纵向布局"><a class="header-anchor" href="#纵向布局">¶</a>纵向布局</h3><ul><li><code>flex-direction: column</code>：从上到下的垂直方向为主轴</li><li><code>flex-direction: column-reverse</code>：从下到上的垂直方向为主轴</li></ul><h2 id="align-items"><a class="header-anchor" href="#align-items">¶</a><strong><code>align-items</code></strong></h2><p>纵向布局属性：</p><ul><li><code>stretch</code> 填充整个容器(默认值)</li><li><code>flex-start</code> 侧轴的起点对齐 （这里我们手动设置下子 view 的高度，来看的明显一些）</li><li><code>flex-end</code> 侧轴的终点对齐</li><li><code>center</code> 在侧轴中居中对齐</li><li><code>baseline</code> 以子元素的第一行文字对齐</li></ul><h2 id="align-self"><a class="header-anchor" href="#align-self">¶</a><strong><code>align-self</code></strong></h2><p>子 <code>View</code> 的属性 <code>align-self</code>，可以覆盖父元素的 <code>align-items</code> 属性，它有 6 个值可选：<code>auto | flex-start | flex-end | center | baseline | stretch</code> （ <code>auto</code> 为继承父元素 <code>align-items</code> 属性，其他和 <code>align-items</code> 一致）</p><h2 id="flex-wrap"><a class="header-anchor" href="#flex-wrap">¶</a><strong><code>flex-wrap</code></strong></h2><p>用于控制子 <code>View</code> 是否换行</p><ul><li><code>nowrap</code> ：不换行（默认）</li><li><code>wrap</code> ：换行</li><li><code>wrap-reverse</code> ：换行，第一行在最下面</li></ul><h2 id="order"><a class="header-anchor" href="#order">¶</a><strong><code>order</code></strong></h2><p>控制子元素的排列顺序，默认为<code>0</code>。<br>把 <code>item3</code> 设置 <code>order:-1;</code> 可以把 <code>item3</code> 排在前面</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">312</span><br></pre></td></tr></table></figure><h2 id="flex-grow"><a class="header-anchor" href="#flex-grow">¶</a><strong><code>flex-grow</code></strong></h2><p><code>.wxss</code>中修改代码如下：在 <code>item1</code> 中增加： <code>flex-grow: 1</code>，在 <code>item3</code> 中增加： <code>flex-grow: 2``，表示在一行中如果有剩余空间的话，item3</code> 之外的子 <code>view</code> 占 1 份空间，而 <code>item3</code> 子 <code>view</code> 占 2 份空间(可以理解为剩余空间 <code>item3</code> 最多可以占 2 份空间)。</p><h2 id="flex-shrink"><a class="header-anchor" href="#flex-shrink">¶</a><strong><code>flex-shrink</code></strong></h2><p><code>.wxss</code>中再增加 4 个子 <code>view</code> 并修改代码如下：<code>i3</code> 的<code>flex-shrink: 0</code>，其余子 <code>view</code> 为 <code>flex-shrink: 1</code>，这表示当空间不足时所有子 <code>view</code> 都等比缩小，但是 <code>i3</code> 的 <code>view</code> 保持大小不变.</p><h2 id="flex-basis"><a class="header-anchor" href="#flex-basis">¶</a><strong><code>flex-basis</code></strong></h2><h2 id="注意"><a class="header-anchor" href="#注意">¶</a><strong>注意</strong></h2><p><code>flex</code> 是 <code>grow</code> ，<code>shrink</code> ，<code>basis</code> 几个属性的合并</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: grow shrink basis;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>flex-flow</code> 是 <code>flex-direction</code> 和 <code>flex-wrap</code> 两个属性的组合</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"> &#123;</span><br><span class="line">  <span class="attribute">flex-flow</span>: wrap row;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>微信小程序开发</category>
      </categories>
      <tags>
        <tag>wechat-dev</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown语法学习笔记</title>
    <url>/posts/4176222009/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><!-- build time:Sat Nov 13 2021 15:45:21 GMT+0000 (Coordinated Universal Time) --><p><strong>Markdown</strong>是一种轻量级标记语言，创始人为约翰·格鲁伯（英语：John Gruber）。它允许人们“使用易读易写的纯文本格式编写文档，然后转换成有效的 XHTML（或者 HTML）文档”。这种语言吸收了很多在电子邮件中已有的纯文本标记的特性。</p><a id="more"></a><p>由于<strong>Markdown</strong>的轻量化、易读易写特性，并且对于图片，图表、数学式都有支持，当前许多网站都广泛使用<strong>Markdown</strong>来撰写帮助文档或是用于论坛上发表消息。例如：GitHub、reddit、Diaspora、Stack Exchange、OpenStreetMap 、SourceForge 等。甚至 Markdown 能被使用来撰写电子书。</p><h2 id="主要内容"><a class="header-anchor" href="#主要内容">¶</a>主要内容</h2><blockquote><h3 id="1-Markdown历史"><a class="header-anchor" href="#1-Markdown历史">¶</a><a href="#Markdown%E5%8E%86%E5%8F%B2">1. <strong>Markdown</strong>历史</a></h3><h3 id="2-Markdown主要语法"><a class="header-anchor" href="#2-Markdown主要语法">¶</a><a href="#Markdown%E4%B8%BB%E8%A6%81%E8%AF%AD%E6%B3%95">2. <strong>Markdown</strong>主要语法</a></h3><h3 id="3-其他语法"><a class="header-anchor" href="#3-其他语法">¶</a><a href="#%E5%85%B6%E4%BB%96%E8%AF%AD%E6%B3%95">3. 其他语法</a></h3><h3 id="4-参考链接"><a class="header-anchor" href="#4-参考链接">¶</a><a href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5">4. 参考链接</a></h3></blockquote><hr><h2 id="正文"><a class="header-anchor" href="#正文">¶</a>正文</h2><hr><h2 id="Markdown历史"><a class="header-anchor" href="#Markdown历史">¶</a><strong>Markdown</strong>历史</h2><hr><h3 id="概述"><a class="header-anchor" href="#概述">¶</a>概述</h3><p><strong>John Gruber</strong>在 2004 年创造了<strong>Markdown</strong>语言，在语法上有很大一部分是跟<a href="https://zh.wikipedia.org/wiki/%E4%BA%9A%E4%BC%A6%C2%B7%E6%96%AF%E6%B2%83%E8%8C%A8" target="_blank" rel="noopener"><strong>Aaron Swartz</strong></a>共同合作的。<strong>Markdown</strong>的目标是实现「易读易写」。可读性，无论如何，都是最重要的。一份使用<strong>Markdown</strong>格式撰写的文件应该可以直接以纯文本发布，并且看起来不会像是由许多标签或是格式指令所构成。<strong>Markdown</strong>语法受到一些既有 text-to-HTML 格式的影响，包括 Setext、atx、Textile、reStructuredText、Grutatext 和 EtText，而最大灵感来源其实是纯文本电子邮件的格式。</p><h3 id="Aaron-Swartz-大神"><a class="header-anchor" href="#Aaron-Swartz-大神">¶</a>Aaron Swartz 大神</h3><p><a href="https://zh.wikipedia.org/wiki/%E4%BA%9A%E4%BC%A6%C2%B7%E6%96%AF%E6%B2%83%E8%8C%A8" target="_blank" rel="noopener"><strong>Aaron Swartz</strong></a>（1986 年 11 月 8 日－2013 年 1 月 11 日）是美国计算机程序员、企业家、作家、政治活动者和互联网黑客主义者。他参与开发了 RSS 网上信息源发布格式、Markdown 文本发布格式、知识共享组织、<a href="http://web.py" target="_blank" rel="noopener">web.py</a> 网站开发框架，同时是社交媒体 Reddit 的联合创始人。</p><blockquote><ul><li><p><strong><em>2009 年</em></strong>，他协助成立了渐进社会变革活动委员会，期以了解有效的互联网运动。</p></li><li><p><strong><em>2010 年</em></strong>，他成为哈佛大学埃德蒙·萨夫拉伦理研究中心的学者，在劳伦斯·莱斯格的领导下进行研究。他曾成立在线群组求进会——因反对禁止网络盗版法案的运动而闻名。</p></li><li><p><strong><em>2011 年</em></strong>，他被麻省理工学院警署以其非法闯入的罪名逮捕：通过麻省理工学院校园网络，透过学院给予的访客账户，大规模系统性地下载 JSTOR 上的学术期刊。联邦检察官对他提起两项网络诈骗和十一项违反《计算机欺诈和滥用法》行为的诉讼——亚伦·斯沃茨将面临合计最高 35 年的刑期并处 100 万美元罚金、没收财产、归还失窃物品和监视居住的处罚。<br>他拒绝了联邦检察官提议其在联邦监狱服刑 6 个月的认罪协商。随后他被发现死在其于纽约布鲁克林区的公寓内，自缢而死。</p></li><li><p><strong><em>2013 年</em></strong>，亚伦·斯沃茨被追授入互联网名人堂。</p></li></ul></blockquote><p><img data-src="https://github.com/younghz/Markdown/raw/master/resource/Aaron_Swartz.jpg" alt="Aaron Swartz"></p><hr><h2 id="Markdown主要语法"><a class="header-anchor" href="#Markdown主要语法">¶</a><strong>Markdown</strong>主要语法</h2><hr><p><strong>Markdown</strong>语法主要分为如下几大部分：<br><a href="#%E6%A0%87%E9%A2%98"><strong>标题</strong></a><br><a href="#%E6%AE%B5%E8%90%BD"><strong>段落</strong></a><br><a href="#%E5%AD%97%E4%BD%93"><strong>字体</strong></a><br><a href="#%E6%A8%AA%E7%BA%BF"><strong>横线</strong></a><br><a href="#%E5%BC%95%E7%94%A8%E5%8C%BA%E5%9D%97"><strong>引用区块</strong></a><br><a href="#%E4%BB%A3%E7%A0%81%E5%8C%BA%E5%9D%97"><strong>代码区块</strong></a><br><a href="#%E5%88%97%E8%A1%A8"><strong>列表</strong></a><br><a href="#%E9%93%BE%E6%8E%A5"><strong>链接</strong></a><br><a href="#%E5%9B%BE%E7%89%87"><strong>图片</strong></a><br><a href="#%E8%A1%A8%E6%A0%BC"><strong>表格</strong></a><br><a href="#%E5%8F%8D%E6%96%9C%E6%9D%A0"><strong>反斜杠</strong></a><br><a href="#%E7%AC%A6%E5%8F%B7%60"><strong>符号`</strong></a></p><hr><h3 id="标题"><a class="header-anchor" href="#标题">¶</a>标题</h3><hr><h4 id="用-和-标记一级和二级标题"><a class="header-anchor" href="#用-和-标记一级和二级标题">¶</a>用<code>=</code>和<code>-</code>标记一级和二级标题</h4><blockquote><p>一级标题<br><code>=========</code><br>二级标题<br><code>---------</code></p></blockquote><p>效果：</p><blockquote><h1>一级标题</h1><h2 id="二级标题"><a class="header-anchor" href="#二级标题">¶</a>二级标题</h2></blockquote><hr><h4 id="使用-，可表示-1-6-级标题"><a class="header-anchor" href="#使用-，可表示-1-6-级标题">¶</a>使用<code>#</code>，可表示 1-6 级标题</h4><blockquote><p><code># 一级标题</code><br><code>## 二级标题</code><br><code>### 三级标题</code><br><code>#### 四级标题</code><br><code>##### 五级标题</code><br><code>###### 六级标题</code></p></blockquote><p>效果：</p><blockquote><h1>一级标题</h1><h2 id="二级标题-v2"><a class="header-anchor" href="#二级标题-v2">¶</a>二级标题</h2><h3 id="三级标题"><a class="header-anchor" href="#三级标题">¶</a>三级标题</h3><h4 id="四级标题"><a class="header-anchor" href="#四级标题">¶</a>四级标题</h4><h5 id="五级标题"><a class="header-anchor" href="#五级标题">¶</a>五级标题</h5><h6 id="六级标题"><a class="header-anchor" href="#六级标题">¶</a>六级标题</h6></blockquote><hr><h3 id="段落"><a class="header-anchor" href="#段落">¶</a>段落</h3><p>段落的前后要有空行，所谓的空行是指没有文字内容。若想在段内强制换行的方式是使用<strong>两个以上空格加上回车</strong>。</p><hr><h3 id="字体"><a class="header-anchor" href="#字体">¶</a>字体</h3><h4 id="粗体和斜体"><a class="header-anchor" href="#粗体和斜体">¶</a>粗体和斜体</h4><p>使用<code>*</code>或<code>_</code>包含需要标记为斜体或加粗的文字：</p><blockquote><p><code>*斜体文本*</code><br><code>_斜体文本_</code><br><code>**粗体文本**</code><br><code>__粗体文本__</code><br><code>***粗斜体文本***</code><br><code>___粗斜体文本___</code></p></blockquote><p>效果：</p><blockquote><p><em>斜体文本</em><br><em>斜体文本</em><br><strong>粗体文本</strong><br><strong>粗体文本</strong><br><strong><em>粗斜体文本</em></strong><br><strong><em>粗斜体文本</em></strong></p></blockquote><h4 id="上下标"><a class="header-anchor" href="#上下标">¶</a>上下标</h4><p>使用<code>&lt;sub&gt;</code>标签：</p><blockquote><p>上标：<code>X&lt;sub&gt;2&lt;/sub&gt;</code><br>下标：<code>O&lt;sup&gt;2&lt;/sup&gt;</code></p></blockquote><p>效果：</p><blockquote><p>上标：X<sub>2</sub><br>下标：O<sup>2</sup></p></blockquote><hr><h3 id="横线"><a class="header-anchor" href="#横线">¶</a>横线</h3><hr><h4 id="分割线"><a class="header-anchor" href="#分割线">¶</a>分割线</h4><p>在一行中用三个以上的<code>*</code>、<code>-</code>、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格（不建议加空格）：</p><blockquote><p><code>* * *</code><br><code>***</code><br><code>*****</code><br><code>- - -</code><br><code>----------</code></p></blockquote><p>效果：</p><hr><hr><hr><hr><hr><h4 id="删除线"><a class="header-anchor" href="#删除线">¶</a>删除线</h4><p>在文字的两端加上两个波浪线<code>~~</code>即可:</p><blockquote><p><code>~~Markdown删除线~~</code></p></blockquote><p>效果：</p><blockquote><p><s>Markdown 删除线</s></p></blockquote><h4 id="下划线"><a class="header-anchor" href="#下划线">¶</a>下划线</h4><p>使用<code>&lt;u&gt;</code>标签：</p><blockquote><p><code>&lt;u&gt;Markdown下划线&lt;/u&gt;</code></p></blockquote><p>效果：</p><blockquote><p><u>Markdown 下划线</u></p></blockquote><hr><h3 id="2-5-引用区块"><a class="header-anchor" href="#2-5-引用区块">¶</a>2.5 引用区块</h3><hr><h4 id="行内引用"><a class="header-anchor" href="#行内引用">¶</a>行内引用</h4><p>使用符号`（Esc 下面那个符号）:</p><blockquote><p>这是`行内`引用</p></blockquote><p>效果：</p><blockquote><p>这是<code>行内</code>引用。</p></blockquote><h4 id="引用区块"><a class="header-anchor" href="#引用区块">¶</a>引用区块</h4><p>在段首使用符号<code>&gt;</code>：<br><code>&gt; **Markdown** 引用单行文本</code><br><code>&gt; **Markdown** 引用单行文本</code></p><p>效果：</p><blockquote><p><strong>Markdown</strong> 引用单行文本<br><strong>Markdown</strong> 引用单行文本</p></blockquote><h4 id="嵌套引用区块"><a class="header-anchor" href="#嵌套引用区块">¶</a>嵌套引用区块</h4><p>使用多个<code>&gt;</code>完成嵌套引用：<br><code>&gt; 单行引用</code><br><code>&gt;&gt; 嵌套引用</code><br><code>&gt;&gt;&gt; 三次嵌套引用</code><br><code>&gt;&gt;&gt; 三次嵌套引用</code></p><p>效果</p><blockquote><p>单行引用</p><blockquote><p>二层引用<br>二层嵌套</p><blockquote><p>三层嵌套引用<br>三层嵌套引用</p></blockquote></blockquote></blockquote><hr><h3 id="代码区块"><a class="header-anchor" href="#代码区块">¶</a>代码区块</h3><hr><p>对代码区块进缩进处理，通过<strong>每行</strong>缩进四个空格或一个制表符即可，但是没有语法高亮和行号显示。代码文本：<br><code>void main()</code><br><code>{</code><br><code>printf(&quot;Hello, Markdown.&quot;);</code><br><code>}</code></p><h4 id="使用空格或制表符"><a class="header-anchor" href="#使用空格或制表符">¶</a>使用空格或制表符</h4><pre><code>void main()
{
    printf(&quot;Hello, Markdown.&quot;);
}
</code></pre><h4 id="通过标签"><a class="header-anchor" href="#通过标签">¶</a>通过标签</h4><p>使用标签<code>&lt;pre&gt;&lt;/pre&gt;</code>也可以实现缩进：<br><code>&lt;pre&gt;</code><br><code>int main(int argc, int *argv[])</code><br><code>{</code><br><code>printf(&quot;Hello, Markdown.&quot;);</code><br><code>}</code><br><code>&lt;/pre&gt;</code></p><p>效果：</p><pre>
int main(int argc, int *argv[]) 
{
    printf("Hello, Markdown.");    
}   
</pre><h4 id="增加高亮和行号"><a class="header-anchor" href="#增加高亮和行号">¶</a>增加高亮和行号</h4><p>类似多行注释，在代码块首位各用三个符号`来处理，并指定代码语言（C 语言为例）：</p><p>```C<br><code>int main(int argc, int *argv[])</code><br><code>{</code><br><code>printf(&quot;Hello, Markdown.&quot;);</code><br><code>}</code><br>```</p><p>效果：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">int</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello, Markdown."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="列表"><a class="header-anchor" href="#列表">¶</a>列表</h3><h4 id="无序列表"><a class="header-anchor" href="#无序列表">¶</a>无序列表</h4><p>使用<code>·</code>、<code>+</code>、或<code>-</code>任意一种标记无序列表，如：</p><blockquote><p>- 第一项<br>- 第二项<br>- 第三项</p></blockquote><blockquote><p>+ 第一项<br>+ 第二项<br>+ 第三项</p></blockquote><blockquote><p>* 第一项<br>* 第二项<br>* 第三项</p></blockquote><p><strong>注意</strong>：标记后面最少有一个<em>空格</em>或<em>制表符</em>。若不在引用区块中，必须和前方段落之间存在空行。</p><p>效果：</p><blockquote><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul></blockquote><h4 id="有序列表"><a class="header-anchor" href="#有序列表">¶</a>有序列表</h4><p>有序列表的标记方式是将上述的符号换成数字,并辅以<code>.</code>，如：</p><blockquote><p><code>1. 第一项</code><br><code>2. 第二项</code><br><code>3. 第三项</code></p></blockquote><p>效果：</p><blockquote><ol><li>第一项</li><li>第二项</li><li>第三项</li></ol></blockquote><h4 id="列表嵌套"><a class="header-anchor" href="#列表嵌套">¶</a>列表嵌套</h4><p>列表嵌套只需在子列表中的选项添加四个空格或缩进 TAB 即可，也可在列表内进行区块引用：</p><blockquote><p><code>1. 第一项</code><br><code>- 第一项嵌套的第一个元素</code><br><code>- 第一项嵌套的第二个元素</code><br><code>2. 第二项</code><br><code>&gt; 第二项嵌套的第一个元素</code><br><code>&gt; 第二项嵌套的第二个元素</code></p></blockquote><p>效果：</p><blockquote><ol><li>第一项<ul><li>第一项嵌套的第一个元素</li><li>第一项嵌套的第二个元素</li></ul></li><li>第二项<blockquote><p>第二项第一个元素区块引用<br>第二项第二个元素区块引用</p></blockquote></li></ol></blockquote><h4 id="GFM-task-list"><a class="header-anchor" href="#GFM-task-list">¶</a>GFM task list</h4><p>带选择框的选项列表：</p><pre>
- [x] GFM task list 1
- [x] GFM task list 2
- [ ] GFM task list 3
    - [ ] GFM task list 3-1
    - [ ] GFM task list 3-2
    - [ ] GFM task list 3-3
- [ ] GFM task list 4
    - [ ] GFM task list 4-1
    - [ ] GFM task list 4-2
</pre><p>效果：</p><ul class="contains-task-list"><li class="task-list-item"><input class="task-list-item-checkbox" checked disabled type="checkbox"> GFM task list 1</li><li class="task-list-item"><input class="task-list-item-checkbox" checked disabled type="checkbox"> GFM task list 2</li><li class="task-list-item"><input class="task-list-item-checkbox" disabled type="checkbox"> GFM task list 3<ul class="contains-task-list"><li class="task-list-item"><input class="task-list-item-checkbox" disabled type="checkbox"> GFM task list 3-1</li><li class="task-list-item"><input class="task-list-item-checkbox" disabled type="checkbox"> GFM task list 3-2</li><li class="task-list-item"><input class="task-list-item-checkbox" disabled type="checkbox"> GFM task list 3-3</li></ul></li><li class="task-list-item"><input class="task-list-item-checkbox" disabled type="checkbox"> GFM task list 4<ul class="contains-task-list"><li class="task-list-item"><input class="task-list-item-checkbox" disabled type="checkbox"> GFM task list 4-1</li><li class="task-list-item"><input class="task-list-item-checkbox" disabled type="checkbox"> GFM task list 4-2</li></ul></li></ul><hr><h3 id="链接"><a class="header-anchor" href="#链接">¶</a>链接</h3><p>链接可以由两种形式生成：<strong>行内式</strong>和<strong>参考式</strong>。</p><h4 id="行内式"><a class="header-anchor" href="#行内式">¶</a>行内式</h4><p>方式为<code>[链接名称](链接地址)</code>或<code>&lt;链接地址&gt;</code></p><blockquote><p><code>这是一个链接 [github treading](https://github.com/trending)</code><br><code>这是另一个链接 &lt;https://github.com/explore&gt;</code></p></blockquote><p>效果：</p><blockquote><p>这是一个链接 <a href="https://github.com/trending" target="_blank" rel="noopener">github treading</a><br>这是另一个链接 <a href="https://github.com/explore" target="_blank" rel="noopener">https://github.com/explore</a></p></blockquote><h4 id="参考式"><a class="header-anchor" href="#参考式">¶</a>参考式</h4><p>链接也可以用变量（数字或字符串）来代替：</p><blockquote><p><code>这是一个链接 [github treading][1]</code><br><code>这是另一个链接 [github explore][explore]</code><br><s><strong>(上下之间必须有空行)</strong></s><br><code>[1]:https://github.com/trending</code><br><code>[explore]:https://github.com/explore</code></p></blockquote><p>效果：</p><blockquote><p>这是一个链接 [github treading][1]<br>这是另一个链接 [github explore][explore]</p><p>[1]:<a href="https://github.com/trending" target="_blank" rel="noopener">https://github.com/trending</a> &gt; [explore]:<a href="https://github.com/explore" target="_blank" rel="noopener">https://github.com/explore</a></p></blockquote><p><strong>注意</strong>：上述的<code>[1]:https://github.com/trending</code>不出现在区块中。</p><hr><h3 id="图片"><a class="header-anchor" href="#图片">¶</a>图片</h3><hr><p>添加图片的形式和链接相似，只需在链接的基础上前方加一个<code>！</code>，支持行内式和参考式。如上文<strong>Aaron Swartz</strong>的图片链接:</p><blockquote><p><code>![Aaron Swartz](https://github.com/younghz/Markdown/raw/master/resource/Aaron_Swartz.jpg)</code></p></blockquote><hr><h3 id="表格"><a class="header-anchor" href="#表格">¶</a>表格</h3><p>使用<code>|</code>来分隔不同的单元格，使用<code>-</code>来分隔表头和其他行。使用<code>-:</code>，<code>:-</code>，<code>:-:</code>设置表格的对齐方式：</p><blockquote><p><code>| 这是左对齐 | 这是右对齐 | 这是居中对齐 |</code><br><code>| :--------- | ---------: | :----------: |</code><br><code>| 单元格 | 单元格 | 单元格 |</code><br><code>| 单元格 | 单元格 | 单元格 |</code></p></blockquote><p>效果：</p><blockquote><table><thead><tr><th style="text-align:left">这是左对齐</th><th style="text-align:right">这是右对齐</th><th style="text-align:center">这是居中对齐</th></tr></thead><tbody><tr><td style="text-align:left">单元格</td><td style="text-align:right">单元格</td><td style="text-align:center">单元格</td></tr><tr><td style="text-align:left">单元格</td><td style="text-align:right">单元格</td><td style="text-align:center">单元格</td></tr></tbody></table></blockquote><hr><h3 id="反斜杠"><a class="header-anchor" href="#反斜杠">¶</a>反斜杠</h3><hr><p><strong>反转义</strong>，使符号成为普通符号。</p><pre>
\\    反斜线 
\`    反引号
\*    星号 
\_    下划线
\{\}  花括号
\[\]  方括号
\(\)  小括号
\#    井字号
\+    加号
\-    减号
\.    英文句点
\!    感叹号
\!    感叹号
</pre><p>效果</p><blockquote><p>\ 反斜线<br>` 反引号<br>* 星号<br>_ 下划线<br>{} 花括号<br>[] 方括号<br>() 小括号<br># 井字号<br>+ 加号<br>- 减号<br>. 英文句点<br>! 感叹号</p></blockquote><hr><h3 id="符号"><a class="header-anchor" href="#符号">¶</a>符号`</h3><hr><p>起到标记作用。如：</p><blockquote><p>`ctrl+a`</p></blockquote><p>效果：</p><blockquote><p><code>ctrl+a</code></p></blockquote><hr><h2 id="其他语法"><a class="header-anchor" href="#其他语法">¶</a>其他语法</h2><hr><p>使用两个美元符<code>$$</code>包裹<strong>TeX</strong>或<strong>LaTeX</strong>格式的数学公式来实现。</p><hr><hr><p><strong>其他</strong>：关于其它扩展语法可参见具体工具的使用说明。</p><hr><h2 id="参考链接"><a class="header-anchor" href="#参考链接">¶</a>参考链接</h2><hr><p><a href="https://www.runoob.com/markdown/md-tutorial.html" target="_blank" rel="noopener">https://www.runoob.com/markdown/md-tutorial.html</a><br><a href="https://markdown.tw" target="_blank" rel="noopener">https://markdown.tw</a><br><a href="https://github.com/younghz/Markdown" target="_blank" rel="noopener">https://github.com/younghz/Markdown</a></p><hr><hr><p><strong><em>笔下是语法，心中格式化</em></strong></p><hr><!-- rebuild by neat -->]]></content>
      <categories>
        <category>Tutorial</category>
      </categories>
      <tags>
        <tag>Tutorial</tag>
        <tag>Markdown</tag>
      </tags>
  </entry>
</search>
