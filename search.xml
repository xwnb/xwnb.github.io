<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Markdown语法学习笔记</title>
    <url>/posts/4176222009/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong>Markdown</strong>是一种轻量级标记语言，创始人为约翰·格鲁伯（英语：John Gruber）。它允许人们“使用易读易写的纯文本格式编写文档，然后转换成有效的 XHTML（或者 HTML）文档”。这种语言吸收了很多在电子邮件中已有的纯文本标记的特性。</p>
<a id="more"></a>
<p>由于<strong>Markdown</strong>的轻量化、易读易写特性，并且对于图片，图表、数学式都有支持，当前许多网站都广泛使用<strong>Markdown</strong>来撰写帮助文档或是用于论坛上发表消息。例如：GitHub、reddit、Diaspora、Stack Exchange、OpenStreetMap 、SourceForge 等。甚至 Markdown 能被使用来撰写电子书。</p>
<h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><blockquote>
<h3 id="1-Markdown历史"><a href="#1-Markdown历史" class="headerlink" title="1. Markdown历史"></a><a href="#Markdown历史">1. <strong>Markdown</strong>历史</a></h3><h3 id="2-Markdown主要语法"><a href="#2-Markdown主要语法" class="headerlink" title="2. Markdown主要语法"></a><a href="#Markdown主要语法">2. <strong>Markdown</strong>主要语法</a></h3><h3 id="3-其他语法"><a href="#3-其他语法" class="headerlink" title="3. 其他语法"></a><a href="#其他语法">3. 其他语法</a></h3><h3 id="4-参考链接"><a href="#4-参考链接" class="headerlink" title="4. 参考链接"></a><a href="#参考链接">4. 参考链接</a></h3></blockquote>
<hr>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><hr>
<h2 id="Markdown历史"><a href="#Markdown历史" class="headerlink" title="Markdown历史"></a><strong>Markdown</strong>历史</h2><hr>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><strong>John Gruber</strong>在 2004 年创造了<strong>Markdown</strong>语言，在语法上有很大一部分是跟<a href="https://zh.wikipedia.org/wiki/%E4%BA%9A%E4%BC%A6%C2%B7%E6%96%AF%E6%B2%83%E8%8C%A8" target="_blank" rel="noopener"><strong>Aaron Swartz</strong></a>共同合作的。<strong>Markdown</strong>的目标是实现「易读易写」。可读性，无论如何，都是最重要的。一份使用<strong>Markdown</strong>格式撰写的文件应该可以直接以纯文本发布，并且看起来不会像是由许多标签或是格式指令所构成。<strong>Markdown</strong>语法受到一些既有 text-to-HTML 格式的影响，包括 Setext、atx、Textile、reStructuredText、Grutatext 和 EtText，而最大灵感来源其实是纯文本电子邮件的格式。</p>
<h3 id="Aaron-Swartz-大神"><a href="#Aaron-Swartz-大神" class="headerlink" title="Aaron Swartz 大神"></a>Aaron Swartz 大神</h3><p><a href="https://zh.wikipedia.org/wiki/%E4%BA%9A%E4%BC%A6%C2%B7%E6%96%AF%E6%B2%83%E8%8C%A8" target="_blank" rel="noopener"><strong>Aaron Swartz</strong></a>（1986 年 11 月 8 日－2013 年 1 月 11 日）是美国计算机程序员、企业家、作家、政治活动者和互联网黑客主义者。他参与开发了 RSS 网上信息源发布格式、Markdown 文本发布格式、知识共享组织、web.py 网站开发框架，同时是社交媒体 Reddit 的联合创始人。</p>
<blockquote>
<ul>
<li><p><strong>_2009 年_</strong>，他协助成立了渐进社会变革活动委员会，期以了解有效的互联网运动。</p>
</li>
<li><p><strong>_2010 年_</strong>，他成为哈佛大学埃德蒙·萨夫拉伦理研究中心的学者，在劳伦斯·莱斯格的领导下进行研究。他曾成立在线群组求进会——因反对禁止网络盗版法案的运动而闻名。</p>
</li>
<li><p><strong>_2011 年_</strong>，他被麻省理工学院警署以其非法闯入的罪名逮捕：通过麻省理工学院校园网络，透过学院给予的访客账户，大规模系统性地下载 JSTOR 上的学术期刊。联邦检察官对他提起两项网络诈骗和十一项违反《计算机欺诈和滥用法》行为的诉讼——亚伦·斯沃茨将面临合计最高 35 年的刑期并处 100 万美元罚金、没收财产、归还失窃物品和监视居住的处罚。<br>他拒绝了联邦检察官提议其在联邦监狱服刑 6 个月的认罪协商。随后他被发现死在其于纽约布鲁克林区的公寓内，自缢而死。</p>
</li>
<li><p><strong>_2013 年_</strong>，亚伦·斯沃茨被追授入互联网名人堂。</p>
</li>
</ul>
</blockquote>
<p><img data-src="https://github.com/younghz/Markdown/raw/master/resource/Aaron_Swartz.jpg" alt="Aaron Swartz"></p>
<hr>
<h2 id="Markdown主要语法"><a href="#Markdown主要语法" class="headerlink" title="Markdown主要语法"></a><strong>Markdown</strong>主要语法</h2><hr>
<p><strong>Markdown</strong>语法主要分为如下几大部分：<br><a href="#标题"><strong>标题</strong></a><br><a href="#段落"><strong>段落</strong></a><br><a href="#字体"><strong>字体</strong></a><br><a href="#横线"><strong>横线</strong></a><br><a href="#引用区块"><strong>引用区块</strong></a><br><a href="#代码区块"><strong>代码区块</strong></a><br><a href="#列表"><strong>列表</strong></a><br><a href="#链接"><strong>链接</strong></a><br><a href="#图片"><strong>图片</strong></a><br><a href="#表格"><strong>表格</strong></a><br><a href="#反斜杠"><strong>反斜杠</strong></a><br><a href="#符号`"><strong>符号`</strong></a></p>
<hr>
<h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><hr>
<h4 id="用-和-标记一级和二级标题"><a href="#用-和-标记一级和二级标题" class="headerlink" title="用=和-标记一级和二级标题"></a>用<code>=</code>和<code>-</code>标记一级和二级标题</h4><blockquote>
<p>一级标题<br><code>=========</code><br>二级标题<br><code>---------</code></p>
</blockquote>
<p>效果：</p>
<blockquote>
<h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2></blockquote>
<hr>
<h4 id="使用-，可表示-1-6-级标题"><a href="#使用-，可表示-1-6-级标题" class="headerlink" title="使用#，可表示 1-6 级标题"></a>使用<code>#</code>，可表示 1-6 级标题</h4><blockquote>
<p><code># 一级标题</code><br><code>## 二级标题</code><br><code>### 三级标题</code><br><code>#### 四级标题</code><br><code>##### 五级标题</code><br><code>###### 六级标题</code></p>
</blockquote>
<p>效果：</p>
<blockquote>
<h1 id="一级标题-1"><a href="#一级标题-1" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题-1"><a href="#二级标题-1" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6></blockquote>
<hr>
<h3 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h3><p>段落的前后要有空行，所谓的空行是指没有文字内容。若想在段内强制换行的方式是使用<strong>两个以上空格加上回车</strong>。</p>
<hr>
<h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><h4 id="粗体和斜体"><a href="#粗体和斜体" class="headerlink" title="粗体和斜体"></a>粗体和斜体</h4><p>使用<code>*</code>或<code>_</code>包含需要标记为斜体或加粗的文字：</p>
<blockquote>
<p><code>*斜体文本*</code><br><code>_斜体文本_</code><br><code>**粗体文本**</code><br><code>__粗体文本__</code><br><code>***粗斜体文本***</code><br><code>___粗斜体文本___</code></p>
</blockquote>
<p>效果：</p>
<blockquote>
<p>_斜体文本_<br>_斜体文本_<br><strong>粗体文本</strong><br><strong>粗体文本</strong><br><strong>_粗斜体文本_</strong><br><strong>_粗斜体文本_</strong></p>
</blockquote>
<h4 id="上下标"><a href="#上下标" class="headerlink" title="上下标"></a>上下标</h4><p>使用<code>&lt;sub&gt;</code>标签：</p>
<blockquote>
<p>上标：<code>X&lt;sub&gt;2&lt;/sub&gt;</code><br>下标：<code>O&lt;sup&gt;2&lt;/sup&gt;</code></p>
</blockquote>
<p>效果：</p>
<blockquote>
<p>上标：X<sub>2</sub><br>下标：O<sup>2</sup></p>
</blockquote>
<hr>
<h3 id="横线"><a href="#横线" class="headerlink" title="横线"></a>横线</h3><hr>
<h4 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h4><p>在一行中用三个以上的<code>*</code>、<code>-</code>、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格（不建议加空格）：</p>
<blockquote>
<p><code>* * *</code><br><code>***</code><br><code>*****</code><br><code>- - -</code><br><code>----------</code></p>
</blockquote>
<p>效果：</p>
<hr>
<hr>
<hr>
<hr>
<hr>
<h4 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h4><p>在文字的两端加上两个波浪线<code>~~</code>即可:</p>
<blockquote>
<p><code>~~Markdown删除线~~</code></p>
</blockquote>
<p>效果：</p>
<blockquote>
<p><del>Markdown 删除线</del></p>
</blockquote>
<h4 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h4><p>使用<code>&lt;u&gt;</code>标签：</p>
<blockquote>
<p><code>&lt;u&gt;Markdown下划线&lt;/u&gt;</code></p>
</blockquote>
<p>效果：</p>
<blockquote>
<p><u>Markdown 下划线</u></p>
</blockquote>
<hr>
<h3 id="2-5-引用区块"><a href="#2-5-引用区块" class="headerlink" title="2.5 引用区块"></a>2.5 引用区块</h3><hr>
<h4 id="行内引用"><a href="#行内引用" class="headerlink" title="行内引用"></a>行内引用</h4><p>使用符号`（Esc 下面那个符号）:</p>
<blockquote>
<p>这是`行内`引用</p>
</blockquote>
<p>效果：</p>
<blockquote>
<p>这是<code>行内</code>引用。</p>
</blockquote>
<h4 id="引用区块"><a href="#引用区块" class="headerlink" title="引用区块"></a>引用区块</h4><p>在段首使用符号<code>&gt;</code>：<br><code>&gt; **Markdown** 引用单行文本</code><br><code>&gt; **Markdown** 引用单行文本</code></p>
<p>效果：</p>
<blockquote>
<p><strong>Markdown</strong> 引用单行文本<br><strong>Markdown</strong> 引用单行文本</p>
</blockquote>
<h4 id="嵌套引用区块"><a href="#嵌套引用区块" class="headerlink" title="嵌套引用区块"></a>嵌套引用区块</h4><p>使用多个<code>&gt;</code>完成嵌套引用：<br><code>&gt; 单行引用</code><br><code>&gt;&gt; 嵌套引用</code><br><code>&gt;&gt;&gt; 三次嵌套引用</code><br><code>&gt;&gt;&gt; 三次嵌套引用</code></p>
<p>效果</p>
<blockquote>
<p>单行引用</p>
<blockquote>
<p>二层引用<br>二层嵌套</p>
<blockquote>
<p>三层嵌套引用<br>三层嵌套引用</p>
</blockquote>
</blockquote>
</blockquote>
<hr>
<h3 id="代码区块"><a href="#代码区块" class="headerlink" title="代码区块"></a>代码区块</h3><hr>
<p>对代码区块进缩进处理，通过<strong>每行</strong>缩进四个空格或一个制表符即可，但是没有语法高亮和行号显示。代码文本：<br><code>void main()</code><br><code>{</code><br>&emsp;&emsp;<code>printf(&quot;Hello, Markdown.&quot;);</code><br><code>}</code></p>
<h4 id="使用空格或制表符"><a href="#使用空格或制表符" class="headerlink" title="使用空格或制表符"></a>使用空格或制表符</h4><pre><code>void main()
{
    printf(&quot;Hello, Markdown.&quot;);
}
</code></pre><h4 id="通过标签"><a href="#通过标签" class="headerlink" title="通过标签"></a>通过标签</h4><p>使用标签<code>&lt;pre&gt;&lt;/pre&gt;</code>也可以实现缩进：<br><code>&lt;pre&gt;</code><br><code>int main(int argc, int *argv[])</code><br><code>{</code><br>&emsp;&emsp;<code>printf(&quot;Hello, Markdown.&quot;);</code><br><code>}</code><br><code>&lt;/pre&gt;</code></p>
<p>效果：</p>
<pre>
int main(int argc, int *argv[]) 
{
    printf("Hello, Markdown.");    
}   
</pre>

<h4 id="增加高亮和行号"><a href="#增加高亮和行号" class="headerlink" title="增加高亮和行号"></a>增加高亮和行号</h4><p>类似多行注释，在代码块首位各用三个符号`来处理，并指定代码语言（C 语言为例）：</p>
<p>```C<br><code>int main(int argc, int *argv[])</code><br><code>{</code><br>&emsp;&emsp;<code>printf(&quot;Hello, Markdown.&quot;);</code><br><code>}</code><br>```</p>
<p>效果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">int</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello, Markdown."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><h4 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h4><p>使用<code>·</code>、<code>+</code>、或<code>-</code>任意一种标记无序列表，如：</p>
<blockquote>
<p>- 第一项<br>- 第二项<br>- 第三项</p>
<p>+ 第一项<br>+ 第二项<br>+ 第三项</p>
<p>* 第一项<br>* 第二项<br>* 第三项</p>
</blockquote>
<p><strong>注意</strong>：标记后面最少有一个<em>空格</em>或<em>制表符</em>。若不在引用区块中，必须和前方段落之间存在空行。</p>
<p>效果：</p>
<blockquote>
<ul>
<li>第一项</li>
<li>第二项</li>
<li>第三项</li>
</ul>
</blockquote>
<h4 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h4><p>有序列表的标记方式是将上述的符号换成数字,并辅以<code>.</code>，如：</p>
<blockquote>
<p>&emsp;&emsp;<code>1. 第一项</code><br>&emsp;&emsp;<code>2. 第二项</code><br>&emsp;&emsp;<code>3. 第三项</code></p>
</blockquote>
<p>效果：</p>
<blockquote>
<ol>
<li>第一项</li>
<li>第二项</li>
<li>第三项</li>
</ol>
</blockquote>
<h4 id="列表嵌套"><a href="#列表嵌套" class="headerlink" title="列表嵌套"></a>列表嵌套</h4><p>列表嵌套只需在子列表中的选项添加四个空格或缩进 TAB 即可，也可在列表内进行区块引用：</p>
<blockquote>
<p>&emsp;&emsp;<code>1. 第一项</code><br>&emsp;&emsp;&emsp;&emsp;<code>- 第一项嵌套的第一个元素</code><br>&emsp;&emsp;&emsp;&emsp;<code>- 第一项嵌套的第二个元素</code><br>&emsp;&emsp;<code>2. 第二项</code><br>&emsp;&emsp;&emsp;&emsp;<code>&gt; 第二项嵌套的第一个元素</code><br>&emsp;&emsp;&emsp;&emsp;<code>&gt; 第二项嵌套的第二个元素</code></p>
</blockquote>
<p>效果：</p>
<blockquote>
<ol>
<li>第一项<ul>
<li>第一项嵌套的第一个元素</li>
<li>第一项嵌套的第二个元素</li>
</ul>
</li>
<li>第二项<blockquote>
<p>第二项第一个元素区块引用<br>第二项第二个元素区块引用</p>
</blockquote>
</li>
</ol>
</blockquote>
<h4 id="GFM-task-list"><a href="#GFM-task-list" class="headerlink" title="GFM task list"></a>GFM task list</h4><p>带选择框的选项列表：</p>
<pre>
- [x] GFM task list 1
- [x] GFM task list 2
- [ ] GFM task list 3
    - [ ] GFM task list 3-1
    - [ ] GFM task list 3-2
    - [ ] GFM task list 3-3
- [ ] GFM task list 4
    - [ ] GFM task list 4-1
    - [ ] GFM task list 4-2
</pre>

<p>效果：</p>
<ul>
<li>[x] GFM task list 1</li>
<li>[x] GFM task list 2</li>
<li>[ ] GFM task list 3<ul>
<li>[ ] GFM task list 3-1</li>
<li>[ ] GFM task list 3-2</li>
<li>[ ] GFM task list 3-3</li>
</ul>
</li>
<li>[ ] GFM task list 4<ul>
<li>[ ] GFM task list 4-1</li>
<li>[ ] GFM task list 4-2</li>
</ul>
</li>
</ul>
<hr>
<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>链接可以由两种形式生成：<strong>行内式</strong>和<strong>参考式</strong>。</p>
<h4 id="行内式"><a href="#行内式" class="headerlink" title="行内式"></a>行内式</h4><p>方式为<code>[链接名称](链接地址)</code>或<code>&lt;链接地址&gt;</code></p>
<blockquote>
<p><code>这是一个链接 [github treading](https://github.com/trending)</code><br><code>这是另一个链接 &lt;https://github.com/explore&gt;</code></p>
</blockquote>
<p>效果：</p>
<blockquote>
<p>这是一个链接 <a href="https://github.com/trending" target="_blank" rel="noopener">github treading</a><br>这是另一个链接 <a href="https://github.com/explore" target="_blank" rel="noopener">https://github.com/explore</a></p>
</blockquote>
<h4 id="参考式"><a href="#参考式" class="headerlink" title="参考式"></a>参考式</h4><p>链接也可以用变量（数字或字符串）来代替：</p>
<blockquote>
<p><code>这是一个链接 [github treading][1]</code><br><code>这是另一个链接 [github explore][explore]</code><br><del><strong>(上下之间必须有空行)</strong></del><br><code>[1]:https://github.com/trending</code><br><code>[explore]:https://github.com/explore</code></p>
</blockquote>
<p>效果：</p>
<blockquote>
<p>这是一个链接 [github treading][1]<br>这是另一个链接 [github explore][explore]</p>
<p>[1]:<a href="https://github.com/trending" target="_blank" rel="noopener">https://github.com/trending</a> &gt; [explore]:<a href="https://github.com/explore" target="_blank" rel="noopener">https://github.com/explore</a></p>
</blockquote>
<p><strong>注意</strong>：上述的<code>[1]:https://github.com/trending</code>不出现在区块中。</p>
<hr>
<h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><hr>
<p>添加图片的形式和链接相似，只需在链接的基础上前方加一个<code>！</code>，支持行内式和参考式。如上文<strong>Aaron Swartz</strong>的图片链接:</p>
<blockquote>
<p><code>![Aaron Swartz](https://github.com/younghz/Markdown/raw/master/resource/Aaron_Swartz.jpg)</code></p>
</blockquote>
<hr>
<h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><p>使用<code>|</code>来分隔不同的单元格，使用<code>-</code>来分隔表头和其他行。使用<code>-:</code>，<code>:-</code>，<code>:-:</code>设置表格的对齐方式：</p>
<blockquote>
<p><code>| 这是左对齐 | 这是右对齐 | 这是居中对齐 |</code><br><code>| :--------- | ---------: | :----------: |</code><br><code>| 单元格 | 单元格 | 单元格 |</code><br><code>| 单元格 | 单元格 | 单元格 |</code></p>
</blockquote>
<p>效果：</p>
<blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">这是左对齐</th>
<th style="text-align:right">这是右对齐</th>
<th style="text-align:center">这是居中对齐</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">单元格</td>
<td style="text-align:right">单元格</td>
<td style="text-align:center">单元格</td>
</tr>
<tr>
<td style="text-align:left">单元格</td>
<td style="text-align:right">单元格</td>
<td style="text-align:center">单元格</td>
</tr>
</tbody>
</table>
</div>
</blockquote>
<hr>
<h3 id="反斜杠"><a href="#反斜杠" class="headerlink" title="反斜杠"></a>反斜杠</h3><hr>
<p><strong>反转义</strong>，使符号成为普通符号。</p>
<pre>
\\    反斜线 
\`    反引号
\*    星号 
\_    下划线
\{\}  花括号
\[\]  方括号
\(\)  小括号
\#    井字号
\+    加号
\-    减号
\.    英文句点
\!    感叹号
\!    感叹号
</pre>

<p>效果</p>
<blockquote>
<p>\ 反斜线<br>` 反引号<br>* 星号<br>_ 下划线<br>\{\} 花括号<br>[] 方括号<br>() 小括号<br># 井字号<br>+ 加号<br>- 减号<br>. 英文句点<br>! 感叹号</p>
</blockquote>
<hr>
<h3 id="符号"><a href="#符号" class="headerlink" title="符号`"></a>符号`</h3><hr>
<p>起到标记作用。如：</p>
<blockquote>
<p>`ctrl+a`</p>
</blockquote>
<p>效果：</p>
<blockquote>
<p><code>ctrl+a</code></p>
</blockquote>
<hr>
<h2 id="其他语法"><a href="#其他语法" class="headerlink" title="其他语法"></a>其他语法</h2><hr>
<p>使用两个美元符$$$$包裹<strong>TeX</strong>或<strong>LaTeX</strong>格式的数学公式来实现。</p>
<hr>
<hr>
<p><strong>其他</strong>：关于其它扩展语法可参见具体工具的使用说明。</p>
<hr>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><hr>
<p><a href="https://www.runoob.com/markdown/md-tutorial.html" target="_blank" rel="noopener">https://www.runoob.com/markdown/md-tutorial.html</a><br><a href="https://markdown.tw" target="_blank" rel="noopener">https://markdown.tw</a><br><a href="https://github.com/younghz/Markdown" target="_blank" rel="noopener">https://github.com/younghz/Markdown</a></p>
<hr>
<hr>
<p><strong>_笔下是语法，心中格式化_</strong></p>
<hr>
]]></content>
      <categories>
        <category>Tutorial</category>
      </categories>
      <tags>
        <tag>Tutorial</tag>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序开发-布局flex</title>
    <url>/posts/208261819/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>微信小程序开发-布局 flex</p>
<a id="more"></a>
<h2 id="flex布局"><a href="#flex布局" class="headerlink" title="flex布局"></a><strong><code>flex</code>布局</strong></h2><p>微信小程序 <code>View</code> 支持两种布局方式：<code>Block</code> 和 <code>Flex</code><br>所有 <code>View</code> 默认都是 <code>block</code>。要使用 flex 布局的话需要显式的声明。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">"main"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">"item item1"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">"item item2"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">"item item3"</span>&gt;</span>3<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>1) 未设置 <code>flex</code>，竖向布局</strong></p>
<pre><code>1
2
3
</code></pre><p><strong>2) <code>flex</code> 布局，在样式中加入 <code>display: flex;</code></strong></p>
<pre><code>123
</code></pre><h2 id="flex-direction"><a href="#flex-direction" class="headerlink" title="flex-direction"></a><strong><code>flex-direction</code></strong></h2><h3 id="横向布局"><a href="#横向布局" class="headerlink" title="横向布局"></a>横向布局</h3><ul>
<li><code>flex-direction: row</code>：从左到右的水平方向为主轴</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">123</span><br></pre></td></tr></table></figure>
<ul>
<li><code>flex-direction: row-reverse</code>：从右到左的水平方向为主轴</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">321</span><br></pre></td></tr></table></figure>
<h2 id="justify-content"><a href="#justify-content" class="headerlink" title="justify-content"></a><strong><code>justify-content</code></strong></h2><p>横向的布局属性</p>
<ul>
<li><code>lex-start</code>：主轴起点对齐(默认值)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">123</span><br></pre></td></tr></table></figure>
<ul>
<li><code>flex-end</code>：主轴结束点对齐</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">123</span><br></pre></td></tr></table></figure>
<ul>
<li><code>center</code>：在主轴中居中对齐</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">123</span><br></pre></td></tr></table></figure>
<ul>
<li><code>space-between</code>：两端对齐，除了两端的子元素分别靠向两端的容器之外，其他子元素之间的间隔都相等</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1        2        3</span><br></pre></td></tr></table></figure>
<ul>
<li><code>space-around</code>：每个子元素之间的距离相等，两端的子元素距离容器的距离也和其它子元素之间的距离相同</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1      2      3</span><br></pre></td></tr></table></figure>
<h3 id="纵向布局"><a href="#纵向布局" class="headerlink" title="纵向布局"></a>纵向布局</h3><ul>
<li><code>flex-direction: column</code>：从上到下的垂直方向为主轴</li>
<li><code>flex-direction: column-reverse</code>：从下到上的垂直方向为主轴</li>
</ul>
<h2 id="align-items"><a href="#align-items" class="headerlink" title="align-items"></a><strong><code>align-items</code></strong></h2><p>纵向布局属性：</p>
<ul>
<li><code>stretch</code> 填充整个容器(默认值)</li>
<li><code>flex-start</code> 侧轴的起点对齐 （这里我们手动设置下子 view 的高度，来看的明显一些）</li>
<li><code>flex-end</code> 侧轴的终点对齐</li>
<li><code>center</code> 在侧轴中居中对齐</li>
<li><code>baseline</code> 以子元素的第一行文字对齐</li>
</ul>
<h2 id="align-self"><a href="#align-self" class="headerlink" title="align-self"></a><strong><code>align-self</code></strong></h2><p>子 <code>View</code> 的属性 <code>align-self</code>，可以覆盖父元素的 <code>align-items</code> 属性，它有 6 个值可选：<code>auto | flex-start | flex-end | center | baseline | stretch</code> （ <code>auto</code> 为继承父元素 <code>align-items</code> 属性，其他和 <code>align-items</code> 一致）</p>
<h2 id="flex-wrap"><a href="#flex-wrap" class="headerlink" title="flex-wrap"></a><strong><code>flex-wrap</code></strong></h2><p>用于控制子 <code>View</code> 是否换行</p>
<ul>
<li><code>nowrap</code> ：不换行（默认）</li>
<li><code>wrap</code> ：换行</li>
<li><code>wrap-reverse</code> ：换行，第一行在最下面</li>
</ul>
<h2 id="order"><a href="#order" class="headerlink" title="order"></a><strong><code>order</code></strong></h2><p>控制子元素的排列顺序，默认为<code>0</code>。<br>把 <code>item3</code> 设置 <code>order:-1;</code> 可以把 <code>item3</code> 排在前面</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">312</span><br></pre></td></tr></table></figure>
<h2 id="flex-grow"><a href="#flex-grow" class="headerlink" title="flex-grow"></a><strong><code>flex-grow</code></strong></h2><p><code>.wxss</code>中修改代码如下：在 <code>item1</code> 中增加： <code>flex-grow: 1</code>，在 <code>item3</code> 中增加： <code>flex-grow: 2``，表示在一行中如果有剩余空间的话，item3</code> 之外的子 <code>view</code> 占 1 份空间，而 <code>item3</code> 子 <code>view</code> 占 2 份空间(可以理解为剩余空间 <code>item3</code> 最多可以占 2 份空间)。</p>
<h2 id="flex-shrink"><a href="#flex-shrink" class="headerlink" title="flex-shrink"></a><strong><code>flex-shrink</code></strong></h2><p><code>.wxss</code>中再增加 4 个子 <code>view</code> 并修改代码如下：<code>i3</code> 的<code>flex-shrink: 0</code>，其余子 <code>view</code> 为 <code>flex-shrink: 1</code>，这表示当空间不足时所有子 <code>view</code> 都等比缩小，但是 <code>i3</code> 的 <code>view</code> 保持大小不变.</p>
<h2 id="flex-basis"><a href="#flex-basis" class="headerlink" title="flex-basis"></a><strong><code>flex-basis</code></strong></h2><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a><strong>注意</strong></h2><p><code>flex</code> 是 <code>grow</code> ，<code>shrink</code> ，<code>basis</code> 几个属性的合并</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: grow shrink basis;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>flex-flow</code> 是 <code>flex-direction</code> 和 <code>flex-wrap</code> 两个属性的组合</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"> &#123;</span><br><span class="line">  <span class="attribute">flex-flow</span>: wrap row;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>微信小程序开发</category>
      </categories>
      <tags>
        <tag>wechat-dev</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序开发-input正则</title>
    <url>/posts/1318413979/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>检查 <code>input</code>输入框是否输入限制字符。如果是，则丢弃；否则，正常输入。</p>
<a id="more"></a>
<p><code>input</code> 标签具有 <code>bindinput</code> 属性，支持输入数据的双向绑定，类似 <code>Vue</code> 中的 <code>v-model</code>。</p>
<blockquote>
<p>键盘输入时触发，<code>event.detail = {value, cursor, keyCode}，keyCode</code> 为键值，2.1.0 起支持，处理函数可以直接 return 一个字符串，将替换输入框的内容。</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"digit"</span> <span class="attr">bindinput</span>=<span class="string">"regInput"</span> <span class="attr">maxlength</span>=<span class="string">"15"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>匹配正则通过则返回所有字符，不通过则去掉最后一个不匹配的字符返回。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*正则匹配*/</span></span><br><span class="line">regInput(e)&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="regexp">/^(\d?)+(\.\d&#123;0,2&#125;)?$/</span>.test(e.detail.value))&#123;</span><br><span class="line">    <span class="keyword">return</span> e.detail.value;</span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> e.detail.value.substring(<span class="number">0</span>,e.detail.value.length<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.jb51.net/article/145878.htm" target="_blank" rel="noopener">https://www.jb51.net/article/145878.htm</a></p>
]]></content>
      <categories>
        <category>微信小程序开发</category>
      </categories>
      <tags>
        <tag>wechat-dev</tag>
      </tags>
  </entry>
  <entry>
    <title>路径规划-RRT</title>
    <url>/posts/2955947163/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="路径规划之-Rapidly-Exploring-Random-Trees-快速扩展随机树"><a href="#路径规划之-Rapidly-Exploring-Random-Trees-快速扩展随机树" class="headerlink" title="路径规划之 Rapidly-Exploring Random Trees (快速扩展随机树)"></a>路径规划之 Rapidly-Exploring Random Trees (快速扩展随机树)</h1><p>RRTs 作为一种 single-query 的规划算法被引入，它有效地覆盖了 q~init~ 和 q~goal~ 之间的空间。该规划器最初也是为 kinodynamic 运动规划而开发的，就像在 ESTs 中一样，只构建一棵树。RRTs 的适用范围超出了 kinodynamic 规划问题。RRT 算法已被证明是概率完备的。</p>
<a id="more"></a>
<p><img data-src="rrt.gif" alt="rrt.gif"></p>
<h2 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h2><p>$T$表示一颗树。 $T_{init}$ 和 $T_{goal}$ 根节分别为 $q_{init}$ 和 $q_{goal}$ 的树。每棵树$T$都是增量扩展的。在每次迭代中，在 $Q_{free}$ 中随机均匀采样一点 $q_{rand}$ 。在$T$中找到距离 $q_{rand}$ 最近的节点 $q_{near}$ ，并尝试从 $q_{near}$ 向 $q_{rand}$ 方向移动一段距离 $step_size$ ，生成一个新节点 $q_{new}$ 。若该节点是无碰撞的(collision-free)，则添加节点 $q_{new}$ 到 $T$ 的顶点集合(vertices)中，添加 $(q_{near}, q_{new})$ 到 $T$ 的边集合(edges)中。下图展示了 RRT 在二维欧式空间扩展一个点的过程。</p>
<p><img data-src="algorithm_rrt_extension.png" alt="Figure 7.14"></p>
<h3 id="伪码"><a href="#伪码" class="headerlink" title="伪码"></a>伪码</h3><p><img data-src="algorithm_rrt.png" alt="Algorithms RRT"></p>
<h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><ol>
<li>初始化随机树，树结点和边只包含起点 $q_{start}$（根节点）。边和书中有一点区别，因为这里的节点用了一个链表结构，这里每个扩展节点 ($q_{new}$) 包含有一个后向指针，指向源节点 ($q_{near}$)，所以不需要单独定义边。只要构造出树，最后反向遍历即可完成路径的构造。</li>
<li>起始点 start 加入到树节点和边中</li>
<li>开始迭代</li>
<li><code>GenerateRandomNode()</code>: 在状态空间（机械臂的关节空间或者笛卡尔空间；小车可达的二维地图空间）中随机采样一个点 $q_{rand}$ 。为加快 RRT 到达目标点 $q_{goal}$ 的速度，在随机采样过程中，加随机的概率 p 来决定，此次扩展的目标点 $q_{goal}$ 是随机点还是目标点 $q_{goal}$ 。当 $0\ltp prob$ 时，取随机采样点；否则取目标点 $q_{goal}$ 。这个概率不宜过大，否则容易陷入障碍物包围圈中不容易跳出。</li>
<li><code>FindNearestNode(qrand)</code>: 遍历 RRT 树节点，返回距离 $q_{rand}$ 最近的一个节点 $q_{near}$</li>
<li><code>ExtendTree(qnear, qrand)</code>: 沿着 $(q_{near}, q_{rand})$ 方向，以一定的步长 $step_size$ 扩展一个新节点 $q_{new}$, 如果扩展不成功（超出地图范围），返回 None，放弃这次扩展。</li>
<li><code>CollsionFree(qnear, qnew)</code>: 对 $(q_{near}, q_{new})$ 路径进行碰撞检查，包括路径过程中及起始点是否有障碍物。这里采用等间距采样，检查路径中位置点所处网格是否包络障碍物。如果发生碰撞，则放弃扩展。</li>
<li>如果新节点 $q_{new}$ 被接受（新节点不为<code>None</code>且与 $(q_{near}, q_{new})$ 之间的路径无碰撞），则将该点加入到树中，并将该节点的后向指针 $q_{new}.parent$ 指向 $q_{near}$ 。这样，在找到目标点时，根据该指针，可遍历得到完整的路径。为了防止树节点过多，可以再检查$q_{new}$是否与树中某个节点过于接近（一般取小于扩展步长），如果是，则也可以放弃此次扩展。但是这也会导致算法时间增长，毕竟要遍历树节点计算距离。</li>
<li><code>IsArrival(qnew)</code>: 检查是否到达目标点 $q_{goal}$ , 如果新节点 $q_{new}$ 距离目标点 $q_{goal}$ 小于扩展步长 $step_size$ ，且无碰撞，则认为找到，将目标点 $q_{goal}$ 作为树的最后一个节点添加到 RRT 树中。</li>
<li><code>FindPath()</code>: 根据目标节点 $q_{goal}$ 的反向指针，遍历至起点 $q_{start}$ ，即完成路径的构造。</li>
<li><code>SmoothPath(path)</code>: 上一步的路径是按照步长一个节点一个节点扩展的，因此这里可以对路径进行圆滑，遍历路径的节点，取最长不碰撞的节点构造新路径。</li>
</ol>
<h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, pos=[<span class="number">0</span>, <span class="number">0</span>])</span>:</span></span><br><span class="line">        self.pos = pos</span><br><span class="line">        self.parent = <span class="literal">None</span></span><br></pre></td></tr></table></figure>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">map_path: 地图图片路径</span></span><br><span class="line"><span class="string">qstart: 起点坐标 [row, col]</span></span><br><span class="line"><span class="string">qgoal: 目标点坐标 [row, col]</span></span><br><span class="line"><span class="string">grid_size: 网格大小（用来碰撞检测）</span></span><br><span class="line"><span class="string">step_size: 扩展步长</span></span><br><span class="line"><span class="string">max_steps: 最大扩展节点数</span></span><br><span class="line"><span class="string">goal_prob: 增加趋向目标点概率（贪婪）</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">rrt = RRT(map_path, qstart, qgoal, grid_size,</span><br><span class="line">          step_size, max_steps, goal_prob)</span><br></pre></td></tr></table></figure>
<h3 id="Planning"><a href="#Planning" class="headerlink" title="Planning"></a>Planning</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Planning</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    rrt planning</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    self.AddVertices(self.qstart)</span><br><span class="line">    self.AddEdges(<span class="literal">None</span>, self.qstart)</span><br><span class="line"></span><br><span class="line">    k = <span class="number">-1</span></span><br><span class="line">    <span class="keyword">while</span> k &lt; self.max_steps:</span><br><span class="line">        k += <span class="number">1</span></span><br><span class="line">        qrand = self.GenerateRandomNode()</span><br><span class="line">        _, qnear = self.FindNearestNode(qrand)</span><br><span class="line">        qnew = self.ExtendTree(qnear, qrand)</span><br><span class="line">        <span class="keyword">if</span> qnew <span class="keyword">and</span> self.CollsionFree(qnear, qnew):</span><br><span class="line">            self.AddVertices(qnew)</span><br><span class="line">            self.AddEdges(qnear, qnew)</span><br><span class="line"></span><br><span class="line">            self.DrawEdges(qnear, qnew)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.IsArrival(qnew):</span><br><span class="line">                print(<span class="string">"Found"</span>)</span><br><span class="line">                self.AddVertices(self.qgoal)</span><br><span class="line">                self.AddEdges(qnew, self.qgoal)</span><br><span class="line"></span><br><span class="line">                path = self.FindPath()</span><br><span class="line">                self.DrawPath(path)</span><br><span class="line">                smooth_path = self.SmoothPath(path)</span><br><span class="line">                self.DrawPath(smooth_path)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    print(<span class="string">'Not Found'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>路径规划</category>
      </categories>
      <tags>
        <tag>路径规划</tag>
        <tag>motion planning</tag>
        <tag>RRT</tag>
      </tags>
  </entry>
  <entry>
    <title>路径规划-A_Star</title>
    <url>/posts/1627378678/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="路径规划之-A-Star-A"><a href="#路径规划之-A-Star-A" class="headerlink" title="路径规划之 A_Star (A*)"></a>路径规划之 A_Star (A*)</h1><p>A*算法是一种基于启发式搜索的算法，该算法综合了 BFS(最佳优先搜索)和 Dijkstra 算法的优点：在进行启发式搜索提高算法效率的同时，可以保证找到一条最优路径。</p>
<a id="more"></a>
<p><img data-src="a_star.gif" alt="a_star.gif"></p>
<h2 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h2><p>A*算法扩展路径时，在主循环的每次迭代中，基于路当前节点到起点的成本以及将路径一直扩展到目标所需的估计成本来执行此操作。即选择最小化路径:</p>
<blockquote>
<p>$f(n)=g(n)+h(n)$</p>
</blockquote>
<p>随着路径的扩展，以扩展到的但未计算的节点放入列表 $open_table$ , 完成计算的节点放入列表 $close_table$。算法每次从 $open_table$ 中选择 $f(n)$ 最小的节点作为当前节点开始扩展。一直到找到目标点或者达到最大搜索次数而终止。</p>
<p>该公式包含有一下特征：</p>
<blockquote>
<p>如果$g(n)=0$, 即只计算当前节点<code>n</code>到目标节点<code>goal</code>的估计函数$h(n)$, 而不计算起点<code>start</code>到当前节点<code>n</code>的距离，算法转换为使用贪心策略的最佳优先搜索(BFS), 搜索速度提高，但是路径不是最优的<br>如果$h(n)$不大于当前节点<code>n</code>到目标节点<code>goal</code>的实际距离，则一定能得到最优解， 且$h(n)$越小，需要计算的节点越多，算法速度降低。<br>如果$h(n)=0$, 即只需求出起点<code>start</code>到当前节点<code>n</code>的最短路径$g(n)$，而不计算任何评估函数$h(n)$，则转化为单源最短路径问题，即 Dijkstra 算法，此时需要计算最多的顶点.</p>
</blockquote>
<p>其中：</p>
<blockquote>
<p>$f(n)$: 目标函数, 规划过程即最小化 f(n)；<br>$g(n)$: 起点$start$到当前节点$n$的实际距离；<br>$h(n)$: 启发函数, 当前节点$n$到终点$goal$的估计距离；<br>$open_table$: 记录需要搜寻过的节点列表<br>$close_table$: 记录已经被搜寻过的节点列表</p>
</blockquote>
<p>常用的启发函数$h(n)$一般有:</p>
<ul>
<li><p>曼哈顿距离:</p>
<blockquote>
<p>$d_{mahattan}=|p1.x-p2.x|+|p1.y-p2.y|$</p>
</blockquote>
</li>
<li><p>切比雪夫距离:</p>
<blockquote>
<p>$d_{chebyshev}=max(|p1.x-p2.x|,|p1.y-p2.y|)$</p>
</blockquote>
</li>
<li><p>欧式距离:</p>
<blockquote>
<p>$d_{euclidean}=\sqrt{(p1.x-p2.x)^2+(p1.y-p2.y)^2}$</p>
</blockquote>
</li>
<li><p>对角距离:</p>
<blockquote>
<p>$d_{diagonal}=(|p1.x-p2.x|+|p1.y-p2.y|)+\sqrt{2}-2\times min(|p1.x-p2.x|,|p1.y-p2.y|)$</p>
</blockquote>
</li>
</ul>
<h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><ul>
<li><p>初始化<code>A_STAR.__init__</code>: 初始化地图，对地图图片二值化处理，网格节点划分，若网格内包含障碍物，则该网格节点标记为障碍物: <code>Node.is_obs = True</code></p>
</li>
<li><p>输入需要随机产生的障碍物网格个数(可选);</p>
</li>
<li><p>计算起点<code>qstart</code>的$h$,$g$,$f$值,这里选择 $h=d_{mahattan}$, $g=d_{diagonal}$计算.将节点放入<code>open_table</code></p>
</li>
<li><p>开始迭代, 若迭代次数达到上限或者<code>open_table</code>为空, 则退出迭代：</p>
<ul>
<li><p>从<code>open_table</code>列表中选择<code>f</code>值最小的节点作为当前节点,记为<code>best_node</code></p>
</li>
<li><p>若<code>best_node</code>为目标节点<code>goal</code>, 即找到目标, 遍历<code>best_node</code>的父节点链表并逆序, 得到完整路径, 退出算法. 否则继续下一步:</p>
</li>
<li><p>将<code>best_node</code>从<code>open_table</code>列表弹出, 并放入<code>close_table</code>列表中.</p>
</li>
<li><p>搜索<code>best_node</code>的 8 个邻接节点<code>Neighbors</code>,对其中每个邻接节点<code>neighbor</code>:</p>
<ul>
<li><p>若该<code>neighbor</code>在<code>close_table</code>中,或者不可达, 则跳过该<code>neighbor</code>,检查下一个邻接节点, 否则继续下一步:</p>
</li>
<li><p>计算该<code>neighbor</code>的新<code>g</code>值(<code>tentative_g</code>), 即为当前节点<code>best_node</code>的<code>g</code>值加上, 当前节点<code>best_node</code>到该邻接节点<code>neighbor</code>的实际距离:<br><code>tentative_g = best_node.g + Distance(best_node, neighbor)</code></p>
</li>
<li><p>若该<code>neighbor</code>不在<code>open_table</code>中, 计算该<code>neighbor</code>的<code>g</code>, <code>h</code>, <code>f</code>值, 并放入<code>open_table</code>中</p>
</li>
<li><p>若该<code>neighbor</code>在<code>open_table</code>中:</p>
<ul>
<li><p>若该邻接节点<code>neighbor</code>新的<code>tentative_g</code>值比已有的<code>g</code>值小, 意味着当前节点<code>best_node</code>通过该<code>neighbor</code>可以更快的到达终点.</p>
</li>
<li><p>更新该<code>neighbor</code>节点的<code>g</code>值为<code>tentative_g</code>,并更新<code>f</code>值</p>
</li>
<li><p>更新该该<code>neighbor</code>节点的父节点为当前节点<code>best_node</code>.</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, pos)</span>:</span></span><br><span class="line">        self.pos = pos          <span class="comment"># 当前节点的位置坐标</span></span><br><span class="line">        self.g = float(<span class="string">'inf'</span>)   <span class="comment"># 当前节点的g(n),g_score</span></span><br><span class="line">        self.h = float(<span class="string">'inf'</span>)   <span class="comment"># 当前节点的的h(n),h_score</span></span><br><span class="line">        self.f = float(<span class="string">'inf'</span>)   <span class="comment"># 当前节点的的f(n), f_score</span></span><br><span class="line">        self.p = <span class="literal">None</span>           <span class="comment"># 当前节点的父节点</span></span><br><span class="line">        self.is_obs = <span class="literal">False</span>     <span class="comment"># 当前节点是否是障碍物</span></span><br></pre></td></tr></table></figure>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">map_path:   地图图片路径</span></span><br><span class="line"><span class="string">qstart:     起点坐标 [row, col]</span></span><br><span class="line"><span class="string">qgoal:      目标点坐标 [row, col]</span></span><br><span class="line"><span class="string">grid_size:  网格大小（用来碰撞检测）</span></span><br><span class="line"><span class="string">max_steps:  最大扩展节点数</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">a_star = A_STAR(map_path, qstart, qgoal, grid_size, max_steps)</span><br></pre></td></tr></table></figure>
<h3 id="Planning"><a href="#Planning" class="headerlink" title="Planning"></a>Planning</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Planning</span><span class="params">(self)</span>:</span></span><br><span class="line"></span><br><span class="line">    color_close = (random.randint(<span class="number">0</span>, <span class="number">255</span>),</span><br><span class="line">                   random.randint(<span class="number">0</span>, <span class="number">255</span>),</span><br><span class="line">                   random.randint(<span class="number">0</span>, <span class="number">255</span>))</span><br><span class="line"></span><br><span class="line">    color_open = (random.randint(<span class="number">0</span>, <span class="number">255</span>),</span><br><span class="line">                  random.randint(<span class="number">0</span>, <span class="number">255</span>),</span><br><span class="line">                  random.randint(<span class="number">0</span>, <span class="number">255</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># input numbers of obstacle grid if necessary</span></span><br><span class="line">    num = input(<span class="string">"input obstacle numbers: "</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        input_num = eval(num)</span><br><span class="line">        <span class="keyword">if</span> type(input_num) == int:</span><br><span class="line">            obstacle_set = self.AddObstacle(input_num)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># init qstart node</span></span><br><span class="line">    self.qstart.g = <span class="number">0</span></span><br><span class="line">    self.qstart.h = self.HScore(self.qstart)</span><br><span class="line">    self.qstart.f = self.FScore(self.qstart)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># init open_table and close_table</span></span><br><span class="line">    self.open_table = set()</span><br><span class="line">    self.close_table = set()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># add start node into open_table</span></span><br><span class="line">    self.open_table.add(self.qstart)</span><br><span class="line"></span><br><span class="line">    k = <span class="number">-1</span></span><br><span class="line">    <span class="keyword">while</span> k &lt; self.max_steps <span class="keyword">or</span> len(self.open_table) != <span class="number">0</span>:</span><br><span class="line"></span><br><span class="line">        <span class="comment"># get the node in open_table having the lowest f_score value</span></span><br><span class="line">        best_node = min(self.open_table, key=<span class="keyword">lambda</span> node: node.f)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># reach the goal node</span></span><br><span class="line">        <span class="keyword">if</span> best_node.pos == self.qgoal.pos:</span><br><span class="line">            print(<span class="string">"Found"</span>)</span><br><span class="line">            self.FindPath()</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># remove the best node in open table and add it into close table</span></span><br><span class="line">        self.open_table.remove(best_node)</span><br><span class="line">        self.close_table.add(best_node)</span><br><span class="line">        self.DrawGrid(best_node.pos, color_close)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># traversal the neighbors of best node</span></span><br><span class="line">        <span class="keyword">for</span> neighbor <span class="keyword">in</span> self.Neighbors(best_node):</span><br><span class="line"></span><br><span class="line">            <span class="comment"># if neighbor is in close table or is collision, skip</span></span><br><span class="line">            <span class="keyword">if</span> neighbor <span class="keyword">in</span> self.close_table <span class="keyword">or</span> self.CollisionFree(best_node, neighbor) == <span class="literal">False</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># calculate the tentative_g which is the distance from start to the neighbor through best_node</span></span><br><span class="line">            tentative_g = self.GScore(best_node, neighbor)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># check the neighbor is in open table or not</span></span><br><span class="line">            <span class="keyword">if</span> neighbor <span class="keyword">not</span> <span class="keyword">in</span> self.open_table:</span><br><span class="line">                <span class="comment"># if neighbor not in open table,</span></span><br><span class="line">                <span class="comment"># then calculate the g, h, f values and add it into open table</span></span><br><span class="line">                neighbor.g = tentative_g</span><br><span class="line">                neighbor.h = self.HScore(neighbor)</span><br><span class="line">                neighbor.f = self.FScore(neighbor)</span><br><span class="line">                neighbor.p = best_node</span><br><span class="line">                self.open_table.add(neighbor)</span><br><span class="line">                self.DrawGrid(neighbor.pos, color_open)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># if neighbor in open table,</span></span><br><span class="line">                <span class="comment"># then compare the tentative_g and neighbor.g</span></span><br><span class="line">                <span class="keyword">if</span> tentative_g &lt; neighbor.g:</span><br><span class="line">                    <span class="comment"># the path from best_node to neighbor is better than previous</span></span><br><span class="line">                    neighbor.g = tentative_g</span><br><span class="line">                    neighbor.f = self.FScore(neighbor)</span><br><span class="line">                    neighbor.p = best_node</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"Not Found"</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>路径规划</category>
      </categories>
      <tags>
        <tag>路径规划</tag>
        <tag>motion planning</tag>
        <tag>A*</tag>
      </tags>
  </entry>
  <entry>
    <title>路径规划-LPA_Star</title>
    <url>/posts/367356294/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="路径规划之-LPA-Star-LPA"><a href="#路径规划之-LPA-Star-LPA" class="headerlink" title="路径规划之 LPA_Star (LPA*)"></a>路径规划之 LPA_Star (LPA*)</h1><p>LPA*是 A*的增量版本. 相比于 A*算法, 首次规划时, 两者过程类似. 假如地图发生变化, A*算法需要重新规划路径. 而 LPA*算法可以通过在当前搜索期间内更新前一次搜索的 g 值（距起始距离）来适应地图变化而无需重新计算整个地图。</p>
<a id="more"></a>
<p><img data-src="lpa_star.gif" alt="lpa_star.gif"></p>
<h2 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h2><p>局部连续（Locally Consistent）：$g(s)=rhs(s)$。当所有节点均为局部连续状态时，g(s)的值等于 s 到起始点的最短距离（注意，反向不成立）。这个概念很重要，当上述条件满足时，我们可以找到任意一点 u 到起始点的最短路径，假设当前位置为 s,父辈节点 s’(向着起始点前进的下一个节点)通过最小化(g(s’)+c(s,s’))来获得，不断重复直到到达 sStart。然而，LPA*并不需要使所有节点均为局部连续状态，它通过启发式搜索将关注点放在搜索上，并且只更新那些与计算最短路径相关的节点的 g 值。</p>
<p>局部过连续（Locally Overconsistent）：$g(s)&gt;rhs(s)$。当优先队列 U 中取出的节点为局部过连续状态时，意味着 g(s)可以通过父辈节点使自己到起点的路径更短，此时将设置 g(s)=rhs(s)，节点状态变为局部连续状态。</p>
<p>局部欠连续(Locally Underconsistent)：$g(s)&lt;rhs(s)$。这种情况通常出现在父辈的某一节点突然变为障碍的情况下，造成父辈节点到起点的路径变大，从而需要修改 g(s)的值，如果节点处于这种状态，则当它由优先队列中取出时，将其 g 值设置为无穷大，即将该节点状态变为局部过连续，而局部过连续的点将会被再次添加到优先队列中，这样就可以在它下次被取出时将其作为局部过连续状态处理，最终达到局部连续状态（如果这一节点与我们要搜索的最短路径相关的话）。</p>
<p>LPA*维持着每个节点的到起点的估计距离: <a href="algorithm_lpa_star_g.png">$g(s)$</a> 首次搜索时, $g(s)$ 的计算方式和 A*相同, 并将这个值带到下次搜索过程中.<br><img data-src="algorithm_lpa_star_g.png" alt="algorithm_lpa_star_g"></p>
<p>此外 LPA*还维护着一个基于 $g(s)$ 的前瞻估计距离: <a href="algorithm_lpa_star_rhs.png">$rhs(s)$</a>.<br><img data-src="algorithm_lpa_star_rhs.png" alt="algorithm_lpa_star_rhs"></p>
<p>A*算法维护着 OPEN 和 CLOSED 列表来避免节点被重复搜索. LPA*通过检查局部一致性来避免节点重复搜索, 不需要维护 COLSED 列表. OPEN 列表是一个优先队列, 使得 A*可以通过队列中具有最小 $f(s)$ 值的节点来进行边的扩展. LPA*也维持着一个只包含局部欠一致(locally inconsistent)节点的优先队列. 优先队列根据节点的 keys 值排列(相当于 A*的 $f(s)$ 值排列). 该 keys 是一个二维变量:</p>
<blockquote>
<p>$k(s)=[k1(s),k2(s)]$</p>
</blockquote>
<p>其中:</p>
<blockquote>
<p>$k1(s)=min(g(s),rhs(s)+h(s))$, 相当于 A*的$f(s)$ &gt; $k2(s)=min(g(s),rhs(s))$, 相当于 A*的$g(s)$</p>
</blockquote>
<p>定义: $k(s1) \leq (s2)$ 为 $k1(s1) \leq k1(s2)$ 或者 $(k1(s1)=k1(s2) \text{ and }k2(s1) \leq k2(s2))$</p>
<h3 id="伪码"><a href="#伪码" class="headerlink" title="伪码"></a>伪码</h3><p>算法伪码如下图所示 <a href="algorithm_lpa_star.png">Algorithms LAP*</a><br><img data-src="algorithm_lpa_star.png" alt="3"></p>
<h3 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h3><p><a href="algorithm_lpa_star_first_search.png">第一次搜索</a><br><img data-src="algorithm_lpa_star_first_search.png" alt="4"></p>
<p><a href="algorithm_lpa_star_secord_search.png">第二次搜索</a><br><img data-src="algorithm_lpa_star_secord_search.png" alt="5"></p>
<h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><ul>
<li><p>初始化<code>LPA_STAR.__init__</code>: 初始化地图，对地图图片二值化处理，网格节点划分，若网格内包含障碍物，则该网格节点标记为障碍物: <code>Node.is_obs = True</code></p>
</li>
<li><p>输入需要随机产生的障碍物网格个数(可选);</p>
</li>
<li><p><code>Initialize()</code>: 初始化所有节点的$g(s)=\infin$, $rhs(s)=\infin$, 实际实现中，不需要初始化所有节点，只需要在遇到一个新节点时初始化该节点. 起点$s_{start}$是一个局部欠一致节点, 计算$keys(s_{start})$, 并将节点$s_{start}$放入优先队列中.</p>
</li>
<li><p>初始化<code>Initialize()</code>保证了首次调用<code>ComputeShortestPath()</code>是一个 A*算法。</p>
</li>
<li><p>等待地图更新， 这里通过用户输入障碍物网格数来模拟地图更新。</p>
</li>
<li><p>地图更新时，导致节点之间的距离<code>DistanceCost</code>发生变化, 调用<code>UpdateVertex(s)</code>更新受影响节点参数<code>rhs</code>和<code>keys</code>。这也这些节点和优先队列之间的联系也发生变化，可能成为局部一致或者局部不一致状态。</p>
</li>
<li><p>重新调用<code>ComputeShortestPath()</code>来根据优先队列顺序展开局部不一致的节点。</p>
<ul>
<li><p>如果展开的节点处于局部过一致(<code>locally overconsistent</code>)状态, 即$g(s)&gt;rhs(s)$, 那么将该节点设置为局部一致(<code>locally consistent</code>), 即$g(s)=rhs(s)$。</p>
</li>
<li><p>如果展开的节点处于局部欠一致(<code>locally underconsistent</code>)状态，即$g(s)&lt;rhs(s)$, 那么将该节点的<code>g</code>值设置为无穷大， 即$g(s)=\infin$</p>
</li>
<li><p>上述两种情况中受该展开节点的<code>g</code>值变化会影响后置节点，所以还需要更新受其影响的节点，调用<code>UpdateVertex(s)</code>来更新。</p>
</li>
</ul>
</li>
<li><p>LPA*扩展停止条件为：目标节点$s_{goal}$处于局部一致并且下一个待展开的节点<code>keys</code>值不小于$s_{goal}$的<code>keys</code>值。若搜索结束之后目标节点$s_{goal}$的<code>g</code>值为无穷大，那路径不存在。</p>
</li>
<li><p>将目标节点$s_{goal}$的后置链表反转即可得到$s_{start}$到$s_{goal}$的路径</p>
</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, pos)</span>:</span></span><br><span class="line">        self.pos = pos          <span class="comment"># 当前节点的位置坐标</span></span><br><span class="line">        self.g = float(<span class="string">'inf'</span>)   <span class="comment"># 当前节点的g(s),g_score</span></span><br><span class="line">        self.h = float(<span class="string">'inf'</span>)   <span class="comment"># 当前节点的的h(s),h_score</span></span><br><span class="line">        self.rhs = float(<span class="string">'inf'</span>) <span class="comment"># rhs(s)</span></span><br><span class="line">        self.keys = [float(<span class="string">'inf'</span>), float(<span class="string">'inf'</span>)]    <span class="comment"># 优先队列keys(s)值</span></span><br><span class="line">        self.p = <span class="literal">None</span>           <span class="comment"># 当前节点的父节点</span></span><br><span class="line">        self.is_obs = <span class="literal">False</span>     <span class="comment"># 当前节点是否是障碍物</span></span><br></pre></td></tr></table></figure>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">map_path:   地图图片路径</span></span><br><span class="line"><span class="string">qstart:     起点坐标 [row, col]</span></span><br><span class="line"><span class="string">qgoal:      目标点坐标 [row, col]</span></span><br><span class="line"><span class="string">grid_size:  网格大小（用来碰撞检测）</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">lpa_star = LPA_STAR(map_path, qstart, qgoal, grid_size)</span><br></pre></td></tr></table></figure>
<h3 id="Planning"><a href="#Planning" class="headerlink" title="Planning"></a>Planning</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">CalculateKey</span><span class="params">(self, s)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    the priority queue ordered by k1(f_score used in A*), then k2</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    key2 = min([s.g, s.rhs])</span><br><span class="line">    <span class="keyword">return</span> [key2 + s.h, key2]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Initialize</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    init</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    self.U = []</span><br><span class="line">    self.qstart.rhs = <span class="number">0</span></span><br><span class="line">    self.qstart.keys = [self.qstart.h, <span class="number">0</span>]</span><br><span class="line">    self.U.append(self.qstart)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">UpdateVertex</span><span class="params">(self, u)</span>:</span></span><br><span class="line">    <span class="comment"># u = copy.deepcopy(u)</span></span><br><span class="line">    <span class="keyword">if</span> u.pos != self.qstart.pos:</span><br><span class="line">        new_rhs = float(<span class="string">'inf'</span>)</span><br><span class="line">        <span class="comment"># predessors = self.Predessors(u)</span></span><br><span class="line">        predessors = self.SuccessorsCollisionFree(u)</span><br><span class="line">        <span class="keyword">for</span> pred <span class="keyword">in</span> predessors:</span><br><span class="line">            tmp_rhs = pred.g + self.DistanceCost(pred, u)</span><br><span class="line">            <span class="keyword">if</span> tmp_rhs &lt; new_rhs:</span><br><span class="line">                new_rhs = tmp_rhs</span><br><span class="line">                u.p = pred</span><br><span class="line">        u.rhs = new_rhs</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> node_index, node <span class="keyword">in</span> enumerate(self.U):</span><br><span class="line">        <span class="keyword">if</span> node.pos == u.pos:</span><br><span class="line">            self.U.pop(node_index)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> u.g != u.rhs:</span><br><span class="line">        u.keys = self.CalculateKey(u)</span><br><span class="line">        self.UInsert(u)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ComputeShortestPath</span><span class="params">(self)</span>:</span></span><br><span class="line"></span><br><span class="line">    color_close = (random.randint(<span class="number">0</span>, <span class="number">255</span>),</span><br><span class="line">                   random.randint(<span class="number">0</span>, <span class="number">255</span>),</span><br><span class="line">                   random.randint(<span class="number">0</span>, <span class="number">255</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (len(self.U) != <span class="number">0</span>) <span class="keyword">and</span> ((self.TopKey() &lt; self.CalculateKey(self.qgoal)) <span class="keyword">or</span> (self.qgoal.rhs != self.qgoal.g)):</span><br><span class="line"></span><br><span class="line">        u = self.U.pop(<span class="number">0</span>)</span><br><span class="line">        self.DrawGrid(u.pos, color_close)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> u.g &gt; u.rhs:</span><br><span class="line">            u.g = u.rhs</span><br><span class="line">            successors = self.SuccessorsCollisionFree(u)</span><br><span class="line">            <span class="keyword">for</span> succ <span class="keyword">in</span> successors:</span><br><span class="line">                self.UpdateVertex(succ)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            u.g = float(<span class="string">'inf'</span>)</span><br><span class="line">            self.UpdateVertex(u)</span><br><span class="line">            successors = self.SuccessorsCollisionFree(u)</span><br><span class="line">            <span class="keyword">for</span> succ <span class="keyword">in</span> successors:</span><br><span class="line">                self.UpdateVertex(succ)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> self.qgoal.rhs == self.qgoal.g <span class="keyword">and</span> self.qgoal.rhs != float(<span class="string">'inf'</span>):</span><br><span class="line">        self.FindPath()</span><br><span class="line">        print(<span class="string">'Found Path'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">'Not Found Path'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Planning</span><span class="params">(self)</span>:</span></span><br><span class="line"></span><br><span class="line">    num = input(<span class="string">"input obstacle numbers: "</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        input_num = eval(num)</span><br><span class="line">        <span class="keyword">if</span> type(input_num) == int:</span><br><span class="line">            self.AddObstacle(input_num)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> self.ComputeShortestPath() == <span class="literal">False</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        num = input(<span class="string">"input obstacle numbers: "</span>)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            input_num = eval(num)</span><br><span class="line">            <span class="keyword">if</span> type(input_num) == int:</span><br><span class="line">                obstacle_set = self.AddObstacle(input_num)</span><br><span class="line">                <span class="keyword">for</span> obs <span class="keyword">in</span> obstacle_set:</span><br><span class="line">                    successors = self.SuccessorsExcludeObstacle(obs)</span><br><span class="line">                    <span class="keyword">for</span> succ <span class="keyword">in</span> successors:</span><br><span class="line">                        self.UpdateVertex(succ)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>路径规划</category>
      </categories>
      <tags>
        <tag>路径规划</tag>
        <tag>motion planning</tag>
        <tag>LPA*</tag>
      </tags>
  </entry>
  <entry>
    <title>路径规划-RRT_Connect</title>
    <url>/posts/2708526344/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="路径规划之-RRT-Connect-平衡双向快速扩展随机树"><a href="#路径规划之-RRT-Connect-平衡双向快速扩展随机树" class="headerlink" title="路径规划之 RRT_Connect (平衡双向快速扩展随机树)"></a>路径规划之 RRT_Connect (平衡双向快速扩展随机树)</h1><p>单颗 RRT 树每次搜索只从初始节点开始在状态空间中快速随机扩展节点，带有一定的盲目性。RRT_Connect 算法是一种基于双向扩展平衡的连结型双树(Balanced Bidirectional RRT)：两颗 RRTs 分别基于 $q_{init}$ 和 $q_{goal}$ 扩展；贪心启发式的连接方法使每棵树扩展时一次移动更长的距离。<a href="https://ieeexplore.ieee.org/document/844730" target="_blank" rel="noopener">作者</a>原文中举例了平面地图以及 6-DOF 的机械臂来验证 RRT_Connect.</p>
<a id="more"></a>
<p><img data-src="rrt_connect.gif" alt="rrt_connect.gif"></p>
<h2 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h2><p>分别在起点 $q_{init}$ 和终点 $q_{goal}$ 构造两棵树 $T_1$ 和 $T_2$，扩展节点方式同 RRT。首先 $T_1$ 从 $q_{init}$ 随机采样 $q_{rand}$ 作为目标点扩展一个新节点 $𝑞_{𝑛𝑒𝑤}$ ，以这个新节点 $𝑞_{𝑛𝑒𝑤}$ 作为第二棵树 $T_2$ 的目标点来扩展新节点 $𝑞_{𝑛𝑒𝑤}^′$。如果 $𝑞_{𝑛𝑒𝑤}^′$ 没有碰撞，继续以$𝑞_{𝑛𝑒𝑤}$作为目标点扩展$T_2$，直到扩展失败(遇到障碍，进行下一次循环扩展或者 $𝑞_{𝑛𝑒𝑤}^′=𝑞_{𝑛𝑒𝑤}$ 两棵树相连，即 connect，整个算法结束)。每次扩展需要考虑两棵树的平衡性，节点多少或总路径的长度。交换次序，选择较短的树进行扩展。<br>首先，RRT_Connect 算法以另一棵树的新节点作为目标点扩展，直到扩展失败。每次扩展更加贪婪，步长更长，使得树的生长更快；其次，两棵树不断朝向对方交替扩展，相比于随机扩展的方式具有一定的启发性质，特别当起始位姿和目标位姿处于约束区域时，两棵树可以通过朝向对方快速扩展而逃离各自的约束区域。</p>
<h3 id="伪码"><a href="#伪码" class="headerlink" title="伪码"></a>伪码</h3><p><img data-src="algorithm_rrt_connect.png" alt="Algorithms RRT_Connect"></p>
<h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, pos=[<span class="number">0</span>, <span class="number">0</span>])</span>:</span></span><br><span class="line">        self.pos = pos</span><br><span class="line">        self.parent = <span class="literal">None</span></span><br></pre></td></tr></table></figure>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">map_path: 地图图片路径</span></span><br><span class="line"><span class="string">qstart: 起点坐标 [row, col]</span></span><br><span class="line"><span class="string">qgoal: 目标点坐标 [row, col]</span></span><br><span class="line"><span class="string">grid_size: 网格大小（用来碰撞检测）</span></span><br><span class="line"><span class="string">step_size: 扩展步长</span></span><br><span class="line"><span class="string">max_steps: 最大扩展节点数</span></span><br><span class="line"><span class="string">goal_prob: 增加趋向目标点概率（贪婪）</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">rrt_connect = RRT_CONNECT(map_path, qstart, qgoal, grid_size,</span><br><span class="line">                          step_size, max_steps, goal_prob)</span><br></pre></td></tr></table></figure>
<h3 id="Planning"><a href="#Planning" class="headerlink" title="Planning"></a>Planning</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Planning</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    RRT_CONNECT planning</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    # 初始化两颗树：分别在起点qstart和终点qgoal构造两棵树,</span></span><br><span class="line"><span class="string">    # 节点树分别记为vertices_t1和vetices_t2.</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    vertices_t1 = []</span><br><span class="line">    self.AddVertices(self.qstart, vertices_t1)</span><br><span class="line">    self.AddEdges(<span class="literal">None</span>, self.qstart)</span><br><span class="line"></span><br><span class="line">    vertices_t2 = []</span><br><span class="line">    self.AddVertices(self.qgoal, vertices_t2)</span><br><span class="line">    self.AddEdges(<span class="literal">None</span>, self.qgoal)</span><br><span class="line"></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    # 开始迭代</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    k = <span class="number">0</span></span><br><span class="line">    new_qgoal = self.qgoal</span><br><span class="line">    <span class="keyword">while</span> k &lt;= self.max_steps:</span><br><span class="line">        k += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        # 随机采样qrand_t1作为目标点，沿(qnear_t1, qrand_t1)方向,</span></span><br><span class="line"><span class="string">        # 以step_size步长扩展第一棵树的节点qnew_t1.</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        qrand_t1 = self.GenerateRandomNode(</span><br><span class="line">            [<span class="number">0</span>, self.map_shape[<span class="number">0</span>]], [<span class="number">0</span>, self.map_shape[<span class="number">1</span>]],</span><br><span class="line">            new_qgoal, self.goal_prob)</span><br><span class="line"></span><br><span class="line">        _, qnear_t1 = self.FindNearestNode(qrand_t1, vertices_t1)</span><br><span class="line">        qnew_t1 = self.ExtendTree(qnear_t1, qrand_t1, self.step_size)</span><br><span class="line"></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        # 检查qnew_t1是否扩展成功且没有碰撞</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="keyword">if</span> qnew_t1 <span class="keyword">and</span> self.CollsionFree(qnear_t1, qnew_t1, self.grid_size):</span><br><span class="line">            <span class="string">'''</span></span><br><span class="line"><span class="string">            将qnew_t1加入到第一颗树vertices_t1中</span></span><br><span class="line"><span class="string">            '''</span></span><br><span class="line">            self.AddVertices(qnew_t1, vertices_t1)</span><br><span class="line">            self.AddEdges(qnear_t1, qnew_t1)</span><br><span class="line"></span><br><span class="line">            self.DrawEdges(self.src_map, qnear_t1, qnew_t1)</span><br><span class="line"></span><br><span class="line">            <span class="string">'''</span></span><br><span class="line"><span class="string">            # 以qnew_t1为目标点，沿(qnear_t2, qnew_t1)方向</span></span><br><span class="line"><span class="string">            # 以step_size步长扩展第二棵树的节点qnew_t2.</span></span><br><span class="line"><span class="string">            '''</span></span><br><span class="line">            k += <span class="number">1</span></span><br><span class="line">            _, qnear_t2 = self.FindNearestNode(qnew_t1, vertices_t2)</span><br><span class="line">            qnew_t2 = self.ExtendTree(qnear_t2, qnew_t1, self.step_size)</span><br><span class="line"></span><br><span class="line">            <span class="string">'''</span></span><br><span class="line"><span class="string">            # 检查qnew_t1是否扩展成功且没有碰撞</span></span><br><span class="line"><span class="string">            '''</span></span><br><span class="line">            <span class="keyword">if</span> qnew_t2 <span class="keyword">and</span> self.CollsionFree(qnear_t2, qnew_t2, self.grid_size):</span><br><span class="line">                <span class="string">'''</span></span><br><span class="line"><span class="string">                # 将qnew_t1加入到第一颗树vertices_t1中</span></span><br><span class="line"><span class="string">                '''</span></span><br><span class="line">                self.AddVertices(qnew_t2, vertices_t2)</span><br><span class="line">                self.AddEdges(qnear_t2, qnew_t2)</span><br><span class="line"></span><br><span class="line">                self.DrawEdges(self.src_map, qnear_t2, qnew_t2)</span><br><span class="line"></span><br><span class="line">                <span class="string">'''</span></span><br><span class="line"><span class="string">                # 这里一直以qnew_t1为目标点，扩展qnew_t2，</span></span><br><span class="line"><span class="string">                # 除非qnew_t2扩展失败或qnew_t2到达qnew_t1。</span></span><br><span class="line"><span class="string">                # 扩展qnew_t2带有一定的贪婪特性，所以扩展树相比RRT更快速</span></span><br><span class="line"><span class="string">                '''</span></span><br><span class="line">                <span class="keyword">while</span> k &lt;= self.max_steps <span class="keyword">and</span> self.IsArrival(qnew_t2, qnew_t1, self.step_size) == <span class="literal">False</span>:</span><br><span class="line">                    k += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                    <span class="string">'''</span></span><br><span class="line"><span class="string">                    # 以qnew_t1为目标点，沿(qnew_t2, qnew_t1)方向</span></span><br><span class="line"><span class="string">                    # 以step_size步长扩展新节点qnew_mid.</span></span><br><span class="line"><span class="string">                    '''</span></span><br><span class="line">                    qnew_mid = self.ExtendTree(</span><br><span class="line">                        qnew_t2, qnew_t1, self.step_size)</span><br><span class="line"></span><br><span class="line">                    <span class="string">'''</span></span><br><span class="line"><span class="string">                    # 检查qnew_mid是否扩展成功且没有碰撞</span></span><br><span class="line"><span class="string">                    '''</span></span><br><span class="line">                    <span class="keyword">if</span> qnew_mid <span class="keyword">and</span> self.CollsionFree(qnew_t2, qnew_mid, self.grid_size):</span><br><span class="line">                        <span class="string">'''</span></span><br><span class="line"><span class="string">                        # 如果qnew_mid扩展成功，则将其加入到第二棵树中.</span></span><br><span class="line"><span class="string">                        '''</span></span><br><span class="line">                        self.AddVertices(qnew_mid, vertices_t2)</span><br><span class="line">                        self.AddEdges(qnew_t2, qnew_mid)</span><br><span class="line"></span><br><span class="line">                        self.DrawEdges(self.src_map, qnew_t2, qnew_mid)</span><br><span class="line"></span><br><span class="line">                        <span class="string">'''</span></span><br><span class="line"><span class="string">                        # 将第二棵树新扩展的节点qnew_mid作为qnew_t2继续扩展</span></span><br><span class="line"><span class="string">                        '''</span></span><br><span class="line">                        qnew_t2 = qnew_mid</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="string">'''</span></span><br><span class="line"><span class="string">                        # 如果qnew_mid扩展失败，则跳出该循环.</span></span><br><span class="line"><span class="string">                        '''</span></span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">            <span class="string">'''</span></span><br><span class="line"><span class="string">            检查两棵树是否相连,若相连，则完成路径规划</span></span><br><span class="line"><span class="string">            '''</span></span><br><span class="line">            <span class="keyword">if</span> self.IsArrival(qnew_t2, qnew_t1, self.step_size):</span><br><span class="line">                print(<span class="string">"Found"</span>)</span><br><span class="line">                <span class="string">'''</span></span><br><span class="line"><span class="string">                # 如果两棵树连上了，说明找到路径了，把最后一个节点添加到树中。</span></span><br><span class="line"><span class="string">                '''</span></span><br><span class="line">                copy_qnew_t1 = copy.deepcopy(qnew_t1)</span><br><span class="line">                self.AddVertices(copy_qnew_t1, vertices_t2)</span><br><span class="line">                self.AddEdges(qnew_t2, copy_qnew_t1)</span><br><span class="line"></span><br><span class="line">                <span class="string">'''</span></span><br><span class="line"><span class="string">                # 合并两棵树，注意终点树的节点指针与起点树反向</span></span><br><span class="line"><span class="string">                '''</span></span><br><span class="line">                path = self.MergeTree(vertices_t1, vertices_t2)</span><br><span class="line">                self.DrawPath(self.src_map, path)</span><br><span class="line"></span><br><span class="line">                <span class="string">'''</span></span><br><span class="line"><span class="string">                # 路径圆滑</span></span><br><span class="line"><span class="string">                '''</span></span><br><span class="line">                smooth_path = self.SmoothPath(path, self.grid_size)</span><br><span class="line">                self.DrawPath(self.src_map, smooth_path)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        # 当第二棵树扩展失败后，回到第一棵树扩展时，检查两棵树的节点个数，</span></span><br><span class="line"><span class="string">        # 选择较短树进行扩展，使两棵树保持相对平衡。新的目标点为较长树的最后一个节点</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="keyword">if</span> (len(vertices_t2) &lt; len(vertices_t1)):</span><br><span class="line">            vertices_t2, vertices_t1 = vertices_t1, vertices_t2</span><br><span class="line">            <span class="comment"># edges_t2, edges_t1 = edges_t1, edges_t2</span></span><br><span class="line"></span><br><span class="line">            new_qgoal = vertices_t2[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"NotFound"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>[1]: Kuffner J J , Lavalle S M . RRT-connect: An efficient approach to single-query path planning[C]// Proceedings 2000 ICRA. Millennium Conference. IEEE International Conference on Robotics and Automation. Symposia Proceedings (Cat. No.00CH37065). IEEE, 2002.</p>
]]></content>
      <categories>
        <category>路径规划</category>
      </categories>
      <tags>
        <tag>路径规划</tag>
        <tag>motion planning</tag>
        <tag>RRT_Connect</tag>
      </tags>
  </entry>
  <entry>
    <title>路径规划-RRT_Star</title>
    <url>/posts/3092301982/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="路径规划之-RRT-Star"><a href="#路径规划之-RRT-Star" class="headerlink" title="路径规划之 RRT_Star"></a>路径规划之 RRT_Star</h1><p>RRT_Connect 相对于 RRT 虽然增加了启发式策略和贪婪思想，但他们的路径都不是最优的。搜索路径都是基于随机采样，缺少评价函数。RRT_Star 算法在 RRT 的基础上，基于代价函数来重新选择新父节点，重新布线新子节点，保证算法渐进最优解。</p>
<a id="more"></a>
<p><img data-src="rrt_star.gif" alt="rrt_star.gif"></p>
<h2 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h2><p>RRT* 构造方式和 RRT 类似，区别在于重新选择父节点和重新布线这个过程。在寻找到新节点 $q_{new}$ 时，先进行碰撞检测，若 ($q_{near}$， $q_{new}$) 没有碰撞，并不立即将新节点和新边加入到树中。而是首先<strong>重新选择父节点</strong>：寻找以 $q_{new}$ 为圆心，以半径$r$内的所有邻接节点，作为$q_{new}$ 的潜在父节点 $q_{proential_parents}$ 。然后遍历所有潜在父节点，若 $q_{protential_parents}$ 到 $q_{new}$ 无碰撞，则计算从起点 $q_{start}$ 到潜在父节点$q_{protential_parents}$，再到新节点$q_{new}$的总路径长。选择最短路径的潜在父节点(假设记为$q_{min_parent}$)作为$q_{new}$的父节点，添加边 ($q_{min_parent}, q_{new}$) 到树中。 在完成父节点的重新选择后，再对该邻域<strong>重新布线</strong>：再次遍历该邻接节点集合中除 $q_{min_parent}$ 之外的剩余节点，作为 $q_{new}$ 的潜在子节点 $q_{proential_children}$，若 $q_{new}$ 到 $q_{protential_children}$ 无碰撞，则计算从起点 $q_{start}$ 到新节点 $q_{new}$ ，再到潜在子节点 $q_{protential_children}$ 的总路径长。选择最短路径的潜在子节点 (假设记为 $q_{min_child}$ )，将该节点的父节点设置为 $q_{new}$ 的新节点，删除边 ($q_{parent_of_min_child}$, $q_{min_child}$) 添加边 ($q_{new}$, $q_{min_parent}$) 到树中。因为我们通过链表来构建树，所以设置父节点也相当于添加边；更改父节点，相当于删除了原来的边并添加新边。通过上述两次选择，使得 RRT* 达到渐进最优，并且构造树的节点和边大大减少，提高的搜索效率。</p>
<h3 id="伪码"><a href="#伪码" class="headerlink" title="伪码"></a>伪码</h3><p><img data-src="algorithm_rrt_star.png" alt="Algorithms RRT_Connect"></p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, pos=[<span class="number">0</span>, <span class="number">0</span>])</span>:</span></span><br><span class="line">        self.pos = pos</span><br><span class="line">        self.parent = <span class="literal">None</span></span><br></pre></td></tr></table></figure>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">map_path: 地图图片路径</span></span><br><span class="line"><span class="string">qstart: 起点坐标 [row, col]</span></span><br><span class="line"><span class="string">qgoal: 目标点坐标 [row, col]</span></span><br><span class="line"><span class="string">grid_size: 网格大小（用来碰撞检测）</span></span><br><span class="line"><span class="string">step_size: 扩展步长</span></span><br><span class="line"><span class="string">neighbor_radius: 邻域半径，有公式计算的，这里为简单起见，选择定制</span></span><br><span class="line"><span class="string">max_steps: 最大扩展节点数</span></span><br><span class="line"><span class="string">goal_prob: 增加趋向目标点概率（贪婪）</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">rrt_star = RRT_STAR(map_path, qstart, qgoal, grid_size,</span><br><span class="line">                    step_size, parent_radius, max_steps, goal_prob)</span><br></pre></td></tr></table></figure>
<h3 id="Planning"><a href="#Planning" class="headerlink" title="Planning"></a>Planning</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Planning</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    RRT_STAR planning</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 初始化树，添加起点</span></span><br><span class="line">    vertices = []</span><br><span class="line">    self.AddVertices(self.qstart, vertices)</span><br><span class="line">    self.AddEdges(<span class="literal">None</span>, self.qstart)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 开始扩展</span></span><br><span class="line">    k = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> k &lt;= self.max_steps:</span><br><span class="line">        k += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 随机采样节点qrand，</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 扩展新节点qnew</span></span><br><span class="line">        qrand = self.GenerateRandomNode(</span><br><span class="line">            [<span class="number">0</span>, self.map_shape[<span class="number">0</span>]], [<span class="number">0</span>, self.map_shape[<span class="number">1</span>]],</span><br><span class="line">            self.qgoal, self.goal_prob)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 遍历树节点 vertices，选择距离最近的节点 qnear</span></span><br><span class="line">        _, qnear = self.FindNearestNode(qrand, vertices)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 扩展新节点 qnew</span></span><br><span class="line">        qnew = self.ExtendTree(qnear, qrand, self.step_size)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 判断 qnew 扩展成功，且(qnear, qnew)无碰撞</span></span><br><span class="line">        <span class="keyword">if</span> qnew <span class="keyword">and</span> self.CollsionFree(qnear, qnew, self.grid_size):</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 寻找以qnew为圆心，parent_radius为半径的圆内邻接节点neighbors_free</span></span><br><span class="line">            neighbors_free = self.FindNeighbors(</span><br><span class="line">                qnew, vertices, self.parent_radius)</span><br><span class="line"></span><br><span class="line">            <span class="string">'''</span></span><br><span class="line"><span class="string">            neighbors = list(filter(lambda qnode: self.Distance(</span></span><br><span class="line"><span class="string">                qnode.pos, qnew.pos) &lt; self.parent_radius, vertices))</span></span><br><span class="line"><span class="string">            neighbors_free = []</span></span><br><span class="line"><span class="string">            for parent in neighbors:</span></span><br><span class="line"><span class="string">                if self.CollsionFree(parent, qnew, self.grid_size):</span></span><br><span class="line"><span class="string">                    neighbors_free.append(parent)</span></span><br><span class="line"><span class="string">            '''</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 重新选择父节点：</span></span><br><span class="line">            <span class="comment"># 计算路径代价Cost(qstart, neighbors_free, qnew),</span></span><br><span class="line">            <span class="comment"># 选择最短路径的潜在父节点作为qnew的新父节点qnew_parent，并将新边加入到树中</span></span><br><span class="line">            len_qnew_path, qnew_parent = self.RewireNewParent(</span><br><span class="line">                qnew, vertices, neighbors_free)</span><br><span class="line"></span><br><span class="line">            <span class="string">'''</span></span><br><span class="line"><span class="string">            len_qnew_path = float('inf')</span></span><br><span class="line"><span class="string">            qnew_parent = None</span></span><br><span class="line"><span class="string">            for parent in neighbors_free:</span></span><br><span class="line"><span class="string">                parent_path = self.FindPathByParentPointer(parent)</span></span><br><span class="line"><span class="string">                len_parent_path = self.CalculatePathLength(parent_path)</span></span><br><span class="line"><span class="string">                tmp_len_path = len_parent_path + \</span></span><br><span class="line"><span class="string">                    self.Distance(qnew.pos, parent.pos)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                if tmp_len_path &lt; len_qnew_path:</span></span><br><span class="line"><span class="string">                    len_qnew_path = tmp_len_path</span></span><br><span class="line"><span class="string">                    qnew_parent = parent</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            self.AddVertices(qnew, vertices)</span></span><br><span class="line"><span class="string">            self.AddEdges(qnew_parent, qnew)</span></span><br><span class="line"><span class="string">            self.DrawEdges(self.src_map, qnew_parent, qnew)</span></span><br><span class="line"><span class="string">            '''</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 重新布线：</span></span><br><span class="line">            <span class="comment"># 计算neighbors_free中除qnew_parent外的路径代价Cost(qstart, qnew, neighbors_free),</span></span><br><span class="line">            <span class="comment"># 选择最短路径的节点qnew_children，设置其父节点为qnew，并将新边加入到树中</span></span><br><span class="line">            <span class="keyword">if</span> qnew_parent:</span><br><span class="line">                neighbors_free.remove(qnew_parent)</span><br><span class="line">            self.RewireNewChild(qnew, len_qnew_path, neighbors_free)</span><br><span class="line">            <span class="string">'''</span></span><br><span class="line"><span class="string">            qnew_children = None</span></span><br><span class="line"><span class="string">            for child in neighbors_free:</span></span><br><span class="line"><span class="string">                tmp_len_path = len_qnew_path + \</span></span><br><span class="line"><span class="string">                    self.Distance(qnew.pos, child.pos)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                if self.CollsionFree(child, qnew, self.grid_size):</span></span><br><span class="line"><span class="string">                    child_path = self.FindPathByParentPointer(child)</span></span><br><span class="line"><span class="string">                    if tmp_len_path &lt; self.CalculatePathLength(child_path):</span></span><br><span class="line"><span class="string">                        qnew_children = child</span></span><br><span class="line"><span class="string">                        self.AddEdges(qnew, qnew_children)</span></span><br><span class="line"><span class="string">                        self.DrawEdges(self.src_map, qnew,</span></span><br><span class="line"><span class="string">                                       qnew_children)</span></span><br><span class="line"><span class="string">            '''</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 检查两棵树是否相连,若相连，则完成路径规划</span></span><br><span class="line">            <span class="keyword">if</span> self.IsArrival(qnew, self.qgoal, self.step_size):</span><br><span class="line">                print(<span class="string">"Found"</span>)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 如果两棵树连上了，说明找到路径了，把最后一个节点添加到树中。</span></span><br><span class="line">                self.AddVertices(self.qgoal, vertices)</span><br><span class="line">                self.AddEdges(qnew, self.qgoal)</span><br><span class="line">                self.DrawEdges(self.src_map, qnew, self.qgoal)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 构建路径</span></span><br><span class="line">                path = self.FindPath(vertices)</span><br><span class="line">                self.DrawPath(self.src_map, path)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 圆滑路径</span></span><br><span class="line">                smooth_path = self.SmoothPath(path, self.grid_size)</span><br><span class="line">                self.DrawPath(self.src_map, smooth_path)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">"NotFound"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>[1]: Karaman S, Frazzoli E. Sampling-based algorithms for optimal motion planning[J]. The international journal of robotics research, 2011, 30(7): 846-894.<br>[2]: Choset. Principles of Robot Motion: Theory, Algorithms, and Implementations[J]. Proceedings of the Society for Experimental Biology &amp; Medicine Society for Experimental Biology &amp; Medicine, 2005, 147(1):512-512.</p>
]]></content>
      <categories>
        <category>路径规划</category>
      </categories>
      <tags>
        <tag>路径规划</tag>
        <tag>motion planning</tag>
        <tag>RRT*</tag>
      </tags>
  </entry>
  <entry>
    <title>自动驾驶仿真 - AirSim (1) - Windows 10 下安装仿真平台 AirSim - v1.3.1</title>
    <url>/posts/4243726933/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>最近在学习自动驾驶相关的知识，看很多公司都是基于百度 <code>Apollo</code> 平台的，不过因为基于 Linux。手头电脑上只有虚拟机，显卡什么不能用，跑起来有点费劲。然后找到了微软开放的一个仿真平台 <code>AirSim</code>。因为微软加持，所以在 <code>Windows</code>平台就很方便，另外也有 <code>Linux</code>版本。（等买一个新硬盘再装个 <code>Linux</code>系统再用下 <code>Apollo</code> 和 <code>AirSim</code> ）。本文主要记录了 <code>Windows 10</code> 下安装 <code>AirSim - v1.3.1</code>的步骤。</p>
<a id="more"></a>
<hr>
<p>[TOC]</p>
<hr>
<h2 id="AirSim-简介"><a href="#AirSim-简介" class="headerlink" title="AirSim 简介"></a>AirSim 简介</h2><p><code>AirSim</code> 是一个建立在虚幻引擎之上用于仿真飞行器和汽车驾驶的仿真器（也有 <code>Unity</code> 的试验版本）。它是开源的、跨平台的，并支持飞行控制器(如 PX4) <code>hardware-in-loop</code> ，用于物理和视觉上的真实模拟。它被开发为一个 <code>Unreal</code> 的插件，可以简单地扔到任何 <code>Unreal</code> 的环境。目标是 <code>AirSim</code> 开发成一个人工智能研究的平台，以实验深度学习、计算机视觉和增强自主学习算法。</p>
<h2 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h2><ul>
<li>Windows 10</li>
<li>AirSim - v1.3.1</li>
<li>Visual Studio 2019</li>
<li>Unreal Engine 4.25.1</li>
</ul>
<h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><p>提前备注下：安装之前保证磁盘可用空间足够大，因为安装 VS 以及 UE 都挺占用磁盘空间的。至少预留 50G + 吧，保险点，免得后面出现磁盘不足的尴尬。</p>
<h3 id="安装-Visual-Studio-2019"><a href="#安装-Visual-Studio-2019" class="headerlink" title="安装 Visual Studio 2019"></a>安装 Visual Studio 2019</h3><p>巨硬官网<a href="https://visualstudio.microsoft.com/zh-hans/vs/" target="_blank" rel="noopener">下载</a> <code>vs_community</code>安装包，执行在线安装，比较耗时。没办法，vs 2017 之后没有提供离线安装包了。必须安装的组件 <code>使用C++的桌面开发</code> 和 <code>Windows 10 SDK</code> 。我这里直接安装了 <code>使用C++的桌面开发</code> ，和 <code>使用C++的游戏开发</code> ，基本上和 C++ 相关的开发组件都有了。其他的就根据自己的需求来。我这里就安装的这几个工作负载，具体的组件都是默认选项。</p>
<p><img data-src="image-20200606121633117.png" alt="image-20200606121633117"></p>
<h3 id="安装-Unreal-Engine"><a href="#安装-Unreal-Engine" class="headerlink" title="安装 Unreal Engine"></a>安装 Unreal Engine</h3><ul>
<li><p><a href="https://www.unrealengine.com/zh-CN/get-now" target="_blank" rel="noopener">下载</a> 安装 Epic Games Launcher。( <strong>PS</strong>：这段时间 Epic 正在免费送游戏呢，白嫖了 GTA 5 ，文明 6， 无主之地等，哈哈哈)。</p>
</li>
<li><p>安装登陆器的时候可能会注册账号之类的。</p>
</li>
<li><p>登陆器完成，接下去就安装引擎了。</p>
</li>
<li><p>首先登录。未安装 UE 的时候，在右上角是灰色的按钮。进入到 <strong><code>库</code></strong> ，选择安装的 UE 版本。这里我就选择最新的引擎版本安装了 <strong><code>4.25.1</code></strong>。</p>
<p><img data-src="image-20200606123115428.png" alt="image-20200606123115428"></p>
</li>
<li><p>引擎下载比较大，大概 11 G 左右（<strong>PS</strong>：相比于游戏动辄五六十 G 来说，还是比较矜持的.如果下载比较慢，可以试下挂加速器下载。没错，就是打游戏用的那个加速器。我这里用的是挂的是鹅厂的加速器（非广告）。选择 Epic 游戏加速下载，反正是被拉满速了，不过其实我也不知道有没有用，因为我没试过不挂加速器是咋样的速度）</p>
<p><img data-src="image-20200606123716438.png" alt="image-20200606123716438"></p>
</li>
</ul>
<p><strong>PS</strong>：手册上建议<code>AirSim v1.3.1</code> 建议安装的 UE 版本 <strong>4.24</strong>，虽然 &gt;=4.22 也可以正常工作。所以我这里建议就直接安装最新的吧。</p>
<ul>
<li><p>文明打几个回合的功夫，应该就下载好了。这时候，登陆器左上角的就会出现可点击的 <code>启动 Unreal Engine 4.25.1</code>。</p>
</li>
<li><p>引擎安装先到这。</p>
</li>
</ul>
<h3 id="构建-AirSim"><a href="#构建-AirSim" class="headerlink" title="构建 AirSim"></a>构建 AirSim</h3><ul>
<li><p>先 <code>Clone</code> 仓库吧：<a href="https://github.com/Microsoft/AirSim" target="_blank" rel="noopener">官方仓库地址</a>： <a href="https://github.com/Microsoft/AirSim。" target="_blank" rel="noopener">https://github.com/Microsoft/AirSim。</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/Microsoft/AirSim.git</span><br></pre></td></tr></table></figure>
</li>
<li><p>咳咳，国内网络从 <code>github</code>拉代码都比较……慢……我这百兆电信也就……几十 kb……所以这里就用 <a href="https://gitee.com/troxyz/airsim" target="_blank" rel="noopener">码云</a> 同步了一下：<a href="https://gitee.com/troxyz/airsim" target="_blank" rel="noopener">https://gitee.com/troxyz/airsim</a> （同步日期：2020.6.6）。</p>
</li>
<li><p>接下去就 <code>git clone</code> 吧，基本能拉满速。我这里拉了 v1.3.1 的最新的代码，历史代码我也暂时用不到。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -b v1.3.1-windows  https://gitee.com/troxyz/airsim.git --depth 1</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后就正式构建 <code>AirSim</code> 。</p>
<ul>
<li><p>从 <code>开始</code> 菜单启动 <code>Developer Command Prompt for VS 2019</code> 或者 <code>Developer Powershell for VS 2019</code>. 一下子找不到就在开始菜单搜索下。</p>
<p><img data-src="image-20200606130910725.png" alt="image-20200606130910725"></p>
</li>
<li><p><code>cd</code> 切换到 <code>airsim</code> 的源码目录下.</p>
</li>
<li><p>运行 <code>build.cmd</code> 脚本</p>
<ul>
<li><strong>PS:</strong> 这里会下载一个库 <a href="https://github.com/rpclib/rpclib/archive/v2.2.1.zip" target="_blank" rel="noopener"><code>rpclib-2.2.1.zip</code></a> 和一个 <a href="https://github.com/Microsoft/AirSim/releases/download/v1.2.0/car_assets.zip" target="_blank" rel="noopener"><code>car_assert.zip</code></a>（就是一辆默认配置好的小车），打开这个脚本搜索一下能看到这两个文件都是放在 <code>github</code>上的，所以下载慢就不奇怪了。我这里就离线下载放到仓库里去了。</li>
<li>重命名一下 <code>rpclib.zip</code> 扔到 <code>external\rpclib.zip</code> 下</li>
<li>解压 <code>car_assert.zip</code> 的 <code>SUV</code> 文件夹到 <code>Unreal\Plugins\AirSim\Content\VehicleAdv\</code></li>
</ul>
</li>
<li><p>如果没有错误，那这里就算构建完成了</p>
</li>
</ul>
</li>
</ul>
<h3 id="如何使用-AirSim"><a href="#如何使用-AirSim" class="headerlink" title="如何使用 AirSim"></a>如何使用 AirSim</h3><p>在 <code>Unreal/Environments/Blocks</code> 文件夹里面有个轻量级的环境。</p>
<ul>
<li><p>切换到 <code>AirSim\Unreal\Environments\Blocks</code> 运行 <code>update_from_git.bat</code> 脚本。</p>
</li>
<li><p>打开生成的 <code>.sln</code> 工程文件，项目配置为 <code>DebugGame_Editor</code> ，<code>Win64</code>.</p>
<p><img data-src="image-20200606140541011.png" alt="image-20200606140541011"></p>
</li>
<li><p>运行，这时候会启动 UE，点击运行按钮，可以看到小车出现，方向键即可控制小车运动。</p>
<p><img data-src="image-20200606140845322.png" alt="image-20200606140845322"></p>
</li>
<li><p>按 <code>F1</code> 可看到帮助提示，可以看到深度图、分割图、相机窗口</p>
<p><img data-src="image-20200606141232221.png" alt="image-20200606141232221"></p>
</li>
</ul>
]]></content>
      <categories>
        <category>自动驾驶</category>
      </categories>
      <tags>
        <tag>自动驾驶</tag>
        <tag>AirSim</tag>
      </tags>
  </entry>
  <entry>
    <title>自动驾驶仿真 - AirSim (2) - 创建并设置 Unreal Engine 环境</title>
    <url>/posts/2194771931/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>对自定义 UE 环境导入 AirSim 插件小车。本文主要参考官方文档 <a href="https://microsoft.github.io/AirSim/unreal_custenv/" target="_blank" rel="noopener">Creating and Setting Up Unreal Environment</a>。</p>
<a id="more"></a>
<hr>
<p>[TOC]</p>
<hr>
<h2 id="地图准备"><a href="#地图准备" class="headerlink" title="地图准备"></a>地图准备</h2><p>因为原文使用的一个免费环境在 UE 商城没有找到。不过官方在 <code>github</code> 上提供了几个<a href="https://github.com/Microsoft/AirSim/releases" target="_blank" rel="noopener">地图</a>可用，不过下载速度太慢了。所以，本文直接从 UE 的 <strong>学习</strong> tab 下载了一个免费的赛车游戏项目，大概一个 G 左右。官方提供的几个地图等下载好之后再试试。</p>
<p><img data-src="image-20200607112530427.png" alt="image-20200607112530427"></p>
<h2 id="创建-UE-工程"><a href="#创建-UE-工程" class="headerlink" title="创建 UE 工程"></a>创建 UE 工程</h2><ol>
<li><p>点击 <code>创建工程</code> 按钮，输入名称和保存的文件夹，<code>创建</code> 工程。这里 <strong>不要出现中文路径</strong>， 貌似后面编译老出问题，换成英文之后就过了。</p>
<p><img data-src="image-20200607113118716.png" alt="image-20200607113118716"></p>
</li>
<li><p>打开项目所在文件夹，打开 ue 项目，这里是 <code>cargame.uproject</code>. 首次打开估计要编译一会儿，这个看电脑配置，我大概花了 10 分钟 (i7 8700 + GTX 1070Ti + 固态)。</p>
<p><strong>PS</strong>：如果使用官方示例中的那个地图，因为没有源码文件，所以触发不了编译。所以官方的那份文档有一步骤是建立一个新的 C++ 的空类。这里不需要，也不能，否则该项目模块编译不了。</p>
<p><img data-src="image-20200607113756907.png" alt="image-20200607113756907"></p>
</li>
<li><p>效果如下图所示，这个是个完整的游戏，如果点击 <code>运行</code> 会出来一辆小车，是可以玩的。不过这辆车不是我们要的那辆。</p>
<p><img data-src="image-20200607115242368.png" alt="image-20200607115242368"></p>
</li>
</ol>
<h2 id="生成-Visual-Studio-项目"><a href="#生成-Visual-Studio-项目" class="headerlink" title="生成 Visual Studio 项目"></a>生成 Visual Studio 项目</h2><ol>
<li><p>在 <code>UnReal Editor</code> 中点击 <code>文件</code>，<code>生成Visual Studio项目</code>。之后，会在项目文件夹下看到一个 vs 项目文件 <code>cargame.sln</code>，这里暂时不要打开。先关闭编辑器。</p>
<p><img data-src="image-20200607115730099.png" alt="image-20200607115730099"></p>
</li>
<li><p>把 <code>AirSim</code> 项目下的 <code>AirSim</code> 插件拷贝（路径 <code>Unreal/Plugins</code>）到 <code>cargame</code> 项目根目录下，如图。</p>
<p><img data-src="AirSim 仿真 (2" alt="image-20200607121222918"> - 创建并设置 Unreal Engine 环境.assets/image-20200607121222918.png)</p>
</li>
<li><p>右键编辑 <code>cargame.uproject</code>, 找到 <code>&quot;Plugins&quot;</code> 字段，把 <code>AirSim</code> 插件添加进去. 保存。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"Plugins": [</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="attr">"Name"</span>: <span class="string">"PhysXVehicles"</span>,</span><br><span class="line">      <span class="attr">"Enabled"</span>: <span class="literal">true</span></span><br><span class="line">   &#125;,</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="attr">"Name"</span>: <span class="string">"RawInput"</span>,</span><br><span class="line">      <span class="attr">"Enabled"</span>: <span class="literal">true</span></span><br><span class="line">   &#125;,</span><br><span class="line">   &#123;</span><br><span class="line">         <span class="attr">"Name"</span>: <span class="string">"AirSim"</span>,</span><br><span class="line">         <span class="attr">"Enabled"</span>: <span class="literal">true</span></span><br><span class="line">     &#125;</span><br><span class="line">],</span><br></pre></td></tr></table></figure>
</li>
<li><p>右键 <code>cargame.uproject</code>，选择 <code>Generate Visual Studio project fiels</code>. 这时候，目录下会出现 vs 的工程文件 <code>cargame.sln</code>.</p>
<p><img data-src="image-20200607121001231.png" alt="image-20200607121001231"></p>
</li>
<li><p>打开 vs 工程文件 <code>cargame.sln</code>，工程配置为 <code>DSebugGame Editor</code>, <code>Win64</code>。</p>
<p><img data-src="image-20200607121426792.png" alt="image-20200607121426792"></p>
</li>
<li><p>编译运行工程，成功后，会自动打开 ue 编辑器的，和运行 <code>Blocks</code> 示例工程一样。</p>
</li>
</ol>
<h2 id="加载-AirSim-插件"><a href="#加载-AirSim-插件" class="headerlink" title="加载 AirSim 插件"></a>加载 <code>AirSim</code> 插件</h2><ol>
<li><p>打开 <code>世界场景设置</code> 窗口。如果没有的话，点击 <code>窗口</code>，勾选 <code>世界场景设置</code> ，即可。效果如下图。</p>
<p><strong>PS</strong>: 这里我找了好久，官方文档说默认有的，我这里没有，一直怀疑我安装有啥问题。</p>
<p><img data-src="image-20200607122150090.png" alt="image-20200607122150090"></p>
</li>
<li><p>在 <code>世界场景设置</code> 中的 <code>游戏模式</code> 的 <code>游戏模式重载</code> 下拉框选择 <code>AirSimGameMode</code>. 至此所有配置均完成。</p>
<p><img data-src="image-20200607122408176.png" alt="image-20200607122408176"></p>
</li>
</ol>
<h2 id="运行仿真"><a href="#运行仿真" class="headerlink" title="运行仿真"></a>运行仿真</h2><p>在编辑器中点击 <code>运行</code> ，然后就出现了我们熟悉的车了，把几个视图窗口调出来。</p>
<p><img data-src="image-20200607122806805.png" alt="image-20200607122806805"></p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ol>
<li><p>在编辑器的 <code>细节</code> 窗口可以看到选中的 对象的一些信息。比如这里我选中了小车，小车运动时，一些数据能实时变化。</p>
<p><img data-src="image-20200607123344712.png" alt="image-20200607123344712"></p>
</li>
<li><p>如果鼠标切换不出来， 按快捷键 <code>shift + F1</code>.</p>
</li>
<li><p>鼠标切出时，可能仿真视图界面会出现卡顿的现象。点击 <code>编辑</code> -&gt; <code>编辑器偏好设置……</code>。搜索一下 <code>cpu</code>，把 <code>编辑器性能</code> 下的 <code>处于背景中时占用较少CPU</code> 的勾勾去掉即可。</p>
<p><img data-src="image-20200607123712008.png" alt="image-20200607123712008"></p>
<p><img data-src="image-20200607123910639.png" alt="image-20200607123910639"></p>
</li>
</ol>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>愉快地继续折腾吧。</p>
]]></content>
      <categories>
        <category>自动驾驶</category>
      </categories>
      <tags>
        <tag>自动驾驶</tag>
        <tag>AirSim</tag>
      </tags>
  </entry>
  <entry>
    <title>自动驾驶仿真 - AirSim (3) - 配置 Visual Studio 工程</title>
    <url>/posts/531482360/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>接下来的文章主要开始记录 AirSim 提供的 APIs 的学习。但是在自己新建一个工程的时候发现，配置有很多问题，这里先解决一下。</p>
<a id="more"></a>
<p>在第一篇文章【AirSim 仿真 (1) - Windows 10 下安装仿真平台 AirSim - v1.3.1】，跑了一下示例工程 <code>Hello Car</code> . 因为工程配置的关系，发现吧这个工程拷贝出来后，在打开编译不了。但是自己码工程的时候，目录不一定非得限制到 AirSim 的工程目录下吧，总归自己有个文件夹的。</p>
<p>其实看一下 <code>Hello Car</code> 的工程属性配置可以看到其实编译不了的原因，无非是包含目录、依赖库的关系。因此，这里主要解决一下这些配置问题。</p>
<hr>
<p>[TOC]</p>
<hr>
<h2 id="新建工程"><a href="#新建工程" class="headerlink" title="新建工程"></a>新建工程</h2><ol>
<li><p>创建一个控制台应用，指定一个自己的归档路径。过程不叙述了。这里，我新建了一个<code>car-controller</code> 文件夹（和 <code>AirSim</code> 项目不在一起）。工程就叫做 <code>CarController</code>.</p>
<p><img data-src="image-20200607165137306.png" alt="image-20200607165137306"></p>
</li>
<li><p>把示例程序 <code>HelloCar</code> 的源码拷贝过来，不用想，这里肯定都是满屏的错误。</p>
</li>
<li>整个过程其实和配置 <code>OpenCV</code>的过程差不多，开始配置项目工程属性，进入 <code>项目</code> -&gt; <code>属性</code>。</li>
</ol>
<h2 id="添加附加包含目录"><a href="#添加附加包含目录" class="headerlink" title="添加附加包含目录"></a>添加附加包含目录</h2><ol>
<li><p><code>配置属性</code> -&gt; <code>C/C++</code> -&gt; <code>常规</code> -&gt; <code>附加包含目录</code></p>
</li>
<li><p>添加如下三个包含目录，在 <code>AirSim</code> 工程内。我这里是 <code>D:\dev\airsim_ws\airsim</code></p>
<blockquote>
<p><code>$(airsim项目目录)\AirLib\deps\rpclib\include</code></p>
<p><code>$(airsim项目目录)\AirLib\deps\eigen3</code></p>
<p><code>$(airsim项目目录)\AirLib\include</code></p>
</blockquote>
<p><img data-src="image-20200607170319035.png" alt="image-20200607170319035"></p>
</li>
</ol>
<h2 id="添加附加库目录"><a href="#添加附加库目录" class="headerlink" title="添加附加库目录"></a>添加附加库目录</h2><ol>
<li><p><code>配置属性</code> -&gt; <code>链接器</code> -&gt; <code>常规</code> -&gt; <code>附加库目录</code></p>
</li>
<li><p>添加如下三个包含库目录，在 <code>AirSim</code> 工程内。</p>
<blockquote>
<p><code>$(airsim项目目录)\AirLib\lib\$(Platform)\$(Configuration)</code></p>
<p><code>$(airsim项目目录)\AirLib\deps\rpclib\lib\$(Platform)\$(Configuration)</code></p>
<p><code>$(airsim项目目录)\AirLib\deps\MavLinkCom\lib\$(Platform)\$(Configuration)</code></p>
</blockquote>
</li>
<li><p><strong>PS</strong>: 因为 <code>Windows</code> 下的库区分 <code>Debug</code> 和 <code>Release</code>模式，还有 <code>x86</code> 和 <code>x64</code> 连个平台。</p>
<blockquote>
<p><code>$(Platform)</code> : 这个就是区分 <code>Debug</code> 和 <code>Release</code>的</p>
<p><code>$(Configuration)</code> : 这个区分 <code>x86</code>还是 <code>x64</code>的</p>
</blockquote>
</li>
</ol>
<p><img data-src="image-20200607171024035.png" alt="image-20200607171024035"></p>
<h2 id="配置附加依赖项"><a href="#配置附加依赖项" class="headerlink" title="配置附加依赖项"></a>配置附加依赖项</h2><p>完成上一步，这时候代码应该不会冒红了，但是编译还是过不了的。会包 <code>LNK2019</code> 无法解析的外部符号的错误，因为依赖库找不到。</p>
<ol>
<li><p><code>配置属性</code> -&gt; <code>链接器</code> -&gt; <code>输入</code> -&gt; <code>附加依赖项</code></p>
</li>
<li><p>添加库，上一步的三个 <code>lib</code> 文件夹下的库都需要添加进去。<strong>PS</strong>: 还有一种方法针对很多库的，比如 <code>OpenCV</code> 是不是在这里要添加很多库，有些时候还会漏掉导致工程编译失败。这里也又一个小技巧，就是用通配符，把指定目录下的所有 lib 都添加进来。</p>
<blockquote>
<p><code>$(airsim项目目录)\AirLib\deps\rpclib\lib\$(Platform)\$(Configuration)\*.lib</code> &gt; <code>$(airsim项目目录)\AirLib\deps\MavLinkCom\lib\$(Platform)\$(Configuration)\*.lib</code> &gt; <code>$(airsim项目目录)\AirLib\lib\$(Platform)\$(Configuration)\*.lib</code></p>
</blockquote>
</li>
</ol>
<p><img data-src="image-20200607175949310.png" alt="image-20200607175949310"></p>
<h2 id="编译运行"><a href="#编译运行" class="headerlink" title="编译运行"></a>编译运行</h2><p>工程配置： <code>Debug</code>, <code>x64</code>。例程再次跑起来了。</p>
<p><img data-src="image-20200607182009709.png" alt="image-20200607182009709"></p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>其实到这里，如果有编译好的库和插件，其实都不需要下载 UE （除非要自定义场景）或者源码编译。</p>
<p>这里把我编译好的库文件和插件上传了，可自行下载:</p>
<blockquote>
<p>AirLib-v1.3.1-vs2019.zip</p>
<p>Plugins-AirSim-v1.3.1-ue2.25.1.zip</p>
</blockquote>
<p>地图的话，在官方的 <code>github</code> 上可以自己<a href="https://github.com/microsoft/AirSim/releases" target="_blank" rel="noopener">下载</a>: <a href="https://github.com/microsoft/AirSim/releases" target="_blank" rel="noopener">https://github.com/microsoft/AirSim/releases</a>，里面是打包好的应用程序，双击就可以运行，可以下载一个小地图试试。</p>
<p><strong>PS</strong>：如果是汽车的话就不要下载 <code>ZhangJiaJie</code>那幅图了，给无人机用的，车开不了。</p>
<p><img data-src="image-20200607183454753.png" alt="image-20200607183454753"></p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>接下去就要开始正真的开发使用了……</p>
]]></content>
      <categories>
        <category>自动驾驶</category>
      </categories>
      <tags>
        <tag>自动驾驶</tag>
        <tag>AirSim</tag>
      </tags>
  </entry>
  <entry>
    <title>自动驾驶仿真 - AirSim (4) - 核心 APIs - C++</title>
    <url>/posts/1307933338/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>接下去主要介绍一下 <code>AirSim</code> 的 <code>APIs</code> 的使用. <a href="https://microsoft.github.io/AirSim/apis/" target="_blank" rel="noopener">官方</a> 提供了 <code>Python</code> 和 <code>C++</code> 两个版本, 我这里就主要以 <code>C++</code> 来试验.</p>
<p>这篇文章的 <code>Hello Car</code> 的<a href="https://microsoft.github.io/AirSim/apis_cpp/#hello_car" target="_blank" rel="noopener">源码</a>.</p>
<a id="more"></a>
<hr>
<p>[TOC]</p>
<hr>
<h2 id="Hello-Car-源码"><a href="#Hello-Car-源码" class="headerlink" title="Hello Car 源码"></a><code>Hello Car</code> 源码</h2><p>官方<a href="https://microsoft.github.io/AirSim/apis_cpp/#quick-start" target="_blank" rel="noopener">文档</a>该部分的源码还没有更新, 这里源码为 <a href="https://github.com/Microsoft/AirSim/blob/master/HelloCar/main.cpp" target="_blank" rel="noopener">GitHub</a>上的源码. 如果要用文档的例程, 需要把 <code>两处</code></p>
<blockquote>
<p><del><code>CarControllerBase::CarControls</code></del></p>
</blockquote>
<p>改为</p>
<blockquote>
<p><code>msr::airlib::CarApiBase::CarControls</code></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Copyright (c) Microsoft Corporation. All rights reserved.</span></span><br><span class="line"><span class="comment">// Licensed under the MIT License.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"common/common_utils/StrictMode.hpp"</span></span></span><br><span class="line">STRICT_MODE_OFF</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> RPCLIB_MSGPACK</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RPCLIB_MSGPACK clmdep_msgpack</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// !RPCLIB_MSGPACK</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"rpc/rpc_error.h"</span></span></span><br><span class="line">STRICT_MODE_ON</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"vehicles/car/api/CarRpcLibClient.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"common/common_utils/FileSystem.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> msr::airlib;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Make sure settings.json has \"SimMode\"=\"Car\" at root. Press Enter to continue."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="built_in">std</span>::<span class="built_in">cin</span>.<span class="built_in">get</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This assumes you are running DroneServer already on the same machine.</span></span><br><span class="line">    <span class="comment">// DroneServer must be running first.</span></span><br><span class="line">    msr::airlib::CarRpcLibClient client;</span><br><span class="line">    <span class="keyword">typedef</span> ImageCaptureBase::ImageRequest ImageRequest;</span><br><span class="line">    <span class="keyword">typedef</span> ImageCaptureBase::ImageResponse ImageResponse;</span><br><span class="line">    <span class="keyword">typedef</span> ImageCaptureBase::ImageType ImageType;</span><br><span class="line">    <span class="keyword">typedef</span> common_utils::<span class="built_in">FileSystem</span> <span class="built_in">FileSystem</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        client.confirmConnection();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Press Enter to get FPV image"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="built_in">std</span>::<span class="built_in">cin</span>.<span class="built_in">get</span>();</span><br><span class="line">        <span class="built_in">vector</span>&lt;ImageRequest&gt; request = &#123; ImageRequest(<span class="string">"0"</span>, ImageType::Scene), ImageRequest(<span class="string">"1"</span>, ImageType::DepthPlanner, <span class="literal">true</span>) &#125;;</span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">vector</span>&lt;ImageResponse&gt;&amp; response = client.simGetImages(request);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"# of images received: "</span> &lt;&lt; response.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (response.<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter path with ending separator to save images (leave empty for no save)"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">string</span> path;</span><br><span class="line">            <span class="built_in">std</span>::getline(<span class="built_in">std</span>::<span class="built_in">cin</span>, path);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> ImageResponse&amp; image_info : response) &#123;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Image uint8 size: "</span> &lt;&lt; image_info.image_data_uint8.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Image float size: "</span> &lt;&lt; image_info.image_data_float.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (path != <span class="string">""</span>) &#123;</span><br><span class="line">                    <span class="built_in">std</span>::<span class="built_in">string</span> file_path = <span class="built_in">FileSystem</span>::combine(path, <span class="built_in">std</span>::to_string(image_info.time_stamp));</span><br><span class="line">                    <span class="keyword">if</span> (image_info.pixels_as_float) &#123;</span><br><span class="line">                        Utils::writePfmFile(image_info.image_data_float.data(), image_info.<span class="built_in">width</span>, image_info.<span class="built_in">height</span>,</span><br><span class="line">                            file_path + <span class="string">".pfm"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="built_in">std</span>::ofstream file(file_path + <span class="string">".png"</span>, <span class="built_in">std</span>::ios::binary);</span><br><span class="line">                        file.<span class="built_in">write</span>(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt;(image_info.image_data_uint8.data()), image_info.image_data_uint8.<span class="built_in">size</span>());</span><br><span class="line">                        file.<span class="built_in">close</span>();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//enable API control</span></span><br><span class="line">        client.enableApiControl(<span class="literal">true</span>);</span><br><span class="line">        CarApiBase::CarControls controls;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Press enter to drive forward"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="built_in">std</span>::<span class="built_in">cin</span>.<span class="built_in">get</span>();</span><br><span class="line">        controls.throttle = <span class="number">0.5f</span>;</span><br><span class="line">        controls.steering = <span class="number">0.0f</span>;</span><br><span class="line">        client.setCarControls(controls);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Press Enter to activate handbrake"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="built_in">std</span>::<span class="built_in">cin</span>.<span class="built_in">get</span>();</span><br><span class="line">        controls.handbrake = <span class="literal">true</span>;</span><br><span class="line">        client.setCarControls(controls);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Press Enter to take turn and drive backward"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="built_in">std</span>::<span class="built_in">cin</span>.<span class="built_in">get</span>();</span><br><span class="line">        controls.handbrake = <span class="literal">false</span>;</span><br><span class="line">        controls.throttle = <span class="number">-0.5</span>;</span><br><span class="line">        controls.steering = <span class="number">1</span>;</span><br><span class="line">        controls.is_manual_gear = <span class="literal">true</span>;</span><br><span class="line">        controls.manual_gear = <span class="number">-1</span>;</span><br><span class="line">        client.setCarControls(controls);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Press Enter to stop"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="built_in">std</span>::<span class="built_in">cin</span>.<span class="built_in">get</span>();</span><br><span class="line">        client.setCarControls(CarApiBase::CarControls());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (rpc::rpc_error&amp;  e) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> msg = e.get_error().as&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;();</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Exception raised by the API, something went wrong."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span> &lt;&lt; msg &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="built_in">std</span>::<span class="built_in">cin</span>.<span class="built_in">get</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Common-APIS"><a href="#Common-APIS" class="headerlink" title="Common APIS"></a><code>Common APIS</code></h2><p>以下方法均在类： <code>msr::airlib::CarRpcLibClient</code></p>
<ul>
<li><p><code>reset</code>: 重置汽车回初始状态 (PS: 调用这个方法, 汽车会重新出现在出生点, 状态均重置) . 你必须在调用 <code>reset</code> 之后再次调用 <code>enableApiControl</code> 和 <code>armDisarm</code></p>
<p>(<strong>PS</strong>: 好像不调用这两个函数, 其他方法依然生效, 不晓得是不是版本更新过的缘故) .</p>
</li>
<li><p><code>confirmConnection</code>: 每隔 1 秒检查链接状态, 并且在控制台输出连接进展.</p>
</li>
<li><p><code>enableApiControl</code>: 处于安全原因, 默认禁止 API 控制自动驾驶汽车, 完全人工控制的 (通常通过 RC 或者 手柄模拟) . 用户必须调用这个函数去请求通过 API 控制. 这就像人工驾驶汽车可能禁止 API 控制, 意味着<code>enableApiControl</code> 是不起作用的. 这个可以通过<code>isApiControlEnabled</code> 来检查.</p>
</li>
<li><p><code>isApiControlEnabled</code>: 返回 true 如果 API 控制被建立了. 如果是 false (默认设置), API 调用将会被忽略. 当成功调用<code>enableApiControl</code>, <code>isApiControlEnabled</code> 将返回 true.</p>
<p><strong>PS</strong>: 默认好像是 true.</p>
</li>
<li><p><code>ping</code>: 如果建立连接, 这个调用将会返回 true, 否则会阻塞知道直到超时.</p>
</li>
<li><p><code>simPrintLogMessage</code>: 在仿真窗口输出指定的 <code>message</code>. 如果 <code>message_param</code>也被提供, 那么也将输出. 如果这个 API 被调用时使用相同的 <code>message</code>值, 但是 <code>message_param</code>不同, 那么前一行将会被新行覆盖 (而不是创建新行来显示) . 举个例子, 当使用不同的 i 值调用 <code>simPrintLogMessage(&quot;Iteration: &quot;, to_string(i))</code> 时, 将在同一行保持更新. 合法的 severity 参数是 0 到 3, 分别以不同的颜色.</p>
<p><strong>PS</strong>: 不知道在哪儿看到这些输出日志).</p>
</li>
<li><p><code>simGetObjectPose</code>, <code>simSetObjectPose</code>: 获取和设置 Unreal 环境中指定对象的位姿. 这里的对象表示 Unreal 术语中的 ”actor”. 它们通过标签 (tag) 和名称 (name) 来搜索. 请记住这些显示在 UE Editor 中的名称是每次运行时 _自动生成 (auto-generated)_ 的, 并非永久的. 所以, 如果你想通过名称来引用 actor, 你必须在 UE Editor 中修改自动生成的名称. 你也可以在 Unreal Editor 中, 通过点击 actor 来完成对它添加一个标签. 然后去 <a href="https://answers.unrealengine.com/questions/543807/whats-the-difference-between-tag-and-tag.html" target="_blank" rel="noopener">Tags property</a> , 点击 “+” 号, 添加一些字符串值. 如果多个 actors 有相同的标签, 那么第一个符合的将会被返回. 如果没有符合的对象被找到, 那么将会返回 NaN. 返回的位姿值是在以玩家出生点为原点的 NED 坐标系下的国际标准单位值. 对于<code>simSetObjectPose</code>, 指定的 actor 必须将 <a href="https://docs.unrealengine.com/en-us/Engine/Actors/Mobility" target="_blank" rel="noopener">Mobility</a> 设置为可移动, 否则你将得到未定义行为. <code>simSetObjectPose</code> 有一个 <code>teleport</code> 参数, 表示对象正在 <a href="https://www.unrealengine.com/en-US/blog/moving-physical-objects" target="_blank" rel="noopener">moved through other objects</a> (<strong>PS</strong>： 瞬移？) , 如果移动成功, 则返回 true.</p>
<p><strong>PS:</strong> 见下图，如果要获取这辆车的位姿，调用的参数名应该是 <code>PhysXCar</code>, 调用 <code>SuvCarPawn-1</code> (自动生成的名称) 位姿值是 <code>NaN</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">msr::airlib::Pose pose_car = client.simGetObjectPose(<span class="string">"PhysXCar"</span>);</span><br></pre></td></tr></table></figure>
<p><img data-src="image-20200609012940736.png" alt="image-20200609012940736"></p>
</li>
</ul>
]]></content>
      <categories>
        <category>自动驾驶</category>
      </categories>
      <tags>
        <tag>自动驾驶</tag>
        <tag>AirSim</tag>
      </tags>
  </entry>
  <entry>
    <title>自动驾驶仿真 - AirSim (6) - 设置</title>
    <url>/posts/1270863220/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>接下去主要介绍一下 <code>AirSim</code> 的配置参数, 翻译了 <a href="https://microsoft.github.io/AirSim/settings" target="_blank" rel="noopener">官方</a> 文档.</p>
<a id="more"></a>
<hr>
<p>[TOC]</p>
<hr>
<h2 id="设置保存在哪儿-Where-are-Settings-Stored"><a href="#设置保存在哪儿-Where-are-Settings-Stored" class="headerlink" title="设置保存在哪儿? Where are Settings Stored"></a>设置保存在哪儿? Where are Settings Stored</h2><p>Windows: <code>Documents\AirSim</code><br>Linux: <code>~/Documents/AirSim</code></p>
<p>文件格式通常为 <a href="https://en.wikipedia.org/wiki/JSON" target="_blank" rel="noopener">json format</a>. 在首次启动 AirSim 是将创建 <code>settings.json</code> 文件, 不含任何设置. 为了避免产生问题, 通常使用 ASCII 格式来保存 json 文件.</p>
<h2 id="如何选择汽车还是飞行器-How-to-Chose-Between-Car-and-Multirotor"><a href="#如何选择汽车还是飞行器-How-to-Chose-Between-Car-and-Multirotor" class="headerlink" title="如何选择汽车还是飞行器? How to Chose Between Car and Multirotor"></a>如何选择汽车还是飞行器? How to Chose Between Car and Multirotor</h2><p>默认设置是飞行器. 要使用汽车, 则设置 <code>&quot;SimMode&quot;: &quot;Car&quot;</code> :</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"SettingsVersion"</span>: <span class="number">1.2</span>,</span><br><span class="line">  <span class="attr">"SimMode"</span>: <span class="string">"Car"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>选择汽车, 则设置 <code>&quot;SimMode&quot;: &quot;Multirotor&quot;</code>. 如果想让用户选择载具类型, 则设置 <code>&quot;SimMode&quot;: &quot;&quot;</code>.</p>
<h2 id="可用设置及默认值-Available-Settings-and-Their-Defaults"><a href="#可用设置及默认值-Available-Settings-and-Their-Defaults" class="headerlink" title="可用设置及默认值 Available Settings and Their Defaults"></a>可用设置及默认值 Available Settings and Their Defaults</h2><p>下述是完整的可用设置参数及其默认值的列表. 如果在 json 文件中没有设置参数, 则会使用默认值. 有些默认参数简单地指定为 <code>&quot;&quot;</code>, 表示实际参数值需要你根据实际使用的载具来选择. 举个例子, <code>ViewMode</code> 默认参数为 <code>&quot;&quot;</code> , 针对飞行器转换成 <code>&quot;FlyWithMe&quot;</code>, 针对汽车则是 <code>&quot;SpringArmChase&quot;</code> .</p>
<p><strong>警告:</strong> 不要把拷贝下面的文本到你自己的 settings.json. 我们强烈建议只加入你不想设置为默认值的参数. 唯一需要设置的元素是 <code>&quot;SettingsVersion&quot;</code>.</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"SimMode"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="attr">"ClockType"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="attr">"ClockSpeed"</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">"LocalHostIp"</span>: <span class="string">"127.0.0.1"</span>,</span><br><span class="line">  <span class="attr">"RecordUIVisible"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"LogMessagesVisible"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"ViewMode"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="attr">"RpcEnabled"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"EngineSound"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"PhysicsEngineName"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="attr">"SpeedUnitFactor"</span>: <span class="number">1.0</span>,</span><br><span class="line">  <span class="attr">"SpeedUnitLabel"</span>: <span class="string">"m/s"</span>,</span><br><span class="line">  <span class="attr">"Recording"</span>: &#123;</span><br><span class="line">    <span class="attr">"RecordOnMove"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"RecordInterval"</span>: <span class="number">0.05</span>,</span><br><span class="line">    <span class="attr">"Cameras"</span>: [</span><br><span class="line">        &#123; <span class="attr">"CameraName"</span>: <span class="string">"0"</span>, <span class="attr">"ImageType"</span>: <span class="number">0</span>, <span class="attr">"PixelsAsFloat"</span>: <span class="literal">false</span>, <span class="attr">"Compress"</span>: <span class="literal">true</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"CameraDefaults"</span>: &#123;</span><br><span class="line">    <span class="attr">"CaptureSettings"</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"ImageType"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">"Width"</span>: <span class="number">256</span>,</span><br><span class="line">        <span class="attr">"Height"</span>: <span class="number">144</span>,</span><br><span class="line">        <span class="attr">"FOV_Degrees"</span>: <span class="number">90</span>,</span><br><span class="line">        <span class="attr">"AutoExposureSpeed"</span>: <span class="number">100</span>,</span><br><span class="line">        <span class="attr">"AutoExposureBias"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">"AutoExposureMaxBrightness"</span>: <span class="number">0.64</span>,</span><br><span class="line">        <span class="attr">"AutoExposureMinBrightness"</span>: <span class="number">0.03</span>,</span><br><span class="line">        <span class="attr">"MotionBlurAmount"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">"TargetGamma"</span>: <span class="number">1.0</span>,</span><br><span class="line">        <span class="attr">"ProjectionMode"</span>: <span class="string">""</span>,</span><br><span class="line">        <span class="attr">"OrthoWidth"</span>: <span class="number">5.12</span></span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"NoiseSettings"</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"Enabled"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">"ImageType"</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="attr">"RandContrib"</span>: <span class="number">0.2</span>,</span><br><span class="line">        <span class="attr">"RandSpeed"</span>: <span class="number">100000.0</span>,</span><br><span class="line">        <span class="attr">"RandSize"</span>: <span class="number">500.0</span>,</span><br><span class="line">        <span class="attr">"RandDensity"</span>: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">        <span class="attr">"HorzWaveContrib"</span>:<span class="number">0.03</span>,</span><br><span class="line">        <span class="attr">"HorzWaveStrength"</span>: <span class="number">0.08</span>,</span><br><span class="line">        <span class="attr">"HorzWaveVertSize"</span>: <span class="number">1.0</span>,</span><br><span class="line">        <span class="attr">"HorzWaveScreenSize"</span>: <span class="number">1.0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="attr">"HorzNoiseLinesContrib"</span>: <span class="number">1.0</span>,</span><br><span class="line">        <span class="attr">"HorzNoiseLinesDensityY"</span>: <span class="number">0.01</span>,</span><br><span class="line">        <span class="attr">"HorzNoiseLinesDensityXY"</span>: <span class="number">0.5</span>,</span><br><span class="line"></span><br><span class="line">        <span class="attr">"HorzDistortionContrib"</span>: <span class="number">1.0</span>,</span><br><span class="line">        <span class="attr">"HorzDistortionStrength"</span>: <span class="number">0.002</span></span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"Gimbal"</span>: &#123;</span><br><span class="line">      <span class="attr">"Stabilization"</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">"Pitch"</span>: NaN, <span class="attr">"Roll"</span>: NaN, <span class="attr">"Yaw"</span>: NaN</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="string">"X"</span>: NaN, <span class="attr">"Y"</span>: NaN, <span class="attr">"Z"</span>: NaN,</span><br><span class="line">    <span class="attr">"Pitch"</span>: NaN, <span class="attr">"Roll"</span>: NaN, <span class="attr">"Yaw"</span>: NaN</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"OriginGeopoint"</span>: &#123;</span><br><span class="line">    <span class="attr">"Latitude"</span>: <span class="number">47.641468</span>,</span><br><span class="line">    <span class="attr">"Longitude"</span>: <span class="number">-122.140165</span>,</span><br><span class="line">    <span class="attr">"Altitude"</span>: <span class="number">122</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"TimeOfDay"</span>: &#123;</span><br><span class="line">    <span class="attr">"Enabled"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"StartDateTime"</span>: <span class="string">""</span>,</span><br><span class="line">    <span class="attr">"CelestialClockSpeed"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"StartDateTimeDst"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"UpdateIntervalSecs"</span>: <span class="number">60</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"SubWindows"</span>: [</span><br><span class="line">    &#123;<span class="attr">"WindowID"</span>: <span class="number">0</span>, <span class="attr">"CameraName"</span>: <span class="string">"0"</span>, <span class="attr">"ImageType"</span>: <span class="number">3</span>, <span class="attr">"Visible"</span>: <span class="literal">false</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">"WindowID"</span>: <span class="number">1</span>, <span class="attr">"CameraName"</span>: <span class="string">"0"</span>, <span class="attr">"ImageType"</span>: <span class="number">5</span>, <span class="attr">"Visible"</span>: <span class="literal">false</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">"WindowID"</span>: <span class="number">2</span>, <span class="attr">"CameraName"</span>: <span class="string">"0"</span>, <span class="attr">"ImageType"</span>: <span class="number">0</span>, <span class="attr">"Visible"</span>: <span class="literal">false</span>&#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"SegmentationSettings"</span>: &#123;</span><br><span class="line">    <span class="attr">"InitMethod"</span>: <span class="string">""</span>,</span><br><span class="line">    <span class="attr">"MeshNamingMethod"</span>: <span class="string">""</span>,</span><br><span class="line">    <span class="attr">"OverrideExisting"</span>: <span class="literal">false</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"PawnPaths"</span>: &#123;</span><br><span class="line">    <span class="attr">"BareboneCar"</span>: &#123;<span class="attr">"PawnBP"</span>: <span class="string">"Class'/AirSim/VehicleAdv/Vehicle/VehicleAdvPawn.VehicleAdvPawn_C'"</span>&#125;,</span><br><span class="line">    <span class="attr">"DefaultCar"</span>: &#123;<span class="attr">"PawnBP"</span>: <span class="string">"Class'/AirSim/VehicleAdv/SUV/SuvCarPawn.SuvCarPawn_C'"</span>&#125;,</span><br><span class="line">    <span class="attr">"DefaultQuadrotor"</span>: &#123;<span class="attr">"PawnBP"</span>: <span class="string">"Class'/AirSim/Blueprints/BP_FlyingPawn.BP_FlyingPawn_C'"</span>&#125;,</span><br><span class="line">    <span class="attr">"DefaultComputerVision"</span>: &#123;<span class="attr">"PawnBP"</span>: <span class="string">"Class'/AirSim/Blueprints/BP_ComputerVisionPawn.BP_ComputerVisionPawn_C'"</span>&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"Vehicles"</span>: &#123;</span><br><span class="line">    <span class="attr">"SimpleFlight"</span>: &#123;</span><br><span class="line">      <span class="attr">"VehicleType"</span>: <span class="string">"SimpleFlight"</span>,</span><br><span class="line">      <span class="attr">"DefaultVehicleState"</span>: <span class="string">"Armed"</span>,</span><br><span class="line">      <span class="attr">"AutoCreate"</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">"PawnPath"</span>: <span class="string">""</span>,</span><br><span class="line">      <span class="attr">"EnableCollisionPassthrogh"</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">"EnableCollisions"</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">"AllowAPIAlways"</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">"RC"</span>: &#123;</span><br><span class="line">        <span class="attr">"RemoteControlID"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">"AllowAPIWhenDisconnected"</span>: <span class="literal">false</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"Cameras"</span>: &#123;</span><br><span class="line">        <span class="comment">//same elements as CameraDefaults above, key as name</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"X"</span>: NaN, <span class="attr">"Y"</span>: NaN, <span class="attr">"Z"</span>: NaN,</span><br><span class="line">      <span class="attr">"Pitch"</span>: NaN, <span class="attr">"Roll"</span>: NaN, <span class="attr">"Yaw"</span>: NaN</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"PhysXCar"</span>: &#123;</span><br><span class="line">      <span class="attr">"VehicleType"</span>: <span class="string">"PhysXCar"</span>,</span><br><span class="line">      <span class="attr">"DefaultVehicleState"</span>: <span class="string">""</span>,</span><br><span class="line">      <span class="attr">"AutoCreate"</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">"PawnPath"</span>: <span class="string">""</span>,</span><br><span class="line">      <span class="attr">"EnableCollisionPassthrogh"</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">"EnableCollisions"</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">"RC"</span>: &#123;</span><br><span class="line">        <span class="attr">"RemoteControlID"</span>: <span class="number">-1</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"Cameras"</span>: &#123;</span><br><span class="line">        <span class="attr">"MyCamera1"</span>: &#123;</span><br><span class="line">          <span class="comment">//same elements as elements inside CameraDefaults above</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"MyCamera2"</span>: &#123;</span><br><span class="line">          <span class="comment">//same elements as elements inside CameraDefaults above</span></span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"X"</span>: NaN, <span class="attr">"Y"</span>: NaN, <span class="attr">"Z"</span>: NaN,</span><br><span class="line">      <span class="attr">"Pitch"</span>: NaN, <span class="attr">"Roll"</span>: NaN, <span class="attr">"Yaw"</span>: NaN</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="仿真模式-SimMode"><a href="#仿真模式-SimMode" class="headerlink" title="仿真模式 SimMode"></a>仿真模式 SimMode</h2><p>SimMode 决定了将使用哪种仿真模式. 目前支持一下参数值:</p>
<ul>
<li><code>&quot;&quot;</code>: 提示用户选择载具类型, 飞行器或者汽车</li>
<li><code>&quot;Multirotor&quot;</code>: 使用飞行器仿真</li>
<li><code>&quot;Car&quot;</code>: 使用汽车仿真</li>
<li><code>&quot;ComputerVision&quot;</code>: 只用摄像头, 没有载具和物理 (<strong>PS</strong>: 应该泛指物理碰撞、接触之类的交互)</li>
</ul>
<h2 id="视角模式-ViewMode"><a href="#视角模式-ViewMode" class="headerlink" title="视角模式 ViewMode"></a>视角模式 ViewMode</h2><p>ViewMode 决定哪儿相机被设置为默认以及相机如何跟随载具 (<strong>PS:</strong> 就是在用户的观察视角, 而不是载具摄像头的视角). 对于无人机, 默认 ViewMode 是<code>&quot;FlyWithMe&quot;</code> , 汽车的 ViewMode 是 <code>&quot;SpringArmChase&quot;</code>.</p>
<ul>
<li><code>FlyWithMe</code>: 从 6 个自由度跟随</li>
<li><code>GroundObserver</code>: 在 XY 平面内自由跟随.</li>
<li><code>Fpv</code>: 载具前部摄像机视角 (<strong>PS:</strong> 第一人称, 汽车的话就是驾驶室人眼的位置)</li>
<li><code>Manual</code>: 不会自动移动摄像机. 通过方向键和 ASWD 键来移动摄摄像机.</li>
<li><code>SpringArmChase</code>: 通过以固定在载具上以弹簧杆 (不可见)相连的摄像机视角跟随 (所以看起来有点延迟) (<strong>PS</strong>: 相当于在载具上装了根延长杆 (类似手持的拍照杆), 延长杆有点弹性, 导致载具起步时, 视角有种被拽着一起动的感觉) .</li>
<li><code>NoDisplay</code>: 这将冻结主屏幕的渲染, 但是对子窗口、录频及 APIs 的渲染依然激活. (<strong>PS</strong>: UE 里面子窗口好像也是黑的, 但是 APIs 可以调用出来图像). 在那些你只关心获取到的图像而不关心如何在主屏幕渲染的 “无用” 模式下, 这个模式能节省资源. 这也可以提高录像图像的 FPS.</li>
</ul>
<h2 id="时间-TimeOfDay"><a href="#时间-TimeOfDay" class="headerlink" title="时间 TimeOfDay"></a>时间 TimeOfDay</h2><p>该设置控制环境中太阳的位置. 默认 <code>Enabled</code> 是 false, 意味这太阳的位置无论何时太阳都在场景的左侧并且一直不变. 如果 <code>Enabled</code> 是 true, 那么太阳的位置将会通过在 <code>OriginGeopoint</code> 节点中设定的经度, 纬度, 高度结合在 <code>StartDateTime</code> 设定的时间来计算. <code>StartDateTime</code> 是一串 <a href="https://en.cppreference.com/w/cpp/io/manip/get_time" target="_blank" rel="noopener">%Y-%m-%d %H:%M:%S</a> 格式的字符串, 举个例子, <code>2018-02-12 15:20:00</code>. 如果字符串为空, 那么就用当前的日期和时间. 如果 <code>StartDateTimeDst</code> 是 true, 那么我们将调整白天时长. 太阳的位置根据 <code>UpdateIntervalSecs</code>设定的时间间隔来持续更新. 在某些情况下, 可能希望天体时钟可以比仿真始终更快或者更慢. 这可以通过<code>CelestialClockSpeed</code>设置, 举个例子, 值 100 意味这仿真时钟 1 秒, 太阳的位置将提前 100 秒, 所以天空中的太阳看起来移动的更加快了.</p>
<p><strong>PS:</strong> 怎么设置太阳都没有动, 改变时间倒是太阳的起始点位置变了.</p>
<p>参考 <a href="apis.md#time-of-day-api">Time of Day API</a>.</p>
<h2 id="地理原点-OriginGeopoint"><a href="#地理原点-OriginGeopoint" class="headerlink" title="地理原点 OriginGeopoint"></a>地理原点 OriginGeopoint</h2><p>这个将设置玩家出生点在 Unreal 环境中的经度, 维度, 高度. 载具的原点通过这个值来转换. 记住所有通过 APIs 的坐标系都是基于国际标准单位制的 NED 坐标系统. 这意味着每个载具都开始于 NED 坐标系下的 (0, 0, 0) 点. 每日的时间设置也是根据<code>OriginGeopoint</code> 设定的地理坐标系计算.</p>
<h2 id="子窗口-SubWindows"><a href="#子窗口-SubWindows" class="headerlink" title="子窗口 SubWindows"></a>子窗口 SubWindows</h2><p>这个设定指定按下 0 键显示的 3 个子窗口. WindowsID 可以是 0 到 2, CameraName 可以是载具上的任何一个 <a href="image_apis.md#available_cameras">可用的相机</a>. ImageType 的值根据 <a href="image_apis.md#available-imagetype">ImageType enum</a> 决定显示哪类图片. 举个例子, 对于下面的载具, 分别显示了驾驶员视角, 前视角, 后视角的场景, 深度, 分割图像. .</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"SubWindows": [</span><br><span class="line">  &#123;"WindowID": 0, "ImageType": 0, "CameraName": "3", "Visible": true&#125;,</span><br><span class="line">  &#123;"WindowID": 1, "ImageType": 3, "CameraName": "0", "Visible": true&#125;,</span><br><span class="line">  &#123;<span class="attr">"WindowID"</span>: <span class="number">2</span>, <span class="attr">"ImageType"</span>: <span class="number">6</span>, <span class="attr">"CameraName"</span>: <span class="string">"4"</span>, <span class="attr">"Visible"</span>: <span class="literal">true</span>&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h2 id="记录-Recording"><a href="#记录-Recording" class="headerlink" title="记录 Recording"></a>记录 Recording</h2><p>记录功能允许你已设定的时间间隔采集类似位置, 方向, 速度的图像. 你可以通过按下红色的 Recored 按钮或者 R 键来开始记录. 数据将被保存在 <code>Documents\AirSim</code> 文件夹中, 每个记录会话都放在一个时间戳命名的子文件中, 以 tab 分割的文本 (<strong>PS:</strong> 举个例子, Record 的数据被保存在已时间戳命名的文件夹中 <code>2020-06-14-13-43-41</code> 文件夹中, 图片放在 <code>image</code> 子文件夹中, 数据放在 <code>airsim_rec.txt</code> 文本文件中, 文本以 Tab 分割).</p>
<ul>
<li><code>RecordInterval</code>: 设定采样图片的最小间隔, 秒.</li>
<li><code>RecordOnMove</code>: 设定在载具位置和姿态没有变化的时候不要采集.</li>
<li><code>Cameras</code>: 控制采集哪个相机的图像. 默认的采集 camera 0 的压缩的 png 格式的场景图像. 这个设定是一个 json 数组的形式, 所以你可以指定采集多个相机不同<a href="settings.md#image-capture-settings">image types</a>的图像, 当 PixelsAsFloat 是 true, 图像将被以 <a href="pfm.md">pfm</a> 格式保存而不是 png.</li>
</ul>
<h2 id="时钟速度-ClockSpeed"><a href="#时钟速度-ClockSpeed" class="headerlink" title="时钟速度 ClockSpeed"></a>时钟速度 ClockSpeed</h2><p>这个设置将允许你设置仿真的时钟. 举个例子, 5.0 表示当挂钟过了 1 秒, 仿真时间过了 5.0 秒 (即仿真运行更快了). 值 0.1 表示仿真比挂钟慢了 10X. 值 1 表示仿真时间和真实时间一样. 当仿真时钟运行更快的情况下, 仿真质量可能降低, 意识到这点很重要. 所以你可能看到一些物体穿模, 因为碰撞没有被探测到. 然后, 降低仿真时钟 (即值 &lt; 1.0) 通常能提高仿真质量.</p>
<h2 id="分割设置-Segmentation-Settings"><a href="#分割设置-Segmentation-Settings" class="headerlink" title="分割设置 Segmentation Settings"></a>分割设置 Segmentation Settings</h2><p><code>InitMethod</code> 决定如何在启动的时候初始化 object IDs 来生成 <a href="image_apis.md#segmentation">segmentation</a>. 值 <code>&quot;&quot;</code> 或者 <code>&quot;CommonObjectsRandomIDs&quot;</code> (默认) 意味着在启动时给每个 object 分配随机的 IDs. 生成的分割图中, 每个 object 也被分配为随机的颜色. 值 <code>&quot;None&quot;</code> 意味这不初始化 object IDs. 这将造成分割视图只有单一固定的颜色. 如果你计划通过 <a href="image_apis.md#segmentation">APIs</a> 来设置 object IDs 会有用. 这也能节约大场景的启动延时, 像 CityEnviron.</p>
<p>如果 <code>OverrideExisting</code> 是 <code>false</code>, 那么初始化时不会改变已分配的非零的 object IDs , 否则会.</p>
<p>如果 <code>MeshNamingMethod</code> 为 <code>&quot;&quot;</code> 或者 <code>&quot;OwnerName&quot;</code> , 那么我们用网格拥有者的名字来生成随机哈希值作为 object IDs. 如果是<code>&quot;StaticMeshName&quot;</code> , 那么我们用静态的网格名称来生成随机哈希值作为 object IDs. 记住这种方法通常不能区分相同静态网格的单个实例, 但是名称通常更加直观.</p>
<h2 id="相机设置-Camera-Settings"><a href="#相机设置-Camera-Settings" class="headerlink" title="相机设置 Camera Settings"></a>相机设置 Camera Settings</h2><p><code>CameraDefaults</code> 作为所有相机设置的根节点元素. 默认值可以被 <code>Vehicles</code> 中的 <code>Cameras</code> 元素中的单个相机设置覆盖.</p>
<h3 id="Note-on-ImageType-element"><a href="#Note-on-ImageType-element" class="headerlink" title="Note on ImageType element"></a>Note on ImageType element</h3><p>JSON 数组的<code>ImageType</code> 元素决定哪种图像类型将被运用. 可用的值在图像类型那一节说明过. 此外, 我们也支持特殊的值 <code>ImageType: -1</code> , 来对外部相机设置 (即你在屏幕上看到的场景视角).</p>
<p>举个例子, <code>CaptureSettings</code> 元素是 json 数组, 所以你可以很容易地添加多个图像类型的设置.</p>
<h3 id="捕捉设置-CaptureSettings"><a href="#捕捉设置-CaptureSettings" class="headerlink" title="捕捉设置 CaptureSettings"></a>捕捉设置 CaptureSettings</h3><p><code>CaptureSettings</code> 决定如何渲染不同的图像类型, 比如 scene, depth, disparity, surface normals 和 segmentation. 宽度, 高度, FOV 的设置应该无需多言. <code>AutoExposureSpeed</code>决定眼睛的适应速度多快 (<strong>PS</strong>: 自动曝光速度?) . 通常我们设定一个较大值, 比如 100 来避免图像采集中的假影. 类似地, 我们默认设置 <code>MotionBlurAmount</code> 为 0 来避免地面图像地假影. <code>ProjectionMode</code> 决定采集的相机用的投影模式, 该值可以是 <code>&quot;perspective</code>“ (默认) 或者 <code>&quot;orthographic&quot;</code>. 如果投影模式是 <code>&quot;orthographic&quot;</code> , 那么<code>OrthoWidth</code> 决定以米制宽度来采集投影区域.</p>
<p>更多其他设置, 请参考 <a href="https://docs.unrealengine.com/latest/INT/Engine/Rendering/PostProcessEffects/AutomaticExposure/" target="_blank" rel="noopener">this article</a>.</p>
<p>(<strong>PS:</strong> 这里不太懂, 没有图像相关的知识)</p>
<h3 id="噪声设置-NoiseSettings"><a href="#噪声设置-NoiseSettings" class="headerlink" title="噪声设置 NoiseSettings"></a>噪声设置 NoiseSettings</h3><p><code>NoiseSettings</code> 允许对指定的图像类型增加噪声, 通过模拟相机传感器的噪声, 干涉和其他假影. 默认美哟添加噪声 即 <code>Enabled: false</code>. 如果你设置 <code>Enabled: true</code> , 那么不同类型的噪声, 干涉, 假影生效, 每个都可以被进一步设置. 噪声的效果通过在 Unreal 引擎中后期材质处理是添加阴影来实现, 称为 <a href="https://github.com/Microsoft/AirSim/blob/master/Unreal/Plugins/AirSim/Content/HUDAssets/CameraSensorNoise.uasset" target="_blank" rel="noopener">CameraSensorNoise</a>.</p>
<p>相机的噪声和干涉仿真的例子:</p>
<p><a href="https://youtu.be/1BeCEZmQyp0" target="_blank" rel="noopener"><img data-src="images/camera_noise_demo.png" alt="AirSim Drone Demo Video"></a></p>
<h4 id="随机噪声-Random-noise"><a href="#随机噪声-Random-noise" class="headerlink" title="随机噪声 Random noise"></a>随机噪声 Random noise</h4><p>这将通过下述参数来增加随机噪声斑点.</p>
<ul>
<li><code>RandContrib</code>: 这决定了噪声像素与图像像素的混合比率, 0 表示没有噪声, 1 表示只有噪声.</li>
<li><code>RandSpeed</code>: 这决定了噪音波动的速度, 1 表示没有波动, 高值如 1E6 表示完全波动.</li>
<li><code>RandSize</code>: 这决定了噪声的粗糙程度, 1 表示每个像素都有自己的噪声, 较大的值表示多个像素有相同的噪声值.</li>
<li><code>RandDensity</code>: 这决定了有多少像素会有噪声, 1 表示所有像素都有噪声, 较高的值意味着较少的像素 (指数).</li>
</ul>
<h4 id="Horizontal-bump-distortion"><a href="#Horizontal-bump-distortion" class="headerlink" title="Horizontal bump distortion"></a>Horizontal bump distortion</h4><p>这增加了水平凸起/闪烁/重影效果.</p>
<ul>
<li><code>HorzWaveContrib</code>: 这决定了噪声像素与图像像素的混合比率, 0 表示没有噪声, 1 表示只有噪声</li>
<li><code>HorzWaveStrength</code>: 这决定了该影响的整体强度.</li>
<li><code>HorzWaveVertSize</code>: 这决定了有多少垂直像素会受到影响</li>
<li><code>HorzWaveScreenSize</code>:这决定了有大的屏幕受影响</li>
</ul>
<h4 id="Horizontal-noise-lines"><a href="#Horizontal-noise-lines" class="headerlink" title="Horizontal noise lines"></a>Horizontal noise lines</h4><p>这在水平线上增加了噪声区域.</p>
<ul>
<li><code>HorzNoiseLinesContrib</code>: 这决定了噪声像素与图像像素的混合比率, 0 表示没有噪声, 1 表示只有噪声</li>
<li><code>HorzNoiseLinesDensityY</code>: 这决定了水平线中有多少像素会受到影响.</li>
<li><code>HorzNoiseLinesDensityXY</code>: 这决定了屏幕上有多少行会受到影响.</li>
</ul>
<h4 id="Horizontal-line-distortion"><a href="#Horizontal-line-distortion" class="headerlink" title="Horizontal line distortion"></a>Horizontal line distortion</h4><p>这增加了水平线上的波动.</p>
<ul>
<li><code>HorzDistortionContrib</code>: 这决定了噪声像素与图像像素的混合比率, 0 表示没有噪声, 1 表示只有噪声.</li>
<li><code>HorzDistortionStrength</code>: 这决定了失真的强度</li>
</ul>
<h3 id="云台-Gimbal"><a href="#云台-Gimbal" class="headerlink" title="云台 Gimbal"></a>云台 Gimbal</h3><p><code>Gimbal</code> 元素允许冻结相机的俯仰, 翻转, 偏航. 这个设置会被忽略, 除非 <code>ImageType</code> 是 -1. <code>Stabilization</code> 默认设置为 0 , 意味着没有云台, 即相机在所有轴上都随着物体发生变化. 值 1 意味着完全稳定. 介于 0 到 1 之间的值作为对在 <code>Pitch</code>, <code>Roll</code> 和<code>Yaw</code> 元素被指定的固定角度 (角度, 世界坐标系) 和载具的方向的权重. 当任一角度被省略或者设置为 <code>NaN</code>, 那么这个角度是不稳定的 (即随着物体而运动).</p>
<p><strong>PS</strong>: 应该是云台</p>
<h2 id="载具设置-Vehicles-Settings"><a href="#载具设置-Vehicles-Settings" class="headerlink" title="载具设置 Vehicles Settings"></a>载具设置 Vehicles Settings</h2><p>每种仿真模式将遍历在该设置中的载具列表, 然后创建那些 <code>&quot;AutoCreate&quot;: true</code> 的载具. 每个被设定的载具有个成为该载具名称的键值. 如果 <code>&quot;Vehicles&quot;</code> 元素缺省, 那么这个列表将被填入名为 <code>&quot;PhysXCar&quot;</code> 的默认汽车和名为 <code>&quot;SimpleFlight&quot;</code> 默认飞行器.</p>
<h3 id="通用载具设置-Common-Vehicle-Setting"><a href="#通用载具设置-Common-Vehicle-Setting" class="headerlink" title="通用载具设置 Common Vehicle Setting"></a>通用载具设置 Common Vehicle Setting</h3><ul>
<li><code>VehicleType</code>: 可以是 <code>PhysXCar</code>, <code>SimpleFlight</code>, <code>PX4Multirotor</code> 或者 <code>ComputerVision</code>. 这个没有默认值, 所以必须被指定.</li>
<li><code>PawnPath</code>: 这个允许覆盖载具使用的 pawn blueprint. 举个例子, 你可以创建一个新的 pawn blueprint , 继承于 ACarPawn, 作为你自己项目中而不在 AirSim 代码中的仓储机器人, 然后在这里指定路径. 参见 <a href="#PawnPaths">PawnPaths</a>.</li>
<li><code>DefaultVehicleState</code>: 飞行器可用的值为 <code>Armed</code> 或 <code>Disarmed</code>.</li>
<li><code>AutoCreate</code>: 如果为 true, 那么这个载具将被加载 (如果选中的 sim 模式支持.</li>
<li><code>RC</code>: 这个子元素允许通过<code>RemoteControlID</code>指定载具使用哪个远程控制器. 值 -1 意味着使用键盘 (飞行器暂时不支持). 值 &gt;= 0 指定被连接上的远程控制器其中的一个. 举个例子, 在 Window 中, 可用的 RCs 列表可以在 Game Controllers 面板中看到.</li>
<li><code>X, Y, Z, Yaw, Roll, Pitch</code>: 这个元素允许你指定载具的初始位置和方向. 位置是在 SI 单位制 NED 坐标系中, 坐标系原点被设置在 Unreal 环境中的玩家出生点. 方向以角度指定.</li>
<li><code>IsFpvVehicle</code>: 这个设置允许指定哪个载具的摄像头被跟随. 当 <code>ViewMode</code> 被设置为 <code>Fpv</code> 时, 这个视角将被显示. 默认情况下, AirSim 选择设置中的第一个载具作为 FPV 载具.</li>
<li><code>Cameras</code>: 这个元素设定载具的相机设置. 这个元素中的关键是 <a href="image_apis.md#available_cameras">available camera</a> 的名称, 这个值和上述 <code>CameraDefaults</code> 的一致. 举个例子, 为了改变前面中间相机 FOV 为 120 度, 你可以用这个 <code>Vehicles</code> 设置:</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"Vehicles": &#123;</span><br><span class="line">    "FishEyeDrone": &#123;</span><br><span class="line">      "VehicleType": "SimpleFlight",</span><br><span class="line">      "Cameras": &#123;</span><br><span class="line">        "front-center": &#123;</span><br><span class="line">          "CaptureSettings": [</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="attr">"ImageType"</span>: <span class="number">0</span>,</span><br><span class="line">              <span class="attr">"FOV_Degrees"</span>: <span class="number">120</span></span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Using-PX4"><a href="#Using-PX4" class="headerlink" title="Using PX4"></a>Using PX4</h3><p>By default we use <a href="simple_flight.md">simple_flight</a> so you don’t have to do separate HITL or SITL setups. We also support <a href="px4_setup.md">“PX4”</a> for advanced users. To use PX4 with AirSim, you can use the following for <code>Vehicles</code> setting:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"Vehicles": &#123;</span><br><span class="line">    "PX4": &#123;</span><br><span class="line">      "VehicleType": "PX4Multirotor",</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Additional-PX4-Settings"><a href="#Additional-PX4-Settings" class="headerlink" title="Additional PX4 Settings"></a>Additional PX4 Settings</h4><p>The defaults for PX4 is to enable hardware-in-loop setup. There are various other settings available for PX4 as follows with their default values:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"Vehicles": &#123;</span><br><span class="line">    "PX4": &#123;</span><br><span class="line">      "VehicleType": "PX4Multirotor",</span><br><span class="line"></span><br><span class="line">      "ControlIp": "127.0.0.1",</span><br><span class="line">      "ControlPort": 14580,</span><br><span class="line">      "LogViewerHostIp": "127.0.0.1",</span><br><span class="line">      "LogViewerPort": 14388,</span><br><span class="line">      "OffboardCompID": 1,</span><br><span class="line">      "OffboardSysID": 134,</span><br><span class="line">      "QgcHostIp": "127.0.0.1",</span><br><span class="line">      "QgcPort": 14550,</span><br><span class="line">      "SerialBaudRate": 115200,</span><br><span class="line">      "SerialPort": "*",</span><br><span class="line">      "SimCompID": 42,</span><br><span class="line">      "SimSysID": 142,</span><br><span class="line">      "TcpPort": 4560,</span><br><span class="line">      "UdpIp": "127.0.0.1",</span><br><span class="line">      "UdpPort": 14560,</span><br><span class="line">      "UseSerial": true,</span><br><span class="line">      "UseTcp": false,</span><br><span class="line">      "VehicleCompID": 1,</span><br><span class="line">      "VehicleSysID": 135,</span><br><span class="line">      "Model": "Generic",</span><br><span class="line">      "LocalHostIp": "127.0.0.1"</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>These settings define the MavLink SystemId and ComponentId for the Simulator (SimSysID, SimCompID), and for the vehicle (VehicleSysID, VehicleCompID)<br>and the node that allows remote control of the drone from another app this is called the offboard node (OffboardSysID, OffboardCompID).</p>
<p>If you want the simulator to also talk to your ground control app (like QGroundControl) you can also set the UDP address for that in case you want to run<br>that on a different machine (QgcHostIp, QgcPort). The default is local host so QGroundControl should “just work” if it is running on the same machine.</p>
<p>You can connect the simulator to the LogViewer app, provided in this repo, by setting the UDP address for that (LogViewerHostIp, LogViewerPort).</p>
<p>And for each flying drone added to the simulator there is a named block of additional settings. In the above you see the default name “PX4”. You can change this name from the Unreal Editor when you add a new BP_FlyingPawn asset. You will see these properties grouped under the category “MavLink”. The MavLink node for this pawn can be remote over UDP or it can be connected to a local serial port. If serial then set UseSerial to true, otherwise set UseSerial to false. For serial connections you also need to set the appropriate SerialBaudRate. The default of 115200 works with Pixhawk version 2 over USB.</p>
<p>When communicating with the PX4 drone over serial port both the HIL<em>\</em> messages and vehicle control messages share the same serial port.<br>When communicating over UDP or TCP PX4 requires two separate channels. If UseTcp is false, then UdpIp, UdpPort are used to send HIL<em>\</em> messages,<br>otherwise the TcpPort is used. TCP support in PX4 was added in 1.9.2 with the <code>lockstep</code> feature because the guarantee of message delivery that<br>TCP provides is required for the proper functioning of lockstep. AirSim becomes a TCP server in that case, and waits for a connection<br>from the PX4 app. The second channel for controlling the vehicle is defined by (ControlIp, ControlPort) and is always a UDP channel.</p>
<h2 id="其他设置-Other-Settings"><a href="#其他设置-Other-Settings" class="headerlink" title="其他设置 Other Settings"></a>其他设置 Other Settings</h2><h3 id="引擎声音-EngineSound"><a href="#引擎声音-EngineSound" class="headerlink" title="引擎声音 EngineSound"></a>引擎声音 EngineSound</h3><p>通过设置 <a href="settings.md">setting</a> <code>&quot;EngineSound&quot;: false</code> 来关闭引擎声音. 目前这个设置只在汽车上运用.</p>
<h3 id="PawnPaths"><a href="#PawnPaths" class="headerlink" title="PawnPaths"></a>PawnPaths</h3><p>This allows you to specify your own vehicle pawn blueprints, for example, you can replace the default car in AirSim with your own car. Your vehicle BP can reside in Content folder of your own Unreal project (i.e. outside of AirSim plugin folder). For example, if you have a car BP located in file <code>Content\MyCar\MySedanBP.uasset</code> in your project then you can set <code>&quot;DefaultCar&quot;: {&quot;PawnBP&quot;:&quot;Class&#39;/Game/MyCar/MySedanBP.MySedanBP_C&#39;&quot;}</code>. The <code>XYZ.XYZ_C</code> is a special notation required to specify class for BP <code>XYZ</code>. Please note that your BP must be derived from CarPawn class. By default this is not the case but you can re-parent the BP using the “Class Settings” button in toolbar in UE editor after you open the BP and then choosing “Car Pawn” for Parent Class settings in Class Options. It’s also a good idea to disable “Auto Possess Player” and “Auto Possess AI” as well as set AI Controller Class to None in BP details. Please make sure your asset is included for cooking in packaging options if you are creating binary.</p>
<h3 id="物理引擎名称-PhysicsEngineName"><a href="#物理引擎名称-PhysicsEngineName" class="headerlink" title="物理引擎名称 PhysicsEngineName"></a>物理引擎名称 PhysicsEngineName</h3><p>对于汽车, 我们目前只支持 <code>PhysX</code> (忽略这是设置值), 对于飞行器, 我们只支持 <code>&quot;FastPhysicsEngine&quot;</code> .</p>
<h3 id="本地主机-IP-设置-LocalHostIp-Setting"><a href="#本地主机-IP-设置-LocalHostIp-Setting" class="headerlink" title="本地主机 IP 设置 LocalHostIp Setting"></a>本地主机 IP 设置 LocalHostIp Setting</h3><p>当你需要连接到远程主机, 你需要通过以太网适配器来互联, 举个例子, 可能通过以太网或者 Wi-Fi, 或者其他一些虚拟适配器或者 VPN. 你的 PC 可能有多个网络, 这些网络可能不孕寻互相通讯, 这种情况下, UDP 消息就不能传播到其他主机上. 所以 <code>LocalHostIp</code>允许你配置如何连接这些主机. 默认值 127.0.0.1 不能够到达外部主机, 这个默认值只能用来单个主机内部通讯.</p>
<h3 id="速度单位因子-SpeedUnitFactor"><a href="#速度单位因子-SpeedUnitFactor" class="headerlink" title="速度单位因子 SpeedUnitFactor"></a>速度单位因子 SpeedUnitFactor</h3><p>速度转换成<code>m/s</code>因子, 默认为 1. 与 <code>SpeedUnitLabel</code> 结合使用. 这通常只被用来显示, 比如汽车行驶速度显示. 举个例子, 速度转换到 <code>miles/hr</code> 的因子是 2.23694.</p>
<h3 id="速度单位标签-SpeedUnitLabel"><a href="#速度单位标签-SpeedUnitLabel" class="headerlink" title="速度单位标签 SpeedUnitLabel"></a>速度单位标签 SpeedUnitLabel</h3><p>速度单位, 默认为 <code>m/s</code>. 结合 <code>SpeedUnitFactor</code> 一起使用.</p>
]]></content>
      <categories>
        <category>自动驾驶</category>
      </categories>
      <tags>
        <tag>自动驾驶</tag>
        <tag>AirSim</tag>
      </tags>
  </entry>
  <entry>
    <title>自动驾驶仿真 - AirSim (5) - 图片 APIs - C++</title>
    <url>/posts/3314168402/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>接下去主要介绍一下 <code>AirSim</code> 的 <code>APIs</code> 的使用, 参考 <a href="https://microsoft.github.io/AirSim/image_apis/" target="_blank" rel="noopener">官方</a> 文档, 并结合结合 OpenCV 来用 C++ 实现部分 官方 Python 的例程.</p>
<a id="more"></a>
<hr>
<p>[TOC]</p>
<hr>
<h2 id="读取相机图片"><a href="#读取相机图片" class="headerlink" title="读取相机图片"></a>读取相机图片</h2><p>官方<a href="https://microsoft.github.io/AirSim/image_apis/" target="_blank" rel="noopener">例程</a> 提供了两种读取相机图片的方式 (需要修改, 代码参考如下). 这个例程获取 “0” 号相机的单幅图片. 返回值为 png 格式图片的字节. 如果要获取其他格式图片或者其他可用相机的图片参考下一小节.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"vehicles/multirotor/api/MultirotorRpcLibClient. hpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getOneImage</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> msr::airlib;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//for car use CarRpcLibClient</span></span><br><span class="line">    msr::airlib::MultirotorRpcLibClient client;</span><br><span class="line"></span><br><span class="line">    msr::airlib::<span class="built_in">vector</span>&lt;<span class="keyword">uint8_t</span>&gt; png_image = client. simGetImage(<span class="string">"0"</span>, VehicleCameraBase::ImageType::Scene);</span><br><span class="line">    <span class="comment">//do something with images</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="更加灵活的获取图片"><a href="#更加灵活的获取图片" class="headerlink" title="更加灵活的获取图片"></a>更加灵活的获取图片</h2><p><code>simGetImages</code> API 相比于 <code>simGetImage</code> API 更加复杂, 举个例子, 你可以通过单个 API 调用获取左侧、右侧、左侧的相机深度视图. <code>simGetImages</code>API 允许你获取未压缩的图片或者浮点单通道的图片数据 (而不是 8 位 3 通道 (RGB)).</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ImageRequest(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; camera_name_val, ImageCaptureBase::ImageType image_type_val, <span class="keyword">bool</span> pixels_as_float_val = <span class="literal">false</span>, <span class="keyword">bool</span> compress_val = <span class="literal">true</span>)</span><br></pre></td></tr></table></figure>
<p><code>ImageRequest</code> 图片请求类的参数为</p>
<p><code>camera_name_val</code>: 相机编号, 可以输入 <code>&quot;0&quot;</code>, <code>&quot;1&quot;</code>, <code>&quot;2&quot;</code>, <code>&quot;3&quot;</code>, <code>&quot;4&quot;</code> 或者 <code>&quot;front_center&quot;</code>, <code>&quot;front_right&quot;</code>, <code>&quot;front_left&quot;</code>, <code>&quot;fpv&quot;</code>, <code>&quot;back_center&quot;</code>.</p>
<p><code>image_type_val</code>: 图片类型, 可支持的图片类型有:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Scene = <span class="number">0</span>,</span><br><span class="line">DepthPlanner = <span class="number">1</span>,</span><br><span class="line">DepthPerspective = <span class="number">2</span>,</span><br><span class="line">DepthVis = <span class="number">3</span>,</span><br><span class="line">DisparityNormalized = <span class="number">4</span>,</span><br><span class="line">Segmentation = <span class="number">5</span>,</span><br><span class="line">SurfaceNormals = <span class="number">6</span>,</span><br><span class="line">Infrared = <span class="number">7</span></span><br></pre></td></tr></table></figure>
<p><code>pixels_as_float_val</code>: 是否为浮点值, 默认为 <code>false</code>.</p>
<p><code>compress_val</code>: 是否是压缩数据, 默认为 <code>true</code></p>
<p><strong>PS:</strong> 后两个参数这里会影响到 opencv 的矩阵或者解码图片. 这里通过将一组图像请求信息 <code>ImageRequest</code> 放入容器中, 通过 <code>simGetImages</code> 一次性请求. 之后可通过迭代获取各个相机的图像数据.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getStereoAndDepthImages</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> msr::airlib;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> VehicleCameraBase::ImageRequest ImageRequest;</span><br><span class="line">    <span class="keyword">typedef</span> VehicleCameraBase::ImageResponse ImageResponse;</span><br><span class="line">    <span class="keyword">typedef</span> VehicleCameraBase::ImageType ImageType;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//for car use</span></span><br><span class="line">    <span class="comment">//msr::airlib::CarRpcLibClient client;</span></span><br><span class="line">    msr::airlib::MultirotorRpcLibClient client;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//get right, left and depth images. First two as png, second as float16.</span></span><br><span class="line">    msr::airlib::<span class="built_in">vector</span>&lt;ImageRequest&gt; request = &#123;</span><br><span class="line">        <span class="comment">//png format</span></span><br><span class="line">        ImageRequest(<span class="string">"0"</span>, ImageType::Scene),</span><br><span class="line">        <span class="comment">//uncompressed RGB array bytes</span></span><br><span class="line">        ImageRequest(<span class="string">"1"</span>, ImageType::Scene, <span class="literal">false</span>, <span class="literal">false</span>),</span><br><span class="line">        <span class="comment">//floating point uncompressed image</span></span><br><span class="line">        ImageRequest(<span class="string">"1"</span>, ImageType::DepthPlanner, <span class="literal">true</span>)</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">vector</span>&lt;ImageResponse&gt;&amp; response = client. simGetImages(request);</span><br><span class="line">    <span class="comment">//do something with response which contains image data, pose, timestamp etc</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="通过-OpenCV-显示图片"><a href="#通过-OpenCV-显示图片" class="headerlink" title="通过 OpenCV 显示图片"></a>通过 <code>OpenCV</code> 显示图片</h2><p>虽然获取到的图片是 <code>uint8_t</code> 类型的数据, 但是无法通过直接转换成 <code>cv::Mat</code> 来使用 <code>OpenCV</code> 进行操作处理. 主要是获取到的是压缩的图片数据. 这里要使用 <code>cv::imdecode</code> 来对图片进行解码. 对应的两个 API 略有不同.</p>
<p>如果是压缩的数据：需要用 <code>cv::imdecode</code> 来解码生成 <code>cv::Mat</code> 的数据格式； 如果是非压缩的数据, 可以直接进行构造. 具体可见代码. 深度图片需要对 Mat 调用 <code>normalize</code> 归一化, 否则图片可能全白.</p>
<p>参考资料:</p>
<p><a href="https://github.com/microsoft/AirSim/issues/966" target="_blank" rel="noopener">https://github.com/microsoft/AirSim/issues/966</a></p>
<p><a href="https://github.com/Microsoft/AirSim/issues/491" target="_blank" rel="noopener">https://github.com/Microsoft/AirSim/issues/491</a></p>
<p>完整源码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"opencv2/opencv. hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"vehicles/multirotor/api/MultirotorRpcLibClient. hpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ImageAPIs::getStereoAndDepthImages4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">namespace</span> msr::airlib;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">typedef</span> ImageCaptureBase::ImageRequest ImageRequest;</span><br><span class="line">  <span class="keyword">typedef</span> ImageCaptureBase::ImageResponse ImageResponse;</span><br><span class="line">  <span class="keyword">typedef</span> ImageCaptureBase::ImageType ImageType;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// for car use</span></span><br><span class="line">  <span class="comment">// msr::airlib::CarRpcLibClient client;</span></span><br><span class="line">  msr::airlib::MultirotorRpcLibClient client;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// get right, left and depth images. First two as png, second as float16.</span></span><br><span class="line">  msr::airlib::<span class="built_in">vector</span>&lt;ImageRequest&gt; request = &#123;<span class="comment">// png format</span></span><br><span class="line">                                               ImageRequest(<span class="string">"0"</span>, ImageType::Scene),</span><br><span class="line">                                               <span class="comment">// uncompressed RGB array bytes</span></span><br><span class="line">                                               ImageRequest(<span class="string">"1"</span>, ImageType::Scene, <span class="literal">false</span>, <span class="literal">false</span>),</span><br><span class="line">                                               <span class="comment">// floating point uncompressed image</span></span><br><span class="line">                                               ImageRequest(<span class="string">"1"</span>, ImageType::DepthPlanner, <span class="literal">true</span>)&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;ImageResponse&gt;&amp; response = client. simGetImages(request);</span><br><span class="line">      <span class="keyword">if</span> (response. <span class="built_in">size</span>() != request. <span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Images were not received!"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 左侧相机 ImageRequest("0", ImageType::Scene)</span></span><br><span class="line">      <span class="comment">// 默认参数是压缩数据, 调用 imdecode</span></span><br><span class="line">      cv::Mat left_mat = cv::imdecode(response. at(<span class="number">0</span>). image_data_uint8, cv::IMREAD_UNCHANGED);</span><br><span class="line">      cv::imshow(<span class="string">"left"</span>, left_mat);</span><br><span class="line">      cv::waitKey(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">      <span class="function">cv::Mat <span class="title">right_mat</span><span class="params">(response. at(<span class="number">1</span>). <span class="built_in">height</span>, response. at(<span class="number">1</span>). <span class="built_in">width</span>, CV_8UC3,</span></span></span><br><span class="line"><span class="function"><span class="params">                        (<span class="keyword">void</span>*)response. at(<span class="number">1</span>). image_data_uint8. data())</span></span>;</span><br><span class="line">      cv::imshow(<span class="string">"right"</span>, right_mat);</span><br><span class="line">      cv::waitKey(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 深度图片 ImageRequest("1", ImageType::DepthPlanner, true)</span></span><br><span class="line">      <span class="comment">// 这里需要对 Mat 调用 normalize 归一化, 否则图片可能全白.</span></span><br><span class="line">      <span class="function">cv::Mat <span class="title">gt_depth_mat</span><span class="params">(response. at(<span class="number">2</span>). <span class="built_in">height</span>, response. at(<span class="number">2</span>). <span class="built_in">width</span>, CV_32FC1,</span></span></span><br><span class="line"><span class="function"><span class="params">                           (<span class="keyword">void</span>*)response. at(<span class="number">2</span>). image_data_float. data())</span></span>;</span><br><span class="line">      cv::normalize(gt_depth_mat, gt_depth_mat, <span class="number">1</span>, <span class="number">0</span>, cv::NORM_MINMAX);</span><br><span class="line">      cv::imshow(<span class="string">"depth"</span>, gt_depth_mat);</span><br><span class="line">      cv::waitKey(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (rpc::timeout&amp; t) &#123;</span><br><span class="line">    <span class="comment">// will display a message like</span></span><br><span class="line">    <span class="comment">// rpc::timeout: Timeout of 50ms while calling RPC function 'sleep'</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; t. what() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="image-20200613175100646.png" alt="image-20200613175100646"></p>
<h2 id="可用的相机"><a href="#可用的相机" class="headerlink" title="可用的相机"></a>可用的相机</h2><h3 id="车"><a href="#车" class="headerlink" title="车"></a>车</h3><p><code>API</code> 可以通过一下相机名称调用: <code>&quot;front_center&quot;</code>, <code>&quot;front_right&quot;</code>, <code>&quot;front_left&quot;</code>, <code>&quot;fpv&quot;</code>, <code>&quot;back_center&quot;</code>. FPV 相机处于驾驶员头部位置 (First Person Virsion, 第一人称视角).</p>
<h3 id="飞行器"><a href="#飞行器" class="headerlink" title="飞行器"></a>飞行器</h3><p><code>API</code> 可以通过一下相机名称调用: <code>front_center</code>, <code>front_right</code>, <code>front_left</code>, <code>bottom_center</code> 和<code>back_center</code>.</p>
<h3 id="计算机视觉模式"><a href="#计算机视觉模式" class="headerlink" title="计算机视觉模式"></a>计算机视觉模式</h3><p>和飞行器的一致.</p>
<h3 id="向后兼容的相机名称"><a href="#向后兼容的相机名称" class="headerlink" title="向后兼容的相机名称"></a>向后兼容的相机名称</h3><p>在 AirSim v1. 2 之前, 相机是通过 ID 来指定的. 考虑到向后兼容, 依然可以用下相机的 ID 序号来代替, 顺序与上述名称保持一直. 此外, 相机名称为空字符串 <code>&quot;&quot;</code> 也是可以的, 也就是默认相机, 通常为 <code>&quot;0&quot;</code> .</p>
<h2 id="“Computer-Vision”-模式"><a href="#“Computer-Vision”-模式" class="headerlink" title="“Computer Vision” 模式"></a>“Computer Vision” 模式</h2><p>可以在 AirSim 中使用 “Computer Virsion” 模式. 在这个模式下, 物理引擎被禁用, 没有载具, 只有相机. 可以通过键盘移动视角 (按 F1 可以看帮助). 可以按下 Record 按钮来持续生成图片. 或者可以调用 APIs 来移动相机和获取图片.</p>
<p>编辑 <a href="https://microsoft.github.io/AirSim/settings/" target="_blank" rel="noopener">settings. json</a> 文件可以激活这种模式. 在用户的 <code>Documents\AirSim</code> 文件夹内 (Linux 则在 <code>Documents\AirSim</code>) 然后更改下列变量的值.</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"SettingsVersion"</span>: <span class="number">1.</span> <span class="number">2</span>,</span><br><span class="line">  <span class="attr">"SimMode"</span>: <span class="string">"ComputerVision"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/Microsoft/AirSim/tree/master/PythonClient//computer_vision/cv_mode.py" target="_blank" rel="noopener">Python 例程</a> 移动相机并获取图片.</p>
<p>这是模式是受 <a href="http://unrealcv.org/" target="_blank" rel="noopener">UnrealCV project</a> 启发的.</p>
<p><strong>PS</strong>:</p>
<ul>
<li>我这里提供了 C++ 的版本, 直接用 OpenCV 动态显示了, 没有保存成图片格式.</li>
<li><code>settings. json</code> 编辑完成后, 不需要重启 UE 编辑器, 只要重新运行当前项目即可.</li>
<li>方向键调整相机位置(前后左右), wasd 调整朝向.</li>
<li>欧拉角转四元数可以参考 Eigen 库, 这里没写.</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ImageAPIs::CVMode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">namespace</span> msr::airlib;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">typedef</span> ImageCaptureBase::ImageRequest ImageRequest;</span><br><span class="line">  <span class="keyword">typedef</span> ImageCaptureBase::ImageResponse ImageResponse;</span><br><span class="line">  <span class="keyword">typedef</span> ImageCaptureBase::ImageType ImageType;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// for car use</span></span><br><span class="line">  msr::airlib::MultirotorRpcLibClient client;</span><br><span class="line">  client. confirmConnection();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Press any key to set camera-0 gimble to 15-degree pitch. \n"</span>;</span><br><span class="line">  <span class="built_in">std</span>::getchar();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// TODO client. simSetCameraOrientation();</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Press any key to get camera parameters. \n"</span>;</span><br><span class="line">  <span class="built_in">std</span>::getchar();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> camera_name = <span class="number">0</span>; camera_name &lt; <span class="number">5</span>; ++camera_name) &#123;</span><br><span class="line">    CameraInfo camera_info = client. simGetCameraInfo(<span class="built_in">std</span>::to_string(camera_name));</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"CameraInfo "</span> &lt;&lt; camera_name &lt;&lt; <span class="string">": \n"</span></span><br><span class="line">              &lt;&lt; <span class="string">"Pose: "</span> &lt;&lt; camera_info. pose. <span class="built_in">position</span>. x() &lt;&lt; <span class="string">" "</span> &lt;&lt; camera_info. pose. <span class="built_in">position</span>. y() &lt;&lt; <span class="string">" "</span></span><br><span class="line">              &lt;&lt; camera_info. pose. <span class="built_in">position</span>. z() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span></span><br><span class="line">              &lt;&lt; <span class="string">"FOV: "</span> &lt;&lt; camera_info. fov &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// get right, left and depth images. First two as png, second as float16.</span></span><br><span class="line">  msr::airlib::<span class="built_in">vector</span>&lt;ImageRequest&gt; request = &#123;ImageRequest(<span class="string">"0"</span>, ImageType::DepthVis),</span><br><span class="line">                                               ImageRequest(<span class="string">"1"</span>, ImageType::DepthPerspective, <span class="literal">true</span>),</span><br><span class="line">                                               ImageRequest(<span class="string">"2"</span>, ImageType::Segmentation),</span><br><span class="line">                                               ImageRequest(<span class="string">"3"</span>, ImageType::Scene),</span><br><span class="line">                                               ImageRequest(<span class="string">"4"</span>, ImageType::DisparityNormalized),</span><br><span class="line">                                               ImageRequest(<span class="string">"4"</span>, ImageType::SurfaceNormals)&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">/* TODO</span></span><br><span class="line"><span class="comment">   client. simSetVehiclePose();</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> msr::airlib::<span class="built_in">vector</span>&lt;ImageResponse&gt;&amp; responses = client. simGetImages(request);</span><br><span class="line">    <span class="comment">// do something with response which contains image data, pose, timestamp etc</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; responses. <span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">      <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">strid</span><span class="params">(<span class="built_in">std</span>::to_string(i))</span></span>;</span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">auto</span>&amp; response = responses. at(i);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (response. pixels_as_float) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Type "</span> &lt;&lt; <span class="keyword">int</span>(response. image_type) &lt;&lt; <span class="string">", size "</span> &lt;&lt; response. image_data_float. <span class="built_in">size</span>() &lt;&lt; <span class="string">", pos "</span></span><br><span class="line">                  &lt;&lt; response. camera_position. x() &lt;&lt; <span class="string">" "</span> &lt;&lt; response. camera_position. y() &lt;&lt; <span class="string">" "</span></span><br><span class="line">                  &lt;&lt; response. camera_position. z() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Type "</span> &lt;&lt; <span class="keyword">int</span>(response. image_type) &lt;&lt; <span class="string">", size "</span> &lt;&lt; response. image_data_uint8. <span class="built_in">size</span>() &lt;&lt; <span class="string">", pos "</span></span><br><span class="line">                  &lt;&lt; response. camera_position. x() &lt;&lt; <span class="string">" "</span> &lt;&lt; response. camera_position. y() &lt;&lt; <span class="string">" "</span></span><br><span class="line">                  &lt;&lt; response. camera_position. z() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">switch</span> (response. image_type) &#123;</span><br><span class="line">        <span class="keyword">case</span> ImageType::Scene:</span><br><span class="line">          <span class="keyword">if</span> (!response. pixels_as_float &amp;&amp; response.compress) &#123;</span><br><span class="line">            cv::Mat img_mat = cv::imdecode(response. image_data_uint8, cv::IMREAD_UNCHANGED);</span><br><span class="line">            cv::imshow(response. camera_name + <span class="string">":Scene-"</span> + strid, img_mat);</span><br><span class="line">            cv::waitKey(<span class="number">5</span>);</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!response. pixels_as_float &amp;&amp; !response.compress) &#123;</span><br><span class="line">            cv::Mat img_mat(response. <span class="built_in">height</span>, response. <span class="built_in">width</span>, CV_8UC3, (<span class="keyword">void</span>*)response. image_data_uint8. data());</span><br><span class="line">            cv::imshow(response. camera_name + <span class="string">":Scene-"</span> + strid, img_mat);</span><br><span class="line">            cv::waitKey(<span class="number">5</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> ImageType::DepthPlanner:</span><br><span class="line">          <span class="keyword">if</span> (!response. pixels_as_float &amp;&amp; response.compress) &#123;</span><br><span class="line">            cv::Mat img_mat = cv::imdecode(response. image_data_uint8, cv::IMREAD_GRAYSCALE);</span><br><span class="line">            cv::imshow(response. camera_name + <span class="string">":DepthPlanner-"</span> + strid, img_mat);</span><br><span class="line">            cv::waitKey(<span class="number">5</span>);</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (response. pixels_as_float &amp;&amp; response.compress) &#123;</span><br><span class="line">            cv::Mat img_mat(response. <span class="built_in">height</span>, response. <span class="built_in">width</span>, CV_32FC1, (<span class="keyword">void</span>*)response. image_data_float. data());</span><br><span class="line">            cv::normalize(img_mat, img_mat, <span class="number">1</span>, <span class="number">0</span>, cv::NORM_MINMAX);</span><br><span class="line">            cv::imshow(response. camera_name + <span class="string">":DepthPlanner-"</span> + strid, img_mat);</span><br><span class="line">            cv::waitKey(<span class="number">5</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ImageType::DepthPerspective:</span><br><span class="line">          <span class="keyword">if</span> (!response. pixels_as_float &amp;&amp; response.compress) &#123;</span><br><span class="line">            cv::Mat img_mat = cv::imdecode(response. image_data_uint8, cv::IMREAD_GRAYSCALE);</span><br><span class="line">            cv::imshow(response. camera_name + <span class="string">":DepthPerspective-"</span> + strid, img_mat);</span><br><span class="line">            cv::waitKey(<span class="number">5</span>);</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (response. pixels_as_float &amp;&amp; response.compress) &#123;</span><br><span class="line">            <span class="comment">// cv::Mat img_mat = cv::imdecode(response. image_data_float, cv::IMREAD_GRAYSCALE);</span></span><br><span class="line">            cv::Mat img_mat(response. <span class="built_in">height</span>, response. <span class="built_in">width</span>, CV_32FC1, (<span class="keyword">void</span>*)response. image_data_float. data());</span><br><span class="line">            cv::normalize(img_mat, img_mat, <span class="number">1</span>, <span class="number">0</span>, cv::NORM_MINMAX);</span><br><span class="line">            cv::imshow(response. camera_name + <span class="string">":DepthPerspective-"</span> + strid, img_mat);</span><br><span class="line">            cv::waitKey(<span class="number">5</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ImageType::DepthVis:</span><br><span class="line">          <span class="keyword">if</span> (!response. pixels_as_float &amp;&amp; response.compress) &#123;</span><br><span class="line">            cv::Mat img_mat = cv::imdecode(response. image_data_uint8, cv::IMREAD_GRAYSCALE);</span><br><span class="line">            cv::imshow(response. camera_name + <span class="string">":DepthVis-"</span> + strid, img_mat);</span><br><span class="line">            cv::waitKey(<span class="number">5</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ImageType::DisparityNormalized:</span><br><span class="line">          <span class="keyword">if</span> (response. pixels_as_float) &#123;</span><br><span class="line">            <span class="function">cv::Mat <span class="title">img_mat</span><span class="params">(response. <span class="built_in">height</span>, response. <span class="built_in">width</span>, CV_32FC1, (<span class="keyword">void</span>*)response. image_data_float. data())</span></span>;</span><br><span class="line">            cv::normalize(img_mat, img_mat, <span class="number">1</span>, <span class="number">0</span>, cv::NORM_MINMAX);</span><br><span class="line">            cv::imshow(response. camera_name + <span class="string">":DisparityNormalized-"</span> + strid, img_mat);</span><br><span class="line">            cv::waitKey(<span class="number">5</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ImageType::Segmentation:</span><br><span class="line">          <span class="keyword">if</span> (!response. pixels_as_float &amp;&amp; response.compress) &#123;</span><br><span class="line">            cv::Mat img_mat = cv::imdecode(response. image_data_uint8, cv::IMREAD_UNCHANGED);</span><br><span class="line">            cv::imshow(response. camera_name + <span class="string">":Segmentation-"</span> + strid, img_mat);</span><br><span class="line">            cv::waitKey(<span class="number">5</span>);</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!response. pixels_as_float &amp;&amp; !response.compress) &#123;</span><br><span class="line">            cv::Mat img_mat(response. <span class="built_in">height</span>, response. <span class="built_in">width</span>, CV_8UC3, (<span class="keyword">void</span>*)response. image_data_uint8. data());</span><br><span class="line">            cv::imshow(response. camera_name + <span class="string">":Segmentation-"</span> + strid, img_mat);</span><br><span class="line">            cv::waitKey(<span class="number">5</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ImageType::SurfaceNormals:</span><br><span class="line">          <span class="keyword">if</span> (!response. pixels_as_float &amp;&amp; response.compress) &#123;</span><br><span class="line">            cv::Mat img_mat = cv::imdecode(response. image_data_uint8, cv::IMREAD_UNCHANGED);</span><br><span class="line">            cv::imshow(response. camera_name + <span class="string">":SurfaceNormals-"</span> + strid, img_mat);</span><br><span class="line">            cv::waitKey(<span class="number">5</span>);</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!response. pixels_as_float &amp;&amp; !response.compress) &#123;</span><br><span class="line">            cv::Mat img_mat(response. <span class="built_in">height</span>, response. <span class="built_in">width</span>, CV_8UC3, (<span class="keyword">void</span>*)response. image_data_uint8. data());</span><br><span class="line">            cv::imshow(response. camera_name + <span class="string">":SurfaceNormals-"</span> + strid, img_mat);</span><br><span class="line">            cv::waitKey(<span class="number">5</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">auto</span> pose = client. simGetVehiclePose();</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Vehicle Pose: "</span> &lt;&lt; pose. <span class="built_in">position</span>. x() &lt;&lt; <span class="string">" "</span> &lt;&lt; pose. <span class="built_in">position</span>. y() &lt;&lt; <span class="string">" "</span> &lt;&lt; pose. <span class="built_in">position</span>. y()</span><br><span class="line">                &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="image-20200613184934655.png" alt="image-20200613184934655"></p>
<h3 id="在-Computer-Vision-模式下设置位姿"><a href="#在-Computer-Vision-模式下设置位姿" class="headerlink" title="在 Computer Vision 模式下设置位姿"></a>在 Computer Vision 模式下设置位姿</h3><p>为了在环境中通过 <code>APIs</code> 移动, 可以用过 <code>simSetVehiclePose</code> API. 这个 API 传入位置和姿态参数, 将不可见的载具设置在 <code>front-center</code> 相机所处的位置. 其他的相机保持相对的位置移动. 如果不想改变位置或者姿态, 只需要将位置和姿态设置为 nan 的浮点数. <code>simGetVehiclePose</code> 可以获取当前位姿, 你可以用 <code>simGetGroundTruthKinematics</code> 来获取 quantities kinematics quantities for the movement (不太明白这意思). 还有很多其他无载具特定的 APIs 也是可用, 比如 分割 APIs, 碰撞 APIs, 相机 APIs.</p>
<h2 id="相机-APIs"><a href="#相机-APIs" class="headerlink" title="相机 APIs"></a>相机 APIs</h2><p><code>simGetCameraInfo</code> 返回指定相机的位姿 (世界场景, NED 坐标系, 国际标准单位制) 和 FOV (角度) . 可参考例程 <a href="https://github.com/Microsoft/AirSim/tree/master/PythonClient//computer_vision/cv_mode.py" target="_blank" rel="noopener">example usage</a>.</p>
<p><code>simSetCameraOrientation</code> 设置指定相机在 NED 坐标系下的位姿(四元数). 函数 <code>airsim. to_quaternion()</code> 用来将俯仰, 翻转, 偏航角度转化为四元数, 举个例子, 设置相机 - 0 倾斜角度为 15 度, 可以用 (<strong>PS</strong>: 这个是 Python 版本, C++ 没找到, 可以自己用 Eigen 库实现) :</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">client. simSetCameraOrientation(<span class="number">0</span>, airsim. to_quaternion(<span class="number">0.</span> <span class="number">261799</span>, <span class="number">0</span>, <span class="number">0</span>)); <span class="comment">#radians</span></span><br></pre></td></tr></table></figure>
<h3 id="Gimbal"><a href="#Gimbal" class="headerlink" title="Gimbal"></a>Gimbal</h3><p>可以 <a href="https://microsoft.github.io/AirSim/settings/#gimbal" target="_blank" rel="noopener">using settings</a> 将任意相机设置为俯仰, 翻转, 偏航角度.</p>
<p>请参考 <a href="https://github.com/Microsoft/AirSim/tree/master/PythonClient//computer_vision/cv_mode.py" target="_blank" rel="noopener">example usage</a>.</p>
<h2 id="修改分辨率和相机参数"><a href="#修改分辨率和相机参数" class="headerlink" title="修改分辨率和相机参数"></a>修改分辨率和相机参数</h2><p>通过 <a href="https://microsoft.github.io/AirSim/settings/" target="_blank" rel="noopener">settings. json</a> 可以修改分辨率和视场角. 举个例子, 下述 settings. json 的额外部分设置了捕捉场景的参数, 并用前述的 “Computer Version” 模式. 如果你省略了任何设置, 下述默认参数将会被使用. 更多设置参见 <a href="https://microsoft.github.io/AirSim/settings/" target="_blank" rel="noopener">settings doc</a>. 如果你正在使用立体相机, 左右两个相机的固定距离是 25 cm.</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"SettingsVersion"</span>: <span class="number">1.</span> <span class="number">2</span>,</span><br><span class="line">  <span class="attr">"CameraDefaults"</span>: &#123;</span><br><span class="line">    <span class="attr">"CaptureSettings"</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"ImageType"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">"Width"</span>: <span class="number">256</span>,</span><br><span class="line">        <span class="attr">"Height"</span>: <span class="number">144</span>,</span><br><span class="line">        <span class="attr">"FOV_Degrees"</span>: <span class="number">90</span>,</span><br><span class="line">        <span class="attr">"AutoExposureSpeed"</span>: <span class="number">100</span>,</span><br><span class="line">        <span class="attr">"MotionBlurAmount"</span>: <span class="number">0</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"SimMode"</span>: <span class="string">"ComputerVision"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="在不同的图像类型像素值表示什么"><a href="#在不同的图像类型像素值表示什么" class="headerlink" title="在不同的图像类型像素值表示什么"></a>在不同的图像类型像素值表示什么</h2><h3 id="可用的图像类型"><a href="#可用的图像类型" class="headerlink" title="可用的图像类型"></a>可用的图像类型</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Scene = <span class="number">0</span>,</span><br><span class="line">DepthPlanner = <span class="number">1</span>,</span><br><span class="line">DepthPerspective = <span class="number">2</span>,</span><br><span class="line">DepthVis = <span class="number">3</span>,</span><br><span class="line">DisparityNormalized = <span class="number">4</span>,</span><br><span class="line">Segmentation = <span class="number">5</span>,</span><br><span class="line">SurfaceNormals = <span class="number">6</span>,</span><br><span class="line">Infrared = <span class="number">7</span></span><br></pre></td></tr></table></figure>
<h3 id="DepthPlanner-and-DepthPerspective"><a href="#DepthPlanner-and-DepthPerspective" class="headerlink" title="DepthPlanner and DepthPerspective"></a>DepthPlanner and DepthPerspective</h3><p>通常你希望在接收到 float 表示的深度图像 ( 即在<code>ImageRequest</code> 将设置 <code>pixels_as_float = true</code>) 然后指定 <code>ImageType = DepthPlanner</code> 或者 <code>ImageType = DepthPerspective</code> . 对于 <code>ImageType = DepthPlanner</code>, 将获得获得深度, 即所有与相机处于相同距离的点具有相同的深度. 对于 <code>ImageType = DepthPerspective</code>, 通过射向像素点的射线来获取深度. 取决与使用的案例, 平行深度或者透视深度可能是所需的真正图像. 举个例子, 你可能对 ROS 包发布透视深度, 例如 <code>depth_image_proc</code> 来生成点云. 或者平行深度可能通过立体视觉算法, 例如 SGM, 用来估计深度图像的生成.</p>
<h3 id="DepthVis"><a href="#DepthVis" class="headerlink" title="DepthVis"></a>DepthVis</h3><p>当在 <code>ImageRequest</code> 指定 <code>ImageType = DepthVis</code>, 将获得一副有助于可视化深度的图像. 在这种请跨下, 每个像素值是米值的根据相机平面从白到黑的插值. 纯白的像素意味着深度超过 100 m, 纯黑意味着深度为 0 m.</p>
<h3 id="DisparityNormalized"><a href="#DisparityNormalized" class="headerlink" title="DisparityNormalized"></a>DisparityNormalized</h3><p>通常你希望在接收到 float 表示的深度图像 ( 即在<code>ImageRequest</code> 设置 <code>pixels_as_float = true</code> <code>ImageType = DisparityNormalized</code> ) . 这种情况下, 每个像素值是 <code>(Xl - Xr)/Xmax</code>, 即被归一化为 0 到 1 之间的值.</p>
<h3 id="Segmentation"><a href="#Segmentation" class="headerlink" title="Segmentation"></a>Segmentation</h3><p>当在 <code>ImageRequest</code> 指定 <code>ImageType = Segmentation</code> , 将获取到真实场景的分割图. 在启动时, AirSim 给环境中每块网格分配 0 到 255 的值. 这些值将映射 <a href="https://github.com/Microsoft/AirSim/tree/master/Unreal//Plugins/AirSim/Content/HUDAssets/seg_color_pallet.png" target="_blank" rel="noopener">the pallet</a> 中指定的颜色. 每个对象的 ID 可以在 <a href="https://microsoft.github.io/AirSim/seg_rgbs.txt" target="_blank" rel="noopener">this file</a> 找到.</p>
<p>你可以通过 APIs 给指定的网格分配指定的值 (范围限制在 0-255) . 举个例子, 下述的 Python (PS: C++ 代码相同) 代码给一个对象 ID 为 ”Ground“ 在 Blocks 环境中的值为 20, 所以改变了该对象在分割视图中的颜色:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">success = client. simSetSegmentationObjectID(<span class="string">"Ground"</span>, <span class="number">20</span>);</span><br></pre></td></tr></table></figure>
<p>返回的布尔值表示是否找到该网格.</p>
<p>主要, 典型的 Unreal 环境中, 像 Blocks, 通常有很多其他有相同对象组成的网格, 举个例子, “Ground_2”, “Ground_3” 等等. 因为对所有网格设置对象 ID 是很冗杂的, AirSim 也支持正则表达式. 举个例子, 以下只用了一行代码设置了名称以 ”ground“ 开头的所有网格为 21 (忽略大小写) :</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">success = client. simSetSegmentationObjectID(<span class="string">"ground[\w]*"</span>, <span class="number">21</span>, <span class="literal">True</span>);</span><br></pre></td></tr></table></figure>
<p>如果至少有一个网格被正则表达式匹配, 则返回 true.</p>
<p>建议通过这个 API 来请求未压缩的分割图像, 确保获取到精确的 RGB 值:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">responses = client. simGetImages([ImageRequest(<span class="number">0</span>, AirSimImageType. Segmentation, <span class="literal">False</span>, <span class="literal">False</span>)])</span><br><span class="line">img1d = np. fromstring(response. image_data_uint8, dtype=np. uint8) <span class="comment">#get numpy array</span></span><br><span class="line">img_rgb = img1d. reshape(response. height, response. width, <span class="number">3</span>) <span class="comment">#reshape array to 3 channel image array H X W X 3</span></span><br><span class="line">img_rgb = np. flipud(img_rgb) <span class="comment">#original image is fliped vertically</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#find unique colors</span></span><br><span class="line">print(np. unique(img_rgb[:, :, <span class="number">0</span>], return_counts=<span class="literal">True</span>)) <span class="comment">#red</span></span><br><span class="line">print(np. unique(img_rgb[:, :, <span class="number">1</span>], return_counts=<span class="literal">True</span>)) <span class="comment">#green</span></span><br><span class="line">print(np. unique(img_rgb[:, :, <span class="number">2</span>], return_counts=<span class="literal">True</span>)) <span class="comment">#blue</span></span><br></pre></td></tr></table></figure>
<p>完整可运行的程序见 <a href="https://github.com/Microsoft/AirSim/tree/master/PythonClient//computer_vision/segmentation.py" target="_blank" rel="noopener">segmentation. py</a>.</p>
<h4 id="Unsetting-object-ID"><a href="#Unsetting-object-ID" class="headerlink" title="Unsetting object ID"></a>Unsetting object ID</h4><p>如果不想在分割图像中显示对象, 可以设置对象 ID 为 -1.</p>
<h4 id="如何找到网格的名字"><a href="#如何找到网格的名字" class="headerlink" title="如何找到网格的名字"></a>如何找到网格的名字</h4><p>为了获取真实的分割图, 你需要知道在 Unreal 环境中的网格名称. 打开 UE 编辑器中的 Unreal 环境, 然后在世界大纲视图 (World Outliner) 中找到感兴趣的网格. 举个例子, 下述图片我们可以在右侧 Blocks 环境面板中看到 ground 的网格名称:</p>
<p><img data-src="https://microsoft.github.io/AirSim/images/unreal_editor_blocks.png" alt="record screenshot"></p>
<p>如果你不知道如何在 Unreal 编辑器中打开 Unreal 环境, 可以参考下列教程 <a href="https://microsoft.github.io/AirSim/build_windows/" target="_blank" rel="noopener">building from source</a>.</p>
<p>一旦你决定你感兴趣的网格, 几下它们的名称, 然后通过上述的 API 来设置它们的 object IDs. 这里有 <a href="https://microsoft.github.io/AirSim/settings/#segmentation-settings" target="_blank" rel="noopener">few settings</a> 来改变生成 object ID 的行为.</p>
<h4 id="修改-Object-IDs-的颜色"><a href="#修改-Object-IDs-的颜色" class="headerlink" title="修改 Object IDs 的颜色"></a>修改 Object IDs 的颜色</h4><p>目前每个对象 ID 都在 <a href="https://github.com/Microsoft/AirSim/tree/master/Unreal//Plugins/AirSim/Content/HUDAssets/seg_color_pallet.png" target="_blank" rel="noopener">this pallet</a> 被固定. 我们将很快增加改变 object IDs 颜色的功能. 同时, 你将可以在你喜欢的图像编辑器中打开分割图, 然后获取你感兴趣的 RGB 值.</p>
<h4 id="Startup-Object-IDs"><a href="#Startup-Object-IDs" class="headerlink" title="Startup Object IDs"></a>Startup Object IDs</h4><p>开始时, AirSim 给能在环境中的<code>UStaticMeshComponent</code> 或者 <code>ALandscapeProxy</code> 类型的每个对象分配了 object id. 然后使用网格名称或者本身的名称 (取决于设置), 转换为小写, 移除所有小于 ASCII 97 的字符以移除数字和一些标点, 对所有字符求和并除以 255 取模来生成 object id. 换句话说, 所具有相同字符的对象将有相同的 object ID. 这个启发对于很多 Unreal 环境很简单也有有效, 但是可能不是你想要的. 这种情况下, 请用上面的 APIs 来修改 object IDs 为你想要的值. 这里可以设置可能修改这些表现 r.</p>
<h4 id="为网格获取-Object-ID"><a href="#为网格获取-Object-ID" class="headerlink" title="为网格获取 Object ID"></a>为网格获取 Object ID</h4><p><code>simGetSegmentationObjectID</code> API 允许你获取一个指定网格名称的 object ID.</p>
<h3 id="Infrared"><a href="#Infrared" class="headerlink" title="Infrared"></a>Infrared</h3><p>目前, 这只是将 object ID 映射为 0-255 灰度域的映射. 所以很多 object ID 42 的网格均已 (42, 42, 42) 的颜色显示. 请参考 <a href="https://microsoft.github.io/AirSim/image_apis/#segmentation" target="_blank" rel="noopener">segmentation section</a> 获取如何设置 object IDs 更多的细节. 通常, 噪声设置可以被运用在这种图像类型, 以获取细微的更加真实效果. 我们依然在增加其他的 infrared artifacts 方面展开工作, 也欢迎任何的 contributions .</p>
<h2 id="例程代码"><a href="#例程代码" class="headerlink" title="例程代码"></a>例程代码</h2><p>设置载具到任意方位和获取图片的代码可以在 <a href="https://github.com/Microsoft/AirSim/tree/master/Examples/DataCollection/StereoImageGenerator.hpp" target="_blank" rel="noopener">GenerateImageGenerator. hpp</a> 找到. 这个例程生成指定数量的立体图像和地面实况视差图像, 并保存为 <a href="https://microsoft.github.io/AirSim/pfm/" target="_blank" rel="noopener">pfm format</a>.</p>
]]></content>
      <categories>
        <category>自动驾驶</category>
      </categories>
      <tags>
        <tag>自动驾驶</tag>
        <tag>AirSim</tag>
      </tags>
  </entry>
  <entry>
    <title>自动驾驶仿真 - AirSim(7) - AirSim 多载具</title>
    <url>/posts/2251441435/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>从 release 1.2 开始, AirSim 完全能够支持多载具. 这能允许你更简单的创建多个载具并用 APIs 来控制它们.</p>
<a id="more"></a>
<h2 id="创建多个载具-Creating-Multiple-Vehicles"><a href="#创建多个载具-Creating-Multiple-Vehicles" class="headerlink" title="创建多个载具 Creating Multiple Vehicles"></a>创建多个载具 Creating Multiple Vehicles</h2><p>在 <a href="settings.md">settings.json</a> 可以很简单地对它们设定. <code>Vehicles</code> 元素允许你指定你想创建地载具列表, 包括初始位置和方向.位置是基于 SI 单位下的原点位于 Unreal 环境下玩家出生点的 NED 坐标系.方向基于角度制的偏航、俯仰和翻转.</p>
<h3 id="创建多辆汽车-Creating-Multiple-Cars"><a href="#创建多辆汽车-Creating-Multiple-Cars" class="headerlink" title="创建多辆汽车 Creating Multiple Cars"></a>创建多辆汽车 Creating Multiple Cars</h3><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"SettingsVersion"</span>: <span class="number">1.2</span>,</span><br><span class="line">  <span class="attr">"SimMode"</span>: <span class="string">"Car"</span>,</span><br><span class="line"></span><br><span class="line">  <span class="attr">"Vehicles"</span>: &#123;</span><br><span class="line">    <span class="attr">"Car1"</span>: &#123;</span><br><span class="line">      <span class="attr">"VehicleType"</span>: <span class="string">"PhysXCar"</span>,</span><br><span class="line">      <span class="attr">"X"</span>: <span class="number">4</span>,</span><br><span class="line">      <span class="attr">"Y"</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">"Z"</span>: <span class="number">-2</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"Car2"</span>: &#123;</span><br><span class="line">      <span class="attr">"VehicleType"</span>: <span class="string">"PhysXCar"</span>,</span><br><span class="line">      <span class="attr">"X"</span>: <span class="number">-4</span>,</span><br><span class="line">      <span class="attr">"Y"</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">"Z"</span>: <span class="number">-2</span>,</span><br><span class="line">      <span class="attr">"Yaw"</span>: <span class="number">90</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="创建多个飞行器-Creating-Multiple-Drones"><a href="#创建多个飞行器-Creating-Multiple-Drones" class="headerlink" title="创建多个飞行器 Creating Multiple Drones"></a>创建多个飞行器 Creating Multiple Drones</h3><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"SettingsVersion"</span>: <span class="number">1.2</span>,</span><br><span class="line">  <span class="attr">"SimMode"</span>: <span class="string">"Multirotor"</span>,</span><br><span class="line"></span><br><span class="line">  <span class="attr">"Vehicles"</span>: &#123;</span><br><span class="line">    <span class="attr">"Drone1"</span>: &#123;</span><br><span class="line">      <span class="attr">"VehicleType"</span>: <span class="string">"SimpleFlight"</span>,</span><br><span class="line">      <span class="attr">"X"</span>: <span class="number">4</span>,</span><br><span class="line">      <span class="attr">"Y"</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">"Z"</span>: <span class="number">-2</span>,</span><br><span class="line">      <span class="attr">"Yaw"</span>: <span class="number">-180</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"Drone2"</span>: &#123;</span><br><span class="line">      <span class="attr">"VehicleType"</span>: <span class="string">"SimpleFlight"</span>,</span><br><span class="line">      <span class="attr">"X"</span>: <span class="number">8</span>,</span><br><span class="line">      <span class="attr">"Y"</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">"Z"</span>: <span class="number">-2</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="多载具的-APIs-使用-Using-APIs-for-Multiple-Vehicles"><a href="#多载具的-APIs-使用-Using-APIs-for-Multiple-Vehicles" class="headerlink" title="多载具的 APIs 使用 Using APIs for Multiple Vehicles"></a>多载具的 APIs 使用 Using APIs for Multiple Vehicles</h2><p>从 AirSim 1.2 以来的新 APIs 允许你指定 <code>vehicle_name</code>. 这个名称和 json settings 的键值对应 (举个例子, 上述的 Car1 或 Drone2 ).</p>
<p><a href="https://github.com/Microsoft/AirSim/tree/master/PythonClient//car/multi_agent_car.py" target="_blank" rel="noopener">Example code for cars</a></p>
<p><a href="https://github.com/Microsoft/AirSim/tree/master/PythonClient//multirotor/multi_agent_drone.py" target="_blank" rel="noopener">Example code for multirotors</a></p>
<p><strong>PS:</strong> 这里提供一份 C++ 的实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> msr::airlib;</span><br><span class="line">msr::airlib::CarRpcLibClient client;</span><br><span class="line"></span><br><span class="line">client.confirmConnection();</span><br><span class="line">client.enableApiControl(<span class="literal">true</span>, <span class="string">"Car1"</span>);</span><br><span class="line">client.enableApiControl(<span class="literal">true</span>, <span class="string">"Car2"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> car_controls1 = client.getCarControls(<span class="string">"Car1"</span>);</span><br><span class="line"><span class="keyword">auto</span> car_controls2 = client.getCarControls(<span class="string">"Car2"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">  <span class="comment">// get state of the car</span></span><br><span class="line">  <span class="keyword">auto</span> car_state1 = client.getCarState(<span class="string">"Car1"</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Car1: Speed "</span> &lt;&lt; car_state1.speed &lt;&lt; <span class="string">", Gear "</span> &lt;&lt; car_state1.gear &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> car_state2 = client.getCarState(<span class="string">"Car2"</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Car1: Speed "</span> &lt;&lt; car_state2.speed &lt;&lt; <span class="string">", Gear "</span> &lt;&lt; car_state2.gear &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// go forward</span></span><br><span class="line">  car_controls1.throttle = <span class="number">0.5</span>;</span><br><span class="line">  car_controls2.throttle = <span class="number">0.5</span>;</span><br><span class="line">  client.setCarControls(car_controls1, <span class="string">"Car1"</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Car1: Go Forward.\n"</span>;</span><br><span class="line"></span><br><span class="line">  car_controls2.throttle = <span class="number">0.5</span>;</span><br><span class="line">  car_controls2.steering = <span class="number">-0.5</span>;</span><br><span class="line">  client.setCarControls(car_controls2, <span class="string">"Car2"</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Car2: Go Forward.\n"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// apply breaks</span></span><br><span class="line">  car_controls1.brake = <span class="number">1</span>;</span><br><span class="line">  client.setCarControls(car_controls1, <span class="string">"Car1"</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Car1: Apply break\n"</span>;</span><br><span class="line">  car_controls1.brake = <span class="number">0</span>;  <span class="comment">// remove break</span></span><br><span class="line"></span><br><span class="line">  car_controls2.brake = <span class="number">1</span>;</span><br><span class="line">  client.setCarControls(car_controls2, <span class="string">"Car2"</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Car2: Apply break\n"</span>;</span><br><span class="line">  car_controls2.brake = <span class="number">0</span>;  <span class="comment">// remove break</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">3</span>));  <span class="comment">// let car drive a bit</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;ImageCaptureBase::ImageResponse&gt;&amp; response1 =</span><br><span class="line">      client.simGetImages(&#123;ImageCaptureBase::ImageRequest(<span class="string">"0"</span>, ImageCaptureBase::ImageType::DepthVis),</span><br><span class="line">                           ImageCaptureBase::ImageRequest(<span class="string">"1"</span>, ImageCaptureBase::ImageType::Scene, <span class="literal">false</span>, <span class="literal">false</span>)&#125;,</span><br><span class="line">                          <span class="string">"Car1"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Car1: Retrieved images: "</span> &lt;&lt; response1.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;ImageCaptureBase::ImageResponse&gt;&amp; response2 =</span><br><span class="line">      client.simGetImages(&#123;ImageCaptureBase::ImageRequest(<span class="string">"0"</span>, ImageCaptureBase::ImageType::Segmentation),</span><br><span class="line">                           ImageCaptureBase::ImageRequest(<span class="string">"1"</span>, ImageCaptureBase::ImageType::Scene, <span class="literal">false</span>, <span class="literal">false</span>)&#125;,</span><br><span class="line">                          <span class="string">"Car2"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Car2: Retrieved images: "</span> &lt;&lt; response2.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  cv::Mat img_mat10 = cv::imdecode(response1.at(<span class="number">0</span>).image_data_uint8, cv::IMREAD_GRAYSCALE);</span><br><span class="line">  cv::imshow(<span class="string">"cat1_multi:DepthVis"</span>, img_mat10);</span><br><span class="line">  cv::waitKey(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function">cv::Mat <span class="title">img_mat11</span><span class="params">(response1.at(<span class="number">1</span>).<span class="built_in">height</span>, response1.at(<span class="number">1</span>).<span class="built_in">width</span>, CV_8UC3,</span></span></span><br><span class="line"><span class="function"><span class="params">                    (<span class="keyword">void</span>*)response1.at(<span class="number">1</span>).image_data_uint8.data())</span></span>;</span><br><span class="line">  cv::imshow(<span class="string">"cat1_multi:Scene"</span>, img_mat11);</span><br><span class="line">  cv::waitKey(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">  cv::Mat img_mat20 = cv::imdecode(response1.at(<span class="number">0</span>).image_data_uint8, cv::IMREAD_UNCHANGED);</span><br><span class="line">  cv::imshow(<span class="string">"cat2_multi:DepthVis"</span>, img_mat10);</span><br><span class="line">  cv::waitKey(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function">cv::Mat <span class="title">img_mat21</span><span class="params">(response2.at(<span class="number">1</span>).<span class="built_in">height</span>, response2.at(<span class="number">1</span>).<span class="built_in">width</span>, CV_8UC3,</span></span></span><br><span class="line"><span class="function"><span class="params">                    (<span class="keyword">void</span>*)response2.at(<span class="number">1</span>).image_data_uint8.data())</span></span>;</span><br><span class="line">  cv::imshow(<span class="string">"cat2_multi:Scene"</span>, img_mat21);</span><br><span class="line">  cv::waitKey(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">client.reset();</span><br><span class="line">client.enableApiControl(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><p><a href="https://youtu.be/35dgcuLuF5M" target="_blank" rel="noopener"><img data-src="images/demo_multi_vehicles.png" alt="AirSimMultiple Vehicles Demo Video"></a></p>
]]></content>
      <categories>
        <category>自动驾驶</category>
      </categories>
      <tags>
        <tag>自动驾驶</tag>
        <tag>AirSim</tag>
      </tags>
  </entry>
  <entry>
    <title>自动驾驶仿真 - AirSim (9) - 如何在 AirSim 使用雷达</title>
    <url>/posts/954477841/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>针对载具和汽车，AirSim 支持雷达。</p>
<a id="more"></a>
<p>可用及其他雷达设定可以通过 AirSimSettings json 配置.<br>请查看 <a href="sensors.md">general sensors</a> 获取通用/共享的传感器设置.</p>
<h2 id="在汽车上使能雷达-Enabling-lidar-on-a-vehicle"><a href="#在汽车上使能雷达-Enabling-lidar-on-a-vehicle" class="headerlink" title="在汽车上使能雷达 Enabling lidar on a vehicle"></a>在汽车上使能雷达 Enabling lidar on a vehicle</h2><ul>
<li>雷达默认是不可用的。 为了使用雷达， 在 settings json 中设定雷达 SensorType 和 Enabled 属性.</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"Lidar1": &#123;</span><br><span class="line">     "SensorType": 6,</span><br><span class="line">     "Enabled" : true,</span><br></pre></td></tr></table></figure>
<ul>
<li>汽车多雷达也可用.</li>
</ul>
<h2 id="雷达配置-Lidar-configuration"><a href="#雷达配置-Lidar-configuration" class="headerlink" title="雷达配置 Lidar configuration"></a>雷达配置 Lidar configuration</h2><p>目前，下列参数可通过 setting json 来配置.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>NumberOfChannels</td>
<td>雷达的激光/通道数目</td>
</tr>
<tr>
<td>Range</td>
<td>范围， 米值</td>
</tr>
<tr>
<td>PointsPerSecond</td>
<td>每秒捕捉的点数</td>
</tr>
<tr>
<td>RotationsPerSecond</td>
<td>每秒旋转角度</td>
</tr>
<tr>
<td>HorizontalFOVStart</td>
<td>雷达初始 Horizontal FOV, 角度制</td>
</tr>
<tr>
<td>HorizontalFOVEnd</td>
<td>雷达终止 Horizontal FOV, 角度制</td>
</tr>
<tr>
<td>VerticalFOVUpper</td>
<td>雷达 Vertical FOV 上限, 角度制</td>
</tr>
<tr>
<td>VerticalFOVLower</td>
<td>雷达 Vertical FOV 下限, 角度制</td>
</tr>
<tr>
<td>X Y Z</td>
<td>雷达相对于汽车的位置 (NED 坐标系, 米制)</td>
</tr>
<tr>
<td>Roll Pitch Yaw</td>
<td>雷达相对于汽车的方向 (角度制, 沿 +X 方向的 yaw-pitch-roll)</td>
</tr>
<tr>
<td>DataFrame</td>
<td>输出的数据坐标系 (“VehicleInertialFrame” 或 “SensorLocalFrame”)</td>
</tr>
</tbody>
</table>
</div>
<p>例如,</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"SeeDocsAt"</span>: <span class="string">"https://github.com/Microsoft/AirSim/blob/master/docs/settings_json.md"</span>,</span><br><span class="line">  <span class="attr">"SettingsVersion"</span>: <span class="number">1.2</span>,</span><br><span class="line"></span><br><span class="line">  <span class="attr">"SimMode"</span>: <span class="string">"Multirotor"</span>,</span><br><span class="line"></span><br><span class="line">  <span class="attr">"Vehicles"</span>: &#123;</span><br><span class="line">    <span class="attr">"Drone1"</span>: &#123;</span><br><span class="line">      <span class="attr">"VehicleType"</span>: <span class="string">"simpleflight"</span>,</span><br><span class="line">      <span class="attr">"AutoCreate"</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">"Sensors"</span>: &#123;</span><br><span class="line">        <span class="attr">"LidarSensor1"</span>: &#123;</span><br><span class="line">          <span class="attr">"SensorType"</span>: <span class="number">6</span>,</span><br><span class="line">          <span class="attr">"Enabled"</span>: <span class="literal">true</span>,</span><br><span class="line">          <span class="attr">"NumberOfChannels"</span>: <span class="number">16</span>,</span><br><span class="line">          <span class="attr">"RotationsPerSecond"</span>: <span class="number">10</span>,</span><br><span class="line">          <span class="attr">"PointsPerSecond"</span>: <span class="number">100000</span>,</span><br><span class="line">          <span class="attr">"X"</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">"Y"</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">"Z"</span>: <span class="number">-1</span>,</span><br><span class="line">          <span class="attr">"Roll"</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">"Pitch"</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">"Yaw"</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">"VerticalFOVUpper"</span>: <span class="number">-15</span>,</span><br><span class="line">          <span class="attr">"VerticalFOVLower"</span>: <span class="number">-25</span>,</span><br><span class="line">          <span class="attr">"HorizontalFOVStart"</span>: <span class="number">-20</span>,</span><br><span class="line">          <span class="attr">"HorizontalFOVEnd"</span>: <span class="number">20</span>,</span><br><span class="line">          <span class="attr">"DrawDebugPoints"</span>: <span class="literal">true</span>,</span><br><span class="line">          <span class="attr">"DataFrame"</span>: <span class="string">"SensorLocalFrame"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"LidarSensor2"</span>: &#123;</span><br><span class="line">          <span class="attr">"SensorType"</span>: <span class="number">6</span>,</span><br><span class="line">          <span class="attr">"Enabled"</span>: <span class="literal">true</span>,</span><br><span class="line">          <span class="attr">"NumberOfChannels"</span>: <span class="number">4</span>,</span><br><span class="line">          <span class="attr">"RotationsPerSecond"</span>: <span class="number">10</span>,</span><br><span class="line">          <span class="attr">"PointsPerSecond"</span>: <span class="number">10000</span>,</span><br><span class="line">          <span class="attr">"X"</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">"Y"</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">"Z"</span>: <span class="number">-1</span>,</span><br><span class="line">          <span class="attr">"Roll"</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">"Pitch"</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">"Yaw"</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">"VerticalFOVUpper"</span>: <span class="number">-15</span>,</span><br><span class="line">          <span class="attr">"VerticalFOVLower"</span>: <span class="number">-25</span>,</span><br><span class="line">          <span class="attr">"DrawDebugPoints"</span>: <span class="literal">true</span>,</span><br><span class="line">          <span class="attr">"DataFrame"</span>: <span class="string">"SensorLocalFrame"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="用于调试的服务端可视化-Server-side-visualization-for-debugging"><a href="#用于调试的服务端可视化-Server-side-visualization-for-debugging" class="headerlink" title="用于调试的服务端可视化 Server side visualization for debugging"></a>用于调试的服务端可视化 Server side visualization for debugging</h2><p>默认情况下，雷达点不会被绘制在视图中。 为了能够在视图中绘制激光扫描点， 请通过 settings json 使能 <code>DrawDebugPoints</code>.<br>例如,</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"Lidar1": &#123;</span><br><span class="line">     ...</span><br><span class="line">     "DrawDebugPoints": true</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<h2 id="客户端-API-Client-API"><a href="#客户端-API-Client-API" class="headerlink" title="客户端 API Client API"></a>客户端 API Client API</h2><p>使用 <code>getLidarData()</code> API 来获取雷达数据.</p>
<ul>
<li>这个 API 返回带捕捉时间戳和雷达位置的平面阵列的浮点数数组.</li>
<li>点云:<ul>
<li>浮点数表示每个在范围之类最后扫描到的 [x,y,z] 坐标.</li>
<li>输出的数据帧可以通过 “DataFrame” 属性来配置。<br>“” 或者 “VehicleInertialFrame” — 默认; 返回汽车惯性坐标系下的点 (NED 坐标系, 米制)<br>“SensorLocalFrame” — 返回雷达局部坐标系下的点 (NED 坐标系, 米制)</li>
</ul>
</li>
<li>雷达位姿:<ul>
<li>在汽车惯性坐标系下的雷达位姿 (NED 坐标系, 米制)</li>
<li>可以转换到其他坐标系下的点.</li>
</ul>
</li>
</ul>
<h3 id="Python-例程-Python-Examples"><a href="#Python-例程-Python-Examples" class="headerlink" title="Python 例程 Python Examples"></a>Python 例程 Python Examples</h3><p><a href="https://github.com/Microsoft/AirSim/tree/master/PythonClient//multirotor" target="_blank" rel="noopener">drone_lidar.py</a><br><a href="https://github.com/Microsoft/AirSim/tree/master/PythonClient//car" target="_blank" rel="noopener">car_lidar.py</a></p>
<h2 id="即将到来"><a href="#即将到来" class="headerlink" title="即将到来"></a>即将到来</h2><ul>
<li>客户端的雷达数据可视化.</li>
</ul>
]]></content>
      <categories>
        <category>自动驾驶</category>
      </categories>
      <tags>
        <tag>自动驾驶</tag>
        <tag>AirSim</tag>
      </tags>
  </entry>
  <entry>
    <title>自动驾驶仿真 - AirSim (8) - AirSim 传感器</title>
    <url>/posts/3783722863/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>AirSim 目前支持一下传感器.</p>
<a id="more"></a>
<p>每类传感器都与之关联一个整型枚举值来表示传感器类型.</p>
<ul>
<li>Camera</li>
<li>Barometer = 1</li>
<li>Imu = 2</li>
<li>Gps = 3</li>
<li>Magnetometer = 4</li>
<li>Distance Sensor = 5</li>
<li>Lidar = 6</li>
</ul>
<p><strong>注意</strong> : 相机配置与其他传感器不一样,所以没有关联枚举值. 相机配置和 API 查看 <a href="settings.md">general settings</a> 和 <a href="image_apis.md">image API</a> .</p>
<h2 id="默认传感器-Default-sensors"><a href="#默认传感器-Default-sensors" class="headerlink" title="默认传感器 Default sensors"></a>默认传感器 Default sensors</h2><p>如果没有在 <code>settings.json</code> 指定传感器, 基于 sim 模式下,下列传感器默认可用.</p>
<h3 id="载具-Multirotor"><a href="#载具-Multirotor" class="headerlink" title="载具 Multirotor"></a>载具 Multirotor</h3><ul>
<li>Imu</li>
<li>Magnetometer</li>
<li>Gps</li>
<li>Barometer</li>
</ul>
<h3 id="车-Car"><a href="#车-Car" class="headerlink" title="车 Car"></a>车 Car</h3><ul>
<li>Gps</li>
</ul>
<h3 id="计算机视觉-ComputerVision"><a href="#计算机视觉-ComputerVision" class="headerlink" title="计算机视觉 ComputerVision"></a>计算机视觉 ComputerVision</h3><ul>
<li>None</li>
</ul>
<p>场景之后, <a href="https://github.com/Microsoft/AirSim/blob/master/AirLib/include/common/AirSimSettings.hpp" target="_blank" rel="noopener">AirSimSettings.hpp</a> 中的 <code>createDefaultSensorSettings</code> 方法是用来设置上述带默认参数的传感器, 根据在 sim 模式在下 <code>settings.json</code> 文件设定的.</p>
<h2 id="配置默认传感器列表-Configuring-the-default-sensor-list"><a href="#配置默认传感器列表-Configuring-the-default-sensor-list" class="headerlink" title="配置默认传感器列表 Configuring the default sensor list"></a>配置默认传感器列表 Configuring the default sensor list</h2><p>默认传感器列表可以在 settings json 配置:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"DefaultSensors": &#123;</span><br><span class="line">    "Barometer": &#123;</span><br><span class="line">         "SensorType": 1,</span><br><span class="line">         "Enabled" : true</span><br><span class="line">    &#125;,</span><br><span class="line">    "Imu": &#123;</span><br><span class="line">         "SensorType": 2,</span><br><span class="line">         "Enabled" : true</span><br><span class="line">    &#125;,</span><br><span class="line">    "Gps": &#123;</span><br><span class="line">         "SensorType": 3,</span><br><span class="line">         "Enabled" : true</span><br><span class="line">    &#125;,</span><br><span class="line">    "Magnetometer": &#123;</span><br><span class="line">         "SensorType": 4,</span><br><span class="line">         "Enabled" : true</span><br><span class="line">    &#125;,</span><br><span class="line">    "Distance": &#123;</span><br><span class="line">         "SensorType": 5,</span><br><span class="line">         "Enabled" : true</span><br><span class="line">    &#125;,</span><br><span class="line">    "Lidar2": &#123;</span><br><span class="line">         "SensorType": 6,</span><br><span class="line">         "Enabled" : true,</span><br><span class="line">         "NumberOfChannels": 4,</span><br><span class="line">         "PointsPerSecond": 10000</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<h2 id="配置汽车专用传感器列表-Configuring-vehicle-specific-sensor-list"><a href="#配置汽车专用传感器列表-Configuring-vehicle-specific-sensor-list" class="headerlink" title="配置汽车专用传感器列表 Configuring vehicle-specific sensor list"></a>配置汽车专用传感器列表 Configuring vehicle-specific sensor list</h2><p>如果载具提供他自己的传感器列表, 它<strong>必须</strong>提供完整的列表. <strong>不支持</strong> 选择性的增加/删除/更新默认传感器列表<br>汽车专用传感器列表可以在设置汽车的 json 部分设置.<br>即,</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"> "Vehicles": &#123;</span><br><span class="line"></span><br><span class="line">     "Drone1": &#123;</span><br><span class="line">         "VehicleType": "SimpleFlight",</span><br><span class="line">         "AutoCreate": true,</span><br><span class="line">         ...</span><br><span class="line">         "Sensors": &#123;</span><br><span class="line">             "MyLidar1": &#123;</span><br><span class="line">                 "SensorType": 6,</span><br><span class="line">                 "Enabled" : true,</span><br><span class="line">                 "NumberOfChannels": 16,</span><br><span class="line">                 "PointsPerSecond": 10000,</span><br><span class="line">                 "X": 0, "Y": 0, "Z": -1,</span><br><span class="line">                 "DrawDebugPoints": true</span><br><span class="line">             &#125;,</span><br><span class="line">             "MyLidar2": &#123;</span><br><span class="line">                 "SensorType": 6,</span><br><span class="line">                 "Enabled" : true,</span><br><span class="line">                 "NumberOfChannels": 4,</span><br><span class="line">                 "PointsPerSecond": 10000,</span><br><span class="line">                 "X": 0, "Y": 0, "Z": -1,</span><br><span class="line">                 "DrawDebugPoints": true</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="传感器专用设置-Sensor-specific-settings"><a href="#传感器专用设置-Sensor-specific-settings" class="headerlink" title="传感器专用设置 Sensor specific settings"></a>传感器专用设置 Sensor specific settings</h3><p>每种传感器类型也有它自己的设置.</p>
<p>以雷达专用设定为例,请查看 <a href="lidar.md">lidar</a> .</p>
<h2 id="传感器-APIs-Sensor-APIs"><a href="#传感器-APIs-Sensor-APIs" class="headerlink" title="传感器 APIs Sensor APIs"></a>传感器 APIs Sensor APIs</h2><p>使用例程可直接跳转到 <a href="https://github.com/Microsoft/AirSim/blob/master/PythonClient/multirotor/hello_drone.py" target="_blank" rel="noopener"><code>hello_drone.py</code></a> 或 <a href="https://github.com/Microsoft/AirSim/blob/master/HelloDrone/main.cpp" target="_blank" rel="noopener"><code>hello_drone.cpp</code></a> , 或者浏览下述全部的 API.</p>
<ul>
<li><p>Barometer</p>
<p>C++</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">msr::airlib::<span class="function">BarometerBase::Output <span class="title">getBarometerData</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; barometer_name, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; vehicle_name)</span></span>;</span><br></pre></td></tr></table></figure>
<p>Python</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">barometer_data = getBarometerData(barometer_name = <span class="string">""</span>, vehicle_name = <span class="string">""</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>IMU</p>
<p>C++</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">msr::airlib::<span class="function">ImuBase::Output <span class="title">getImuData</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; imu_name = <span class="string">""</span>, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; vehicle_name = <span class="string">""</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>Python</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">imu_data = getImuData(imu_name = <span class="string">""</span>, vehicle_name = <span class="string">""</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>GPS</p>
<p>C++</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">msr::airlib::<span class="function">GpsBase::Output <span class="title">getGpsData</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; gps_name = <span class="string">""</span>, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; vehicle_name = <span class="string">""</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>Python</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">gps_data = getGpsData(gps_name = <span class="string">""</span>, vehicle_name = <span class="string">""</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>Magnetometer</p>
<p>C++</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">msr::airlib::<span class="function">MagnetometerBase::Output <span class="title">getMagnetometerData</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; magnetometer_name = <span class="string">""</span>, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; vehicle_name = <span class="string">""</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>Python</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">magnetometer_data = getMagnetometerData(magnetometer_name = <span class="string">""</span>, vehicle_name = <span class="string">""</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>Distance sensor</p>
<p>C++</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">msr::airlib::<span class="function">DistanceBase::Output <span class="title">getDistanceSensorData</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; distance_sensor_name = <span class="string">""</span>, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; vehicle_name = <span class="string">""</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>Python</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">distance_sensor_name = getDistanceSensorData(distance_sensor_name = <span class="string">""</span>, vehicle_name = <span class="string">""</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>Lidar<br>See <a href="lidar.md">lidar</a> for Lidar API.</p>
</li>
</ul>
]]></content>
      <categories>
        <category>自动驾驶</category>
      </categories>
      <tags>
        <tag>自动驾驶</tag>
        <tag>AirSim</tag>
      </tags>
  </entry>
  <entry>
    <title>github action test</title>
    <url>/posts/1401209445/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>]]></content>
  </entry>
  <entry>
    <title>ROS学习-xacro</title>
    <url>/posts/2389657244/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Xacro(XML Macros)Xacro 是一种 XML 宏语言. 使用 xacro, 可以通过使用宏命令构建更精悍短小但又具有更高可读性的 XML 文件, 这种宏命令可以扩展达到更大的 XML 表达范围. 此包在处理大型 XML 文档(如机器人说明)时最为有用. 它在如 urdf 的包中大量使用. 本文主要来源于<a href="http://wiki.ros.org/xacro" target="_blank" rel="noopener">官方教程</a>.</p>
<a id="more"></a>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p><a href="#1-%e6%a1%88%e4%be%8b">1. 案例</a><br><a href="#2-%e5%b1%9e%e6%80%a7%e5%92%8c%e5%b1%9e%e6%80%a7%e5%9d%97">2. 属性和属性块</a><br><a href="#3-%e6%95%b0%e5%ad%a6%e8%a1%a8%e8%be%be%e5%bc%8f">3. 数学表达式</a><br><a href="#4-%e6%9d%a1%e4%bb%b6%e5%9d%97">4. 条件块</a><br><a href="#4-%e6%9d%a1%e4%bb%b6%e5%9d%97">5. <code>Rospack</code>命令</a><br><a href="#5-rospack%e5%91%bd%e4%bb%a4">6. 宏命令</a><br><a href="#61-%e9%bb%98%e8%ae%a4%e5%8f%82%e6%95%b0">6.1 默认参数</a><br><a href="#62-%e5%b1%80%e9%83%a8%e5%b1%9e%e6%80%a7">6.2 局部属性</a><br><a href="#7-%e5%8c%85%e5%90%ab%e5%85%b6%e4%bb%96xacro%e6%96%87%e4%bb%b6">7. 包含其他<code>xacro</code>文件</a><br><a href="#8-yaml%e8%af%ad%e8%a8%80%e6%94%af">8. <code>YAML</code>语言支持</a><br><a href="#9-%e7%94%a8cmakeliststxt%e8%bf%9b%e8%a1%8c%e6%9e%84%e5%bb%ba">9. 用<code>CMakeLists.txt</code>进行构建</a><br><a href="#10-%e5%85%83%e7%b4%a0%e4%b8%8e%e5%b1%9e%e6%80%a7">10. 元素和属性</a><br><a href="#11-%e5%a4%84%e7%90%86%e9%a1%ba%e5%ba%8f">11. 处理顺序</a><br><a href="#12-%e5%b7%b2%e5%bc%83%e7%94%a8%e7%9a%84%e8%af%ad%e6%b3%95">12. 已弃用的语法</a></p>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>参考以下的<code>Xacro XML</code>片段:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xacro:macro</span> <span class="attr">name</span>=<span class="string">"pr2_arm"</span> <span class="attr">params</span>=<span class="string">"suffix parent reflect"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">pr2_upperarm</span> <span class="attr">suffix</span>=<span class="string">"$&#123;suffix&#125;"</span> <span class="attr">reflect</span>=<span class="string">"$&#123;reflect&#125;"</span> <span class="attr">parent</span>=<span class="string">"$&#123;parent&#125;"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">pr2_forearm</span> <span class="attr">suffix</span>=<span class="string">"$&#123;suffix&#125;"</span> <span class="attr">reflect</span>=<span class="string">"$&#123;reflect&#125;"</span> <span class="attr">parent</span>=<span class="string">"elbow_flex_$&#123;suffix&#125;"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xacro:macro</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">xacro:pr2_arm</span> <span class="attr">suffix</span>=<span class="string">"left"</span> <span class="attr">reflect</span>=<span class="string">"1"</span> <span class="attr">parent</span>=<span class="string">"torso"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">xacro:pr2_arm</span> <span class="attr">suffix</span>=<span class="string">"right"</span> <span class="attr">reflect</span>=<span class="string">"-1"</span> <span class="attr">parent</span>=<span class="string">"torso"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面的片段扩展成为下面的样子:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">pr2_upperarm</span> <span class="attr">suffix</span>=<span class="string">"left"</span> <span class="attr">reflect</span>=<span class="string">"1"</span> <span class="attr">parent</span>=<span class="string">"torso"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">pr2_forearm</span> <span class="attr">suffix</span>=<span class="string">"left"</span> <span class="attr">reflect</span>=<span class="string">"1"</span> <span class="attr">parent</span>=<span class="string">"elbow_flex_left"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">pr2_upperarm</span> <span class="attr">suffix</span>=<span class="string">"right"</span> <span class="attr">reflect</span>=<span class="string">"-1"</span> <span class="attr">parent</span>=<span class="string">"torso"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">pr2_forearm</span> <span class="attr">suffix</span>=<span class="string">"right"</span> <span class="attr">reflect</span>=<span class="string">"-1"</span> <span class="attr">parent</span>=<span class="string">"elbow_flex_right"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果我们还定义了<code>pr2_upperarm</code>和<code>pr2_forearm</code>的宏, 那么这个片段可以扩展以描述整个机器人臂.</p>
<p>本文的其余部分描述了<code>xacro</code>的功能.</p>
<h2 id="属性和属性块"><a href="#属性和属性块" class="headerlink" title="属性和属性块"></a>属性和属性块</h2><p>属性是可以插入到<code>XML</code>文档中的任何位置的值. 属性块是<code>XML</code>的名称片段, 可以插入允许<code>XML</code>的任何位置. 两者都使用属性标签来定义值. 属性标签不能在<code>xacro:macro</code>中声明. 以下示例将显示如何声明和使用属性:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">"the_radius"</span> <span class="attr">value</span>=<span class="string">"2.1"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">"the_length"</span> <span class="attr">value</span>=<span class="string">"4.5"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">geometry</span> <span class="attr">type</span>=<span class="string">"cylinder"</span> <span class="attr">radius</span>=<span class="string">"$&#123;the_radius&#125;"</span> <span class="attr">length</span>=<span class="string">"$&#123;the_length&#125;"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>通过将名称放在<code>dollared-braces</code> (<strong><code>${}</code></strong>)中, 你可以将两个属性值插入到几何表达式中. 如果你想要一个文本<code>&quot;{&quot;</code>, 你应该将其转义为<code>&quot;$${&quot;</code>.<br>下面是使用属性块的示例:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">"front_left_origin"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">"0.3 0 0"</span> <span class="attr">rpy</span>=<span class="string">"0 0 0"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xacro:property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">pr2_wheel</span> <span class="attr">name</span>=<span class="string">"front_left_wheel"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">xacro:insert_block</span> <span class="attr">name</span>=<span class="string">"front_left_origin"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">pr2_wheel</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="数学表达式"><a href="#数学表达式" class="headerlink" title="数学表达式"></a>数学表达式</h2><p>在<code>dollared-braces</code> (<strong><code>${}</code></strong>)中, 您还可以编写简单的数学表达式. 目前, 该结构支持基本算术和变量替换. 下面是一个例子:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">"pi"</span> <span class="attr">value</span>=<span class="string">"3.1415926535897931"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">circle</span> <span class="attr">circumference</span>=<span class="string">"$&#123;2.5 * pi&#125;"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>在<code>Jade</code>版本的<code>ROS</code>中更新的地方:<br>自<code>ROS Jade</code>以来, <code>Xacro</code>使用<code>python</code>来评估包含在<code>dollared-braces</code> (<strong><code>${}</code></strong>)中的表达式. 这允许用户使用更复杂的算术表达式. 此外, 一些基本常数, 例如<code>pi</code>, 已经被预定义过了:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">"R"</span> <span class="attr">value</span>=<span class="string">"2"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">"alpha"</span> <span class="attr">value</span>=<span class="string">"$&#123;30/180*pi&#125;"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">circle</span> <span class="attr">circumference</span>=<span class="string">"$&#123;2 * pi * R&#125;"</span> <span class="attr">pos</span>=<span class="string">"$&#123;sin(alpha)&#125; $&#123;cos(alpha)&#125;"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="条件块"><a href="#条件块" class="headerlink" title="条件块"></a>条件块</h2><p>在<code>Hydro</code>版本的<code>ROS</code>中更新的地方:<br>自从<code>ROS Hydro</code>以来, <code>Xacro</code>有类似于<code>roslaunch</code>的条件块. 这对于可配置的机器人或加载不同的<code>Gazebo</code>插件等事情很有用. 它遵循以下语法:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xacro:if</span> <span class="attr">value</span>=<span class="string">"&lt;expression&gt;"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- &lt;... some xml code here ...&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xacro:if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">xacro:unless</span> <span class="attr">value</span>=<span class="string">"&lt;expression&gt;"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- &lt;... some xml code here ...&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xacro:unless</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>表达式需要计算结果为<code>&quot;0&quot;</code>, <code>&quot;1&quot;</code>, <code>&quot;true&quot;</code>或<code>&quot;false&quot;</code>, 否则将抛出错误.</p>
<p>在<code>Jade</code>版本的<code>ROS</code>中更新的地方:<br><code>ROS Jade</code>中更强大的评估功能允许使用更复杂的表达式. 几乎任何<code>python</code>表达式的计算结果都是可行的:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">"var"</span> <span class="attr">value</span>=<span class="string">"useit"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">xacro:if</span> <span class="attr">value</span>=<span class="string">"$&#123;var == 'useit'&#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">xacro:if</span> <span class="attr">value</span>=<span class="string">"$&#123;var.startswith('use') and var.endswith('it')&#125;"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">"allowed"</span> <span class="attr">value</span>=<span class="string">"[1,2,3]"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">xacro:if</span> <span class="attr">value</span>=<span class="string">"$&#123;1 in allowed&#125;"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="Rospack命令"><a href="#Rospack命令" class="headerlink" title="Rospack命令"></a><code>Rospack</code>命令</h2><p><code>Xacro</code>允许你使用某些<code>rospack</code>命令和<code>dollared-braces</code> (<strong><code>${}</code></strong>).</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">foo</span> <span class="attr">value</span>=<span class="string">"$(find xacro)"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">foo</span> <span class="attr">value</span>=<span class="string">"$(arg myvar)"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>Xacro</code>目前支持使用<code>substitution args</code>的<code>roslaunch</code>支持的所有<code>rospack</code>命令. 参数需要在命令行中使用<code>myvar := true</code>语法指定.</p>
<p>在<code>Indigo</code>版本的<code>ROS</code>中更新的地方:<br>自从<code>ROS Indigo</code>, 它也可以像如下定义默认值:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xacro:arg</span> <span class="attr">name</span>=<span class="string">"myvar"</span> <span class="attr">default</span>=<span class="string">"false"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>通过这种方式, 你可以像下面这样运行<code>xacro</code>:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"robot_description"</span> <span class="attr">command</span>=<span class="string">"$(find xacro)/xacro.py $(arg model) myvar:=true"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="宏命令"><a href="#宏命令" class="headerlink" title="宏命令"></a>宏命令</h2><p><code>xacro</code>的主要特性是它对宏的支持. 使用宏标签定义宏, 并指定宏名称和参数列表. 参数列表应以空格分隔. 它们变成<code>macro-local</code>属性.</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xacro:macro</span> <span class="attr">name</span>=<span class="string">"pr2_caster"</span> <span class="attr">params</span>=<span class="string">"suffix *origin **content **anothercontent"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">joint</span> <span class="attr">name</span>=<span class="string">"caster_$&#123;suffix&#125;_joint"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">axis</span> <span class="attr">xyz</span>=<span class="string">"0 0 1"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">joint</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">name</span>=<span class="string">"caster_$&#123;suffix&#125;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:insert_block</span> <span class="attr">name</span>=<span class="string">"origin"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:insert_block</span> <span class="attr">name</span>=<span class="string">"content"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:insert_block</span> <span class="attr">name</span>=<span class="string">"anothercontent"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xacro:macro</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">xacro:pr2_caster</span> <span class="attr">suffix</span>=<span class="string">"front_left"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">pose</span> <span class="attr">xyz</span>=<span class="string">"0 1 0"</span> <span class="attr">rpy</span>=<span class="string">"0 0 0"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">container</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">color</span> <span class="attr">name</span>=<span class="string">"yellow"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mass</span>&gt;</span>0.1<span class="tag">&lt;/<span class="name">mass</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">container</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">another</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">inertial</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">"0 0 0.5"</span> <span class="attr">rpy</span>=<span class="string">"0 0 0"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">mass</span> <span class="attr">value</span>=<span class="string">"1"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">inertia</span> <span class="attr">ixx</span>=<span class="string">"100"</span>  <span class="attr">ixy</span>=<span class="string">"0"</span>  <span class="attr">ixz</span>=<span class="string">"0"</span> <span class="attr">iyy</span>=<span class="string">"100"</span> <span class="attr">iyz</span>=<span class="string">"0"</span> <span class="attr">izz</span>=<span class="string">"100"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">inertial</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">another</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xacro:pr2_caster</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>该示例声明了一个宏<code>&quot;pr2_caster&quot;</code>, 它有两个参数: <code>suffix</code>和<code>origin</code>. <strong>_请注意, “origin”已加星标. 这表明 origin 是一个块参数, 而不是一个简单的文本参数_</strong>. 看下<code>pr2_caster</code>的使用. <code>suffix</code>属性(<code>property</code>)在<code>pr2_caster</code>标签中定义为属性(<code>attribute</code>), 但没有定义<code>origin</code>属性. 相反, <code>origin</code>指的是第一个元素(<code>&quot;pose&quot;</code>块). <strong>_双星号版本(<code>&quot;content&quot;</code>, <code>&quot;anothercontent&quot;</code>)允许插入在随后可用的元素(在上面的示例中分别是<code>&quot;container&quot;</code>, <code>&quot;another&quot;</code>)中传递的任意数量的元素_</strong>. 此示例扩展为以下内容:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">joint</span> <span class="attr">name</span>=<span class="string">"caster_front_left_joint"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">axis</span> <span class="attr">xyz</span>=<span class="string">"0 0 1"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">joint</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">name</span>=<span class="string">"caster_front_left"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">pose</span> <span class="attr">xyz</span>=<span class="string">"0 1 0"</span> <span class="attr">rpy</span>=<span class="string">"0 0 0"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">color</span> <span class="attr">name</span>=<span class="string">"yellow"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mass</span>&gt;</span>0.1<span class="tag">&lt;/<span class="name">mass</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">inertial</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">"0 0 0.5"</span> <span class="attr">rpy</span>=<span class="string">"0 0 0"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mass</span> <span class="attr">value</span>=<span class="string">"1"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">inertia</span> <span class="attr">ixx</span>=<span class="string">"100"</span>  <span class="attr">ixy</span>=<span class="string">"0"</span>  <span class="attr">ixz</span>=<span class="string">"0"</span> <span class="attr">iyy</span>=<span class="string">"100"</span> <span class="attr">iyz</span>=<span class="string">"0"</span> <span class="attr">izz</span>=<span class="string">"100"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">inertial</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>多个块参数将按指定的顺序处理:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xacro:macro</span> <span class="attr">name</span>=<span class="string">"reorder"</span> <span class="attr">params</span>=<span class="string">"*first *second"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">xacro:insert_block</span> <span class="attr">name</span>=<span class="string">"second"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">xacro:insert_block</span> <span class="attr">name</span>=<span class="string">"first"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xacro:macro</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">reorder</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">first</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">second</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">reorder</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>宏可能包含其他宏. 外部宏将首先展开, 然后内部宏将展开. 例如:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">xacro:macro</span> <span class="attr">name</span>=<span class="string">"foo"</span> <span class="attr">params</span>=<span class="string">"x"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">in_foo</span> <span class="attr">the_x</span>=<span class="string">"$&#123;x&#125;"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">xacro:macro</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">xacro:macro</span> <span class="attr">name</span>=<span class="string">"bar"</span> <span class="attr">params</span>=<span class="string">"y"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">in_bar</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">xacro:foo</span> <span class="attr">x</span>=<span class="string">"$&#123;y&#125;"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">in_bar</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">xacro:macro</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">xacro:bar</span> <span class="attr">y</span>=<span class="string">"12"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>变成:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">in_bar</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">in_foo</span> <span class="attr">the_x</span>=<span class="string">"12.0"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">in_bar</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><p><code>Indigo</code>中更新<br>宏参数可以有默认值:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xacro:macro</span> <span class="attr">name</span>=<span class="string">"foo"</span> <span class="attr">params</span>=<span class="string">"x:=$&#123;x&#125; y:=$&#123;2*y&#125; z:=0"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果默认值包含评估表达式, 则将在实例化时评估它们.</p>
<p><code>Jade</code>中更新<br>通常, 您需要将外部变量传递到本地宏参数(如上面的<code>x</code>). 要简化此任务, 可以使用<code>^</code>语法:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xacro:macro</span> <span class="attr">name</span>=<span class="string">"foo"</span> <span class="attr">params</span>=<span class="string">"p1 p2:=expr_a p3:=^ p4:=^|expr_b"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>插入符号<code>^</code>表示使用外部<code>scope</code>属性(具有相同名称). 管道<code>|</code>表示如果属性未在外部范围中定义, 则使用给定的回退.</p>
<h2 id="局部属性"><a href="#局部属性" class="headerlink" title="局部属性"></a>局部属性</h2><p><code>Jade</code>中更新<br>在宏中定义的属性和宏对于该宏来说是局部的, 即在外部不可见. 使用可选属性<code>scope =&quot;parent | global&quot;</code>, 属性定义可以导出到宏的父作用域(或全局作用域).</p>
<h2 id="包含其他xacro文件"><a href="#包含其他xacro文件" class="headerlink" title="包含其他xacro文件"></a>包含其他<code>xacro</code>文件</h2><p>您可以使用<code>xacro: include</code>标签来包含其他<code>xacro</code>文件:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xacro:include</span> <span class="attr">filename</span>=<span class="string">"$(find package)/other_file.xacro"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">xacro:include</span> <span class="attr">filename</span>=<span class="string">"other_file.xacro"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">xacro:include</span> <span class="attr">filename</span>=<span class="string">"$(cwd)/other_file.xacro"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>文件<code>&quot;other_file.xacro&quot;</code>将被<code>xacro</code>包含和扩展. <code>Jade</code>中的新功能: 相对文件名相对于当前处理的文件进行解释. <strong>注意: 当在宏中包含文件时, 包含处理不是宏定义, 而是宏调用文件</strong>! <code>$(cwd)</code>显式的允许访问当前工作目录中的文件.<br>为了避免各种包含文件的属性和宏之间的名称冲突, 可以为包含的文件指定命名空间 - 提供属性<code>ns</code>:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xacro:include</span> <span class="attr">filename</span>=<span class="string">"other_file.xacro"</span> <span class="attr">ns</span>=<span class="string">"namespace"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>访问命名空间宏和属性是通过预先命名空间来实现的, 用点分隔:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">$&#123;namespace.property&#125;</span><br></pre></td></tr></table></figure>
<h2 id="YAML语言支"><a href="#YAML语言支" class="headerlink" title="YAML语言支"></a><code>YAML</code>语言支</h2><p><code>Jade</code>中的新功能<br>属性可以是用<code>python</code>语法声明的字典或列表, 如下所示:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">"props"</span> <span class="attr">value</span>=<span class="string">"$&#123;dict(a=1, b=2, c=3)&#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">"numbers"</span> <span class="attr">value</span>=<span class="string">"$&#123;[1,2,3,4]&#125;"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>或者从<code>YAML</code>文件中加载, 如下:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">"props"</span> <span class="attr">value</span>=<span class="string">"$&#123;load_yaml('props.yaml')&#125;"</span>/</span></span><br></pre></td></tr></table></figure>
<p>注意, 通过<code>evaluation brackets ${}</code>区分评价和纯文本定义. 校准数据是从 YAML 加载的理想候选.</p>
<h2 id="用CMakeLists-txt进行构建"><a href="#用CMakeLists-txt进行构建" class="headerlink" title="用CMakeLists.txt进行构建"></a>用<code>CMakeLists.txt</code>进行构建</h2><p>以下代码段显示如何在程序包的申明期间使用<code>xacro</code>:</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Generate .world files from .world.xacro files</span></span><br><span class="line"><span class="keyword">find_package</span>(xacro REQUIRED)</span><br><span class="line"><span class="comment"># You can also add xacro to the list of catkin packages:</span></span><br><span class="line"><span class="comment">#   find_package(catkin REQUIRED COMPONENTS ... xacro)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Xacro files</span></span><br><span class="line"><span class="keyword">file</span>(GLOB xacro_files <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/worlds/*.world.xacro)</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span>(it <span class="variable">$&#123;xacro_files&#125;</span>)</span><br><span class="line">  <span class="comment"># remove .xacro extension</span></span><br><span class="line">  <span class="keyword">string</span>(REGEX MATCH <span class="string">"(.*)[.]xacro$"</span> unused <span class="variable">$&#123;it&#125;</span>)</span><br><span class="line">  <span class="keyword">set</span>(output_filename <span class="variable">$&#123;CMAKE_MATCH_1&#125;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># create a rule to generate $&#123;output_filename&#125; from &#123;it&#125;</span></span><br><span class="line">  xacro_add_xacro_file(<span class="variable">$&#123;it&#125;</span> <span class="variable">$&#123;output_filename&#125;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">list</span>(APPEND world_files <span class="variable">$&#123;output_filename&#125;</span>)</span><br><span class="line"><span class="keyword">endforeach</span>(it)</span><br><span class="line"></span><br><span class="line"><span class="comment"># add an abstract target to actually trigger the builds</span></span><br><span class="line"><span class="keyword">add_custom_target</span>(media_files ALL DEPENDS <span class="variable">$&#123;world_files&#125;</span>)</span><br></pre></td></tr></table></figure>
<p><code>Jade</code>中的新功能:<br>虽然这个<code>cmake</code>代码提供了对目标名称和构建顺序的完全控制, 但还有一个更简便的宏:</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">file</span>(GLOB xacro_files worlds/*.world.xacro)</span><br><span class="line">xacro_add_files(<span class="variable">$&#123;xacro_files&#125;</span> <span class="keyword">TARGET</span> media_files)</span><br></pre></td></tr></table></figure>
<h2 id="元素与属性"><a href="#元素与属性" class="headerlink" title="元素与属性"></a>元素与属性</h2><p><code>Jade</code>中的新功能:<br>要使用动态定义的名称添加元素或属性, 可以使用特殊的<code>xacro</code>标签</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xacro:element</span> <span class="attr">xacro:name</span>=<span class="string">"$&#123;element_name&#125;"</span> [<span class="attr">other</span> <span class="attr">attributes</span>]&gt;</span></span><br><span class="line"> [content]</span><br><span class="line"><span class="tag">&lt;/<span class="name">xacro:element</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">xacro:attribute</span> <span class="attr">name</span>=<span class="string">"$&#123;attribute_name&#125;"</span> <span class="attr">value</span>=<span class="string">"$&#123;attribute_value&#125;"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="处理顺序"><a href="#处理顺序" class="headerlink" title="处理顺序"></a>处理顺序</h2><p><code>Classicly Xacro</code>首先加载所有包含项, 然后处理所有属性和宏定义, 最后实例化宏并计算表达式. 因此, <strong>后期定义的属性或宏定义将覆盖先前的定义</strong>. 此外, 条件标签, <code>&lt;if&gt;</code>和<code>&lt;unless&gt;</code>, 对宏或属性定义以及包含的其他文件没有影响.</p>
<p><code>Jade</code>中的新功能:<br>自<code>ROS Jade</code>以来, <code>Xacro</code>提供了命令行选项<code>–-inorder</code>, 允许以读取的顺序来处理整个文档. 因此, 将使用属性或宏的最新定义. 这是一个更直观的评估过程, 提供了一些不错的新功能:</p>
<ul>
<li>如果<code>&lt;include&gt;</code>标签分别放置在宏内或条件标签中, 则可以推迟或完全禁止包含文件.</li>
<li>包含文件名可以通过属性或宏参数指定.</li>
<li>通过更改全局范围的属性, 如果在宏中使用这些属性, 则宏的实例化可以产生不同的结果.</li>
<li>属性定义可以是有条件的.</li>
<li>宏可以在局部范围内定义属性, 而不会影响外部.</li>
</ul>
<p>因为<code>–-inorder</code>处理更强大, 在未来<code>Jade</code>以后的版本, 新的处理风格将成为默认风格, 所以你应该检查你的<code>xacro</code>文件的兼容性. 通常, 两种加工方式应该给出相同的结果. 你可以很容易地像下面这样检查:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rosrun xacro xacro file.xacro &gt; /tmp/old.xml</span><br><span class="line">rosrun xacro xacro --inorder file.xacro &gt; /tmp/new.xml</span><br><span class="line">diff /tmp/old.xml /tmp/new.xml</span><br></pre></td></tr></table></figure>
<p>如果结果显示出任何差异, 你应检查并调整您的 xacro 文件. 常见的原因是校准数据后期加载了(作为属性). 在这种情况下, 只需将加载行为向前移动, 即在使用之前进行校准数据的加载. 为了方便搜索错误放置的属性定义, 可以使用选项<code>-–check--order</code>运行<code>xacro</code>. 如果任何有问题的属性, 它们将在<code>stderr</code>上列出:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Document is incompatible to --inorder processing.</span><br><span class="line">The following properties were redefined after usage:</span><br><span class="line">foo redefined <span class="keyword">in</span> issues.xacro</span><br></pre></td></tr></table></figure>
<p>使用命令行选项<code>-vv</code>或<code>-vvv</code>, 可以增加详细程度级别以记录属性的所有定义.</p>
<h2 id="已弃用的语法"><a href="#已弃用的语法" class="headerlink" title="已弃用的语法"></a>已弃用的语法</h2><p><code>Jade</code>中的新功能:<br>虽然在以前的版本中, 没有命名空间前缀的<code>xacro</code>标签能够被接受并使用, 但是这种草率的语法是我们应当强烈反对的, 因为它阻止在最终的<code>XML</code>中使用这些标签. 从<code>Jade</code>开始, 这种语法已被弃用, 你应该相应地更新你的文件. 以下脚本将为您更新文件:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find . -iname <span class="string">"*.xacro"</span> | xargs sed -i <span class="string">'s#&lt;\([/]\?\)\(if\|unless\|include\|arg\|property\|macro\|insert_block\)#&lt;\1xacro:\2#g'</span></span><br></pre></td></tr></table></figure>
<hr>
<p>参考链接:</p>
<ul>
<li><a href="http://wiki.ros.org/xacro" target="_blank" rel="noopener">http://wiki.ros.org/xacro</a></li>
<li><a href="https://blog.csdn.net/chishuideyu/article/details/53695392" target="_blank" rel="noopener">https://blog.csdn.net/chishuideyu/article/details/53695392</a></li>
</ul>
]]></content>
      <categories>
        <category>ROS学习</category>
      </categories>
      <tags>
        <tag>ROS</tag>
        <tag>xacro</tag>
      </tags>
  </entry>
  <entry>
    <title>ROS学习-roslaunch_xml</title>
    <url>/posts/73359715/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>这个页面描述了用于<code>roslaunch</code>的<code>.launch</code>文件的<code>XML</code>格式. 有关<code>roslaunch</code>的背景、功能和相关工具, 请先访问<code>roslaunch</code>页面.</p>
<a id="more"></a>
<p><a href="#%e6%96%87%e4%bb%b6%e8%a7%a3%e6%9e%90%e9%a1%ba%e5%ba%8f">文件解析顺序</a><br><a href="#%e7%bd%ae%e6%8d%a2%e5%8f%82%e6%95%b0">置换参数</a></p>
<ul>
<li><a href="#env-environmentvariable">env ENVIRONMENT_VARIABLE</a></li>
<li><a href="#optenv-environmentvariable%e5%92%8coptenv-environmentvariable-defaultvalue">optenv ENVIRONMENT_VARIABLE / optenv ENVIRONMENT_VARIABLE default_value</a></li>
<li><a href="#find-pkg">find pkg</a></li>
<li><a href="#anon-name">anon name</a></li>
<li><a href="#arg-variblename">arg varible_name</a></li>
<li><a href="#eval-expression-new-in-kinetic">eval expression</a></li>
</ul>
<p><a href="#3-if-%e5%92%8c-unless-%e5%b1%9e%e6%80%a7">IF 和 UNLESS 属性</a></p>
<p><a href="#%e5%8f%82%e8%80%83%e6%a0%87%e7%ad%be">参考标签</a></p>
<ul>
<li><a href="#launch">launch</a></li>
<li><a href="#node">node</a></li>
<li><a href="#param">param</a></li>
<li><a href="#rosparam">rosparam</a></li>
<li><a href="#remap">remap</a></li>
<li><a href="#machine">machine</a></li>
<li><a href="#include">include</a></li>
<li><a href="#env">env</a></li>
<li><a href="#test">test</a></li>
<li><a href="#arg">arg</a></li>
<li><a href="#group">group</a></li>
</ul>
<p><a href="#launch%e6%96%87%e4%bb%b6%e7%9a%84%e4%be%8b%e5%ad%90">launch 文件的例子</a></p>
<ul>
<li><a href="#%e4%b8%80%e4%b8%aa%e7%ae%80%e5%8d%95%e7%9a%84%e4%be%8b%e5%ad%90">一个简单的例子</a></li>
<li><a href="#%e4%b8%80%e4%b8%aa%e5%a4%8d%e6%9d%82%e4%b8%80%e7%82%b9%e7%9a%84%e4%be%8b%e5%ad%90">一个复杂一点的例子</a></li>
<li><a href="#%e8%ae%be%e7%bd%ae%e5%8f%82%e6%95%b0">设置参数</a></li>
</ul>
<h2 id="文件解析顺序"><a href="#文件解析顺序" class="headerlink" title="文件解析顺序"></a>文件解析顺序</h2><p><code>roslaunch</code> 以单程的方式解析 XML 格式文件, <code>include</code> 是以深度优先的方式解析内容, 而标签<code>Tag</code>以串行的方式处理, 所以一个参数的最后一次设置被认定为有效值. 也就是说在<code>. launch</code>文件中同样的设置可能存在多处, 比如在开头定义了一个变量, 遵循着尽量节省空间的想法, 在后面的定义中又对这个变量进行了重新赋值, 以便重新利用, 在这种情况下, 在整个<code>launch</code>文件解析完成后, 最终进行的那次设置是有效的, 但也并不保证一定有效, 不排除在其它的文件中对变量进行了重命名, 所以推荐使用<code>$(arg)/&lt;arg&gt;</code>的方式进行覆写.</p>
<h2 id="置换参数"><a href="#置换参数" class="headerlink" title="置换参数"></a>置换参数</h2><p><code>roslaunch</code>标签属性可以使用置换参数, <code>roslaunch</code>将在启动节点之前解析这些置换参数. 目前支持的置换参数是：</p>
<h3 id="env-ENVIRONMENT-VARIABLE"><a href="#env-ENVIRONMENT-VARIABLE" class="headerlink" title="$(env ENVIRONMENT_VARIABLE)"></a><code>$(env ENVIRONMENT_VARIABLE)</code></h3><p>其中的<script type="math/tex">`是一个置换处理标志, 类似`shell`中的`</script>. 从当前环境变量替换变量的值. 如果没有设置环境变量, 启动将失败. 该值不能被<code>&lt;env&gt;</code>标签覆盖. —就是说用环境变量<code>ENVIRONMENT_VARIABLE</code>设置的值来替换目标值. 例子：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"variable_name"</span> <span class="attr">value</span>=<span class="string">"$(env NUM_CPUS)"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>param</code>是<code>launch</code>文件参数定义的标签, <code>name</code>属性表示定义的变量名称, <code>value</code>属性表示对定义变量进行赋值或替代. 类似于<code>variable_name=$(env NUM_CPUS)</code>. 如果没有设置环境变量<code>NUM_CPUS</code>, <code>roslaunch</code>启动时将报错.</p>
<h3 id="optenv-ENVIRONMENT-VARIABLE-和-optenv-ENVIRONMENT-VARIABLE-default-value"><a href="#optenv-ENVIRONMENT-VARIABLE-和-optenv-ENVIRONMENT-VARIABLE-default-value" class="headerlink" title="$(optenv ENVIRONMENT_VARIABLE)和$(optenv ENVIRONMENT_VARIABLE default_value)"></a><code>$(optenv ENVIRONMENT_VARIABLE)</code>和<code>$(optenv ENVIRONMENT_VARIABLE default_value)</code></h3><p>和上条的区别在于, <code>optenv</code>表示这是一个可选的环境变量(<code>optional environment</code>). 假如没有设置环境变量<code>ENVIRONMENT_VARIABLE</code>, 若提供了<code>default_value</code>值, 则, 则用<code>default_value</code>替代目标变量, 若没有提供该值, 则用空字符串表示(<code>roslaunch</code>启动时, 不会报错). <code>default_value</code>的值可以是包含被空格分隔的多字符.</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 若设置了环境变量 NUM_CPUS, 则 foo = $NUM_CPUS, 否则 foo = "1". 如果没有默认值 1, 那么 foo = "". --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"foo"</span> <span class="attr">value</span>=<span class="string">"$(optenv NUM_CPUS 1)"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 若设置了环境变量 CONFIG_PATH, 则 foo = $CONFIG_PATH, 否则 foo = "/home/marvin/ros_workspace". --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"foo"</span> <span class="attr">value</span>=<span class="string">"$(optenv CONFIG_PATH /home/marvin/ros_workspace)"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 若设置了环境变量 VARIABLE, 则 foo = $VARIABLE, 否则 foo = "ros rocks". 变量可以包含空格字符串. --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"foo"</span> <span class="attr">value</span>=<span class="string">"$(optenv VARIABLE ros rocks)"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="find-pkg"><a href="#find-pkg" class="headerlink" title="$(find pkg)"></a><code>$(find pkg)</code></h3><p>查找包路径. 例如<code>$(find rospy)/manifest.xml</code>指定包相对路径。包目录的完整文件路径将被内联替换。强烈建议使用包相对路径，因为硬编码路径会限制启动配置的可移植性。前斜杠和后斜杠将按惯例被解析为本地文件系统。</p>
<h3 id="anon-name"><a href="#anon-name" class="headerlink" title="$(anon name)"></a><code>$(anon name)</code></h3><p>产生基于名称的匿名 ID, 主要用于节点名称属性中创建匿名节点, 并检查是否有相同的匿名名字, 因为 ROS 中名字作为标识符要求具有唯一性. 其中的 anon 是 anonymous 的简写. 例如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">"$(anon talk_01)"</span> <span class="attr">pkg</span>=<span class="string">"rospy_tutorials"</span> <span class="attr">type</span>=<span class="string">"talker.py"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">"$(anon talk_01)"</span> <span class="attr">pkg</span>=<span class="string">"rospy_tutorials"</span> <span class="attr">type</span>=<span class="string">"talker.py"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>则会产生错误, 因为系统检测到了两个节点具有相同的匿名名字.</p>
<h3 id="arg-varible-name"><a href="#arg-varible-name" class="headerlink" title="$(arg varible_name)"></a><code>$(arg varible_name)</code></h3><p>解析由<code>&lt;arg&gt;</code>标签指定的变量值. 必须在声明<code>arg</code>的同一启动文件中有对应的<code>&lt;arg&gt;</code>标签。 例如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"foo"</span> <span class="attr">value</span>=<span class="string">"$(arg my_foo)"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>将<code>my_foo</code>的值赋给参数<code>foo</code>. 这样在解析<code>my_foo</code>的值的时候才能正常进行. 就如同你在表达式中用一个变量进行计算, 你必须在计算之前就已经定义过这个变量才可以. 再如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">"add_two_ints_server"</span> <span class="attr">pkg</span>=<span class="string">"beginner_tutorials"</span> <span class="attr">type</span>=<span class="string">"add_two_ints_server"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">"add_two_ints_client"</span> <span class="attr">pkg</span>=<span class="string">"beginner_tutorials"</span> <span class="attr">type</span>=<span class="string">"add_two_ints_client"</span> <span class="attr">args</span>=<span class="string">"$(arg a) $(arg b)"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>其中的<code>$(arg a)</code>和<code>$(arg b)</code>则是对节点所需要的变量进行声明, 这样你在对节点进行参数传递的时候就可以用以下代码进行：<br><code>roslaunch beginner_tutorials launch_file.launch a:=1 b:=5</code></p>
<h3 id="eval-lt-expression-gt-New-in-Kinetic"><a href="#eval-lt-expression-gt-New-in-Kinetic" class="headerlink" title="$(eval &lt;expression&gt;) New in Kinetic"></a><code>$(eval &lt;expression&gt;)</code> <strong>New in Kinetic</strong></h3><p>允许计算任意复杂的<code>python</code>表达式. 例如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"circumference"</span> <span class="attr">value</span>=<span class="string">"$(eval 2. * 3. 1415 * arg('radius'))"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>会根据给定的<code>radius</code>进行计算后将结果赋给<code>circumference</code>. 作为限制, <code>$(eval)</code>的作用范围要跨越表示整个表达式的字符串, 如果在其中插入其它属性是不可行的. 例如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"a_name"</span> <span class="attr">value</span>=<span class="string">"$(arg r_dis) $(eval 6*7) bar"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>是不可行的. 为了弥补这个限制，所有的替换命令都可以作为函数在 eval 中使用:</p>
<blockquote>
<p><code>&quot;$(eval arg(&#39;sth&#39;) + env(&#39;PATH&#39;) + &#39;bar&#39; + find(&#39;pkg&#39;))&quot;</code></p>
</blockquote>
<p>为了方便起见，参数也是隐式解析的，即以下两个表达式是相同的:</p>
<blockquote>
<p><code>&quot;$(eval arg(&#39;foo&#39;))&quot;</code><br><code>&quot;$(eval foo)&quot;</code></p>
</blockquote>
<h2 id="IF-和-UNLESS-属性"><a href="#IF-和-UNLESS-属性" class="headerlink" title="IF 和 UNLESS 属性"></a><code>IF</code> 和 <code>UNLESS</code> 属性</h2><p>所有的标签都支持<code>if</code>和<code>unless</code>属性, 此类属性是基于计算的值包含或是排除一个标签的内容.</p>
<blockquote>
<p><code>if = value (optional)</code><br>如果 value 的值为真则包含标签及内容.</p>
<p><code>unless = value (optional)</code><br>如果值为假, 则包括此内容.</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">group</span> <span class="attr">if</span>=<span class="string">"$(arg foo)"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- stuff that will only be evaluated if foo is true --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">group</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"foo"</span> <span class="attr">value</span>=<span class="string">"bar"</span> <span class="attr">unless</span>=<span class="string">"$(arg foo)"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- This param won't be set when "unless" condition is met --&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="参考标签"><a href="#参考标签" class="headerlink" title="参考标签"></a>参考标签</h2><h3 id="lt-launch-gt"><a href="#lt-launch-gt" class="headerlink" title="&lt;launch&gt;"></a><code>&lt;launch&gt;</code></h3><blockquote>
<p><code>&lt;launch&gt;</code>标签为所有 roslaunch 文件的根标签, 可以将其理解为所有其它标签的容器. 以下为<code>&lt;launch&gt;</code>标签与其它标签的关系：</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">remap</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">machine</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rosparam</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">env</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">test</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">arg</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">group</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="lt-node-gt"><a href="#lt-node-gt" class="headerlink" title="&lt;node&gt;"></a><code>&lt;node&gt;</code></h3><p>用来启动节点, 但不保证节点的启动顺序.</p>
<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">pkg="mypackage"</span><br><span class="line"><span class="comment">&lt;!--指定所用的包--&gt;</span></span><br><span class="line"></span><br><span class="line">type="nodetype"</span><br><span class="line"><span class="comment">&lt;!--指定对应的可执行程序的名字--&gt;</span></span><br><span class="line"></span><br><span class="line">name="nodename"</span><br><span class="line"><span class="comment">&lt;!--指定节点名称, 但不能在这里加入命名空间名称--&gt;</span></span><br><span class="line"></span><br><span class="line">args="arg1 arg2 arg3"</span><br><span class="line"><span class="comment">&lt;!--声明或传递参数(optional)--&gt;</span></span><br><span class="line"></span><br><span class="line">machine="machine-name"</span><br><span class="line"><span class="comment">&lt;!--在指定的机器上启动节点(optional)--&gt;</span></span><br><span class="line"></span><br><span class="line">respawn="true"</span><br><span class="line"><span class="comment">&lt;!--如果节点失败则重新启动(optional)--&gt;</span></span><br><span class="line"></span><br><span class="line">respawn_delay="30"</span><br><span class="line"><span class="comment">&lt;!--如果上rospawn属性为真, 则等待一定的时间之后重新启动节点(optional, New in indigo)--&gt;</span></span><br><span class="line"></span><br><span class="line">required="true"</span><br><span class="line"><span class="comment">&lt;!--将节点定义为必需节点, 如果本节点失效, 则关闭整个文件(optional)--&gt;</span></span><br><span class="line"></span><br><span class="line">ns="nnss"</span><br><span class="line"><span class="comment">&lt;!--在一个命名空间中启动节点(optional)--&gt;</span></span><br><span class="line"></span><br><span class="line">clear_params="true|false"</span><br><span class="line"><span class="comment">&lt;!--在节点启动之前是否清空所在命名空间中的变量(optional)--&gt;</span></span><br><span class="line"></span><br><span class="line">output="log|screen"</span><br><span class="line"><span class="comment">&lt;!--指定输出的对象(optional)--&gt;</span></span><br><span class="line"></span><br><span class="line">cwd="ROS_HOME|node"</span><br><span class="line"><span class="comment">&lt;!--指定node则节点工作路径与其可执行程序路径相同(optional)--&gt;</span></span><br><span class="line"></span><br><span class="line">launch-prefix="prefix arguments"</span><br><span class="line"><span class="comment">&lt;!--预先处理指令或参数(optional, 支持多种工具)--&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="元素"><a href="#元素" class="headerlink" title="元素"></a>元素</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">node</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">env</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">remap</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rosparam</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">node</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="lt-param-gt"><a href="#lt-param-gt" class="headerlink" title="&lt;param&gt;"></a><code>&lt;param&gt;</code></h3><p>用于在参数服务器中定义参数. 其属性参数如下所示：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">name="namespace/name"</span><br><span class="line"><span class="comment">&lt;!-- 参数名称. 在这个名称定义中是可以使用命名空间的, 而在node的名称定义中不能使用命名空间, 这个是有区别的. 但是应该避免指定全局的名称.  --&gt;</span></span><br><span class="line"></span><br><span class="line">value="value"</span><br><span class="line"><span class="comment">&lt;!-- 定义参数的值, 如果这一属性忽略掉了, 但必须指定 binfile, textfile or command.  --&gt;</span></span><br><span class="line"></span><br><span class="line">type="str|int|double|bool|yaml"</span><br><span class="line"><span class="comment">&lt;!-- 指定参数的类型(optional), 如果不指定则会自动识别类型, 规则如下：</span></span><br><span class="line"><span class="comment">1. 有“. ”的认为是浮点数, 没有的则认为是整型.</span></span><br><span class="line"><span class="comment">2. ”true” 和 “false” 被认为是逻辑变量 (not case-sensitive).</span></span><br><span class="line"><span class="comment">3. 其它的所有都为string型.  --&gt;</span></span><br><span class="line"></span><br><span class="line">textfile="$(find pkg-name)/path/file.txt"</span><br><span class="line"><span class="comment">&lt;!-- 文件的内容被存储为string类型用以替代目标变量(optional). 该文件必须是本地可访问的, 但是强烈建议使用包相对路径$(find)/file.txt的语法来指定位置。  --&gt;</span></span><br><span class="line"></span><br><span class="line">binfile="$(find pkg-name)/path/file"</span><br><span class="line"><span class="comment">&lt;!-- 内容将被存储为 base64-encoded XML-RPC 二进制对象用以替代目标变量(optional). 同上建议相对路径指定位置 --&gt;</span></span><br><span class="line"></span><br><span class="line">command="$(find pkg-name)/exe '$(find pkg-name)/arg. txt'"(optional)</span><br><span class="line"><span class="comment">&lt;!-- 执行某项命令, 命令的输出将被存储为一个string类型以替代目标变量. 文件的路径变量需要用单引号包括.  --&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在参数服务器中定义名称为：publish_frequency, 类型为：double, 值为：10.0 的变量.  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"publish_frequency"</span> <span class="attr">type</span>=<span class="string">"double"</span> <span class="attr">value</span>=<span class="string">"10.0"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 如果是加载 YAML 文件可以用以下代码，其中的 file 属性要指定路径和文件名.  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">rosparam</span> <span class="attr">command</span>=<span class="string">"load"</span> <span class="attr">file</span>=<span class="string">"FILENAME"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="lt-rosparam-gt"><a href="#lt-rosparam-gt" class="headerlink" title="&lt;rosparam&gt;"></a><code>&lt;rosparam&gt;</code></h3><p>支持从<code>YAML</code>文件读取与卸载参数.</p>
<h4 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- rosparam的命令, 可以指定 加载|卸载|删除 对应的参数.  --&gt;</span></span><br><span class="line">command="load|dump|delete" (optional, default=load)</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 指定文件所要求的路径.  --&gt;</span></span><br><span class="line">file="$(find pkg-name)/path/my. yaml" (load or dump commands)</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 参数名称 --&gt;</span></span><br><span class="line">param="param-name"</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 设定参数给指定的命名空间（设定参数的作用域） --&gt;</span></span><br><span class="line">ns="namespace" (optional)</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 是否运允许使用YAML文件中置换参数 --&gt;</span></span><br><span class="line">subst_value=true|false (optional)</span><br></pre></td></tr></table></figure>
<h4 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 加载.yaml文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">rosparam</span> <span class="attr">command</span>=<span class="string">"load"</span> <span class="attr">file</span>=<span class="string">"$(find rosparam)/example.yaml"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 卸载.yaml文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">rosparam</span> <span class="attr">command</span>=<span class="string">"delete"</span> <span class="attr">param</span>=<span class="string">"my/param"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 定义一个变量 a_list, 而变量的值即为标签之间的所有内容, 即 a_list = [1, 2, 3, 4, 5] --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">rosparam</span> <span class="attr">param</span>=<span class="string">"a_list"</span>&gt;</span>[1, 2, 3, 4]<span class="tag">&lt;/<span class="name">rosparam</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">rosparam</span>&gt;</span></span><br><span class="line">  a: 1</span><br><span class="line">  b: 2</span><br><span class="line"><span class="tag">&lt;/<span class="name">rosparam</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 参数置换允许您使用 roslaunch args 来表示一个 YAML 字符串的全部或部分 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 如果subst_value为false, 表示不允许使用替代标签, 则输出的blacklist只是一个字符串$(arg whitelist); 但如果为true则表示允许使用替代标签, 则blacklist输出的值为[3, 2].  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">"whitelist"</span> <span class="attr">default</span>=<span class="string">"[3, 2]"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">rosparam</span> <span class="attr">param</span>=<span class="string">"whitelist"</span> <span class="attr">subst_value</span>=<span class="string">"True"</span>&gt;</span>$(arg whitelist)<span class="tag">&lt;/<span class="name">rosparam</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 它们对于在yaml字符串中嵌入$(find…)和其他替换模式也很有用。 --&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="lt-remap-gt"><a href="#lt-remap-gt" class="headerlink" title="&lt;remap&gt;"></a><code>&lt;remap&gt;</code></h3><p>用来通过名称进行参数之间的映射. 其属性如下：</p>
<h4 id="属性-2"><a href="#属性-2" class="headerlink" title="属性"></a>属性</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">from="original-name"</span><br><span class="line"><span class="comment">&lt;!-- 指定节点原来要监听的话题的名称.  --&gt;</span></span><br><span class="line"></span><br><span class="line">to="new-name"</span><br><span class="line"><span class="comment">&lt;!-- 指定节点实际要监听的话题的名称.  --&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">remap</span> <span class="attr">from</span>=<span class="string">"chatter"</span> <span class="attr">to</span>=<span class="string">"hello"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 此行代码表明要将原来应监听chatter话题的节点改到监听hello话题.  --&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="lt-machine-gt"><a href="#lt-machine-gt" class="headerlink" title="&lt;machine&gt;"></a><code>&lt;machine&gt;</code></h3><p><code>&lt;machine&gt;</code>标签声明一台可以运行<code>ROS</code>节点的机器。如果在本地启动所有节点，则不需要此标签。它主要用于声明远程机器的<code>SSH</code>和<code>ROS</code>环境变量设置，不过您也可以使用它来声明关于本地机器的信息。</p>
<h4 id="属性-3"><a href="#属性-3" class="headerlink" title="属性"></a>属性</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">name="machine-name"</span><br><span class="line"><span class="comment">&lt;!-- 要分配给机器的名称。这对应于&lt;node&gt;标记的machine属性的名称。 --&gt;</span></span><br><span class="line"></span><br><span class="line">address="blah.willowgarage.com"</span><br><span class="line"><span class="comment">&lt;!-- 机器的远程地址或主机名 --&gt;</span></span><br><span class="line"></span><br><span class="line">env-loader="/opt/ros/fuerte/env.sh"</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- New in Fuerte. 指定远程计算机上的环境文件。环境文件必须是一个设置了所有需要环境变量的shell脚本，并提供参数执行exec --&gt;</span></span><br><span class="line"></span><br><span class="line">default="true|false|never" (optional)</span><br><span class="line"><span class="comment">&lt;!-- 将此机器设置为节点的默认分配机器。默认设置只适用于后续在同一范围内定义的节点。注意:如果没有默认机器，则使用本地机器。可以通过设置default="never"来阻止机器被选中，在这种情况下，只能显式地分配机器。 --&gt;</span></span><br><span class="line"></span><br><span class="line">user="username" (optional)</span><br><span class="line"><span class="comment">&lt;!-- 登录机器的ssh用户名, 如果不需要可以忽略 --&gt;</span></span><br><span class="line"></span><br><span class="line">password="passwhat"(strongly discouraged)</span><br><span class="line"><span class="comment">&lt;!-- ssh登录密码。强烈建议您配置SSH密钥和SSH代理，这样您就可以使用证书登录了 --&gt;</span></span><br><span class="line"></span><br><span class="line">timeout="10.0" (optional)</span><br><span class="line"><span class="comment">&lt;!-- 登录超时检测时间，默认设置为10秒。虽然您可以使用此设置来允许较慢的连接，但需要更改此参数通常是您的整个ROS图将出现通信问题的症状（While you can use this setting to allow for slower connections, needing to change this parameter is generally a symptom that your overall ROS graph will have communication issues.） --&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="例子-3"><a href="#例子-3" class="headerlink" title="例子"></a>例子</h4><p>下面的示例显示如何配置节点“footalker”来运行另一台机器。它使用 Fuerte 附带的默认的 env-loader 文件。注：<strong><code>Basic (ROS Fuerte and later) using env-loader</code></strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">machine</span> <span class="attr">name</span>=<span class="string">"foo"</span> <span class="attr">address</span>=<span class="string">"foo-address"</span> <span class="attr">env-loader</span>=<span class="string">"/opt/ros/fuerte/env.sh"</span> <span class="attr">user</span>=<span class="string">"someone"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">machine</span>=<span class="string">"foo"</span> <span class="attr">name</span>=<span class="string">"footalker"</span> <span class="attr">pkg</span>=<span class="string">"test_ros"</span> <span class="attr">type</span>=<span class="string">"talker.py"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>下面是一个 ev -loader 脚本示例。如果你想使用不同的环境配置, 将/opt/ros/fuerte/setup.sh 替换为另外的安装文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line">./opt/ros/fuerte/setup.sh</span><br><span class="line"><span class="built_in">exec</span> <span class="string">"<span class="variable">$@</span>"</span></span><br></pre></td></tr></table></figure>
<p>此外，如果要从<code>rosws</code>工作空间中加载源：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> /home/username/path/to/workspace/setup.bash</span><br><span class="line"><span class="built_in">exec</span> <span class="string">"<span class="variable">$@</span>"</span></span><br></pre></td></tr></table></figure>
<h3 id="lt-include-gt"><a href="#lt-include-gt" class="headerlink" title="&lt;include&gt;"></a><code>&lt;include&gt;</code></h3><p><code>&lt;include&gt;</code>标记允许您将另一个<code>roslaunch XML</code>文件导入当前文件。它将被导入到当前的文档范围，包括<code>&lt;group&gt;</code>和<code>&lt;remap&gt;</code>标签。除了<code>&lt;master&gt;</code>标记外，<code>include</code>文件中的所有内容都将被导入。<code>&lt;master&gt;</code>标签仅在顶级文件中被遵守。</p>
<h4 id="属性-4"><a href="#属性-4" class="headerlink" title="属性"></a>属性</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">file="$(find pkg-name)/path/filename.xml"</span><br><span class="line"><span class="comment">&lt;!-- 指定要包含的文件路径.  --&gt;</span></span><br><span class="line"></span><br><span class="line">ns="namespace_name" (optional)</span><br><span class="line"><span class="comment">&lt;!-- 指定要导入文件的命名空间.  --&gt;</span></span><br><span class="line"></span><br><span class="line">clear_params="true|false" (optional Default: false)</span><br><span class="line"><span class="comment">&lt;!-- 在文件加载之前删除&lt;include&gt;的命名空间中的所有参数, 缺省为false, 此参数要谨慎使用, 用之前要核对好命名空间名称.  --&gt;</span></span><br><span class="line"></span><br><span class="line">pass_all_args="true|false" (optional Default: false)</span><br><span class="line"><span class="comment">&lt;!-- 如果为true，所有当前上下文的args将被加入到在处理&lt;include&gt;文件时创建的子上下文中.  --&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="元素-1"><a href="#元素-1" class="headerlink" title="元素"></a>元素</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">include</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">env</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="lt-env-gt"><a href="#lt-env-gt" class="headerlink" title="&lt;env&gt;"></a><code>&lt;env&gt;</code></h3><p>此标签用来设置将要启动的节点的环境变量, 其可以在<code>&lt;launch&gt;</code>, <code>&lt;include&gt;</code>, <code>&lt;node&gt;</code>和<code>&lt;machine&gt;</code>标签中使用. 当在<code>&lt;launch&gt;</code>中使用时, <code>&lt;env&gt;</code>标签作用于其后声明的所有节点. 但是用此标签声明的环境变量对于<code>$(env …)</code>不可见, 所以并不能用<code>$(env …)</code>对其它变量的值进行置换, 所以<code>&lt;env&gt;</code>标签不能用来参数化 launch 文件.</p>
<h4 id="属性-5"><a href="#属性-5" class="headerlink" title="属性"></a>属性</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">name="environment-variable-name"</span><br><span class="line"><span class="comment">&lt;!-- 此属性用来设置环境变量名称.  --&gt;</span></span><br><span class="line"></span><br><span class="line">value="environment-variable-value"</span><br><span class="line"><span class="comment">&lt;!-- 此属性用来设置环境变量值.  --&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="lt-test-gt"><a href="#lt-test-gt" class="headerlink" title="&lt;test&gt;"></a><code>&lt;test&gt;</code></h3><p><code>&lt;test&gt;</code>标签在语法上类似于<code>&lt;node&gt;</code>标签, 都是指定一个<code>ROS</code>节点运行, 但是<code>&lt;test&gt;</code>标签表明当前要运行的节点是一个测试节点.</p>
<p><code>&lt;test&gt;</code>与<code>&lt;node&gt;</code>具有大部分相同的属性, 但以下内容是不同的：</p>
<ul>
<li>没有 respawn 属性 (测试节点必须要被终止, 所以它们没有重启属性)</li>
<li>没有输出属性, 因为测试节点有其输出记录机制.</li>
<li>Machine 属性被忽略.</li>
</ul>
<h4 id="属性-6"><a href="#属性-6" class="headerlink" title="属性"></a>属性</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">pkg="mypackage"</span><br><span class="line"><span class="comment">&lt;!-- 这一属性是必需的属性, 指定节点的包名称.  --&gt;</span></span><br><span class="line"></span><br><span class="line">test-name="test_name"</span><br><span class="line"><span class="comment">&lt;!-- 必须的属性, 指定测试节点的名称.  --&gt;</span></span><br><span class="line"></span><br><span class="line">type="nodetype"</span><br><span class="line"><span class="comment">&lt;!-- 必须的属性, 指定测试节点所对应的可执行程序名称.  --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 标签可选择的属性如下： --&gt;</span></span><br><span class="line">name="nodename"</span><br><span class="line"><span class="comment">&lt;!-- 节点名称. PS:名称中不能包含命名空间, 如果要指定要使用ns属性, 如果此属性未指定, 则test-name将被作为节点名称.  --&gt;</span></span><br><span class="line"></span><br><span class="line">args="arg1 arg2 arg3"</span><br><span class="line"><span class="comment">&lt;!-- 用测试节点传递参数.  --&gt;</span></span><br><span class="line"></span><br><span class="line">clear_params="true|false"</span><br><span class="line"><span class="comment">&lt;!-- 如果是true, 则在启动之前清空当前节点私有命名空间中的全部参数.  --&gt;</span></span><br><span class="line"></span><br><span class="line">cwd="ROS_HOME|node"</span><br><span class="line"><span class="comment">&lt;!-- 指定工作路径. 如果是node则节点的工作目录与节点的可执行程序目录相同.  --&gt;</span></span><br><span class="line"></span><br><span class="line">launch-prefix="prefix arguments"</span><br><span class="line"><span class="comment">&lt;!-- 节点启动之前的预置参数或命令.  --&gt;</span></span><br><span class="line"></span><br><span class="line">ns="namespace_name"</span><br><span class="line"><span class="comment">&lt;!-- 在指定的命名空间中启动节点.  --&gt;</span></span><br><span class="line"></span><br><span class="line">retry="0"</span><br><span class="line"><span class="comment">&lt;!-- 用于有时可能失效的随机过程, 设置重新尝试的次数.  --&gt;</span></span><br><span class="line"></span><br><span class="line">time-limit="60. 0"</span><br><span class="line"><span class="comment">&lt;!-- 认定节点启动失败之前要经历的时间, 缺省为60s.  --&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="例子-4"><a href="#例子-4" class="headerlink" title="例子"></a>例子</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">test</span> <span class="attr">test-name</span>=<span class="string">"test"</span> <span class="attr">pkg</span>=<span class="string">"mypkg"</span> <span class="attr">type</span>=<span class="string">"test. py"</span> <span class="attr">time-limit</span>=<span class="string">"10. 0"</span> <span class="attr">args</span>=<span class="string">"--test1 --test2"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 上行代码指定要测试的节点的名称, 包名称, 可执行程序名称, 测试时间跨度和要传递的参数 --&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="元素-2"><a href="#元素-2" class="headerlink" title="元素"></a>元素</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">test</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">env</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">remap</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rosparam</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">test</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="lt-arg-gt"><a href="#lt-arg-gt" class="headerlink" title="&lt;arg&gt;"></a><code>&lt;arg&gt;</code></h3><p><code>&lt;arg&gt;</code>标签允许通过命令行、<code>&lt;include&gt;</code>标签或者更上层的文件传递指定的值，用来创建可以重用或者可配置的的<code>launch</code>文件. 但<code>&lt;arg&gt;</code>标签是非全局的, 一个声明只针对一个<code>launch</code>文件, 如同局部变量一样。如果要在一个包含文件<code>include file</code>中使用, 则必须要显式的值传递.</p>
<p><code>&lt;arg&gt;</code>可以通过以下三种方式使用:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">"foo"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 声明了一个foo变量。foo必须通过命令行传递或通过&lt;include&gt;标签进行传递.  --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">"foo"</span> <span class="attr">default</span>=<span class="string">"1"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 声明变量foo, 并赋予一个缺省值1. foo可以通过命令行覆写或&lt;include&gt;标签进行值传递使用.  --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">"foo"</span> <span class="attr">value</span>=<span class="string">"bar"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 声明了一个值为bar的常量foo。foo的值不能被覆写。此用法支持启动文件的内部参数化，而无需在更高级别暴露该参数。 --&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="属性-7"><a href="#属性-7" class="headerlink" title="属性"></a>属性</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">name="arg_name"</span><br><span class="line"><span class="comment">&lt;!-- 指定变量名.  --&gt;</span></span><br><span class="line"></span><br><span class="line">default="default value" (optional)</span><br><span class="line"><span class="comment">&lt;!-- 指定变量缺省值, 不能与value属性一起使用.  --&gt;</span></span><br><span class="line"></span><br><span class="line">value="value" (optional)</span><br><span class="line"><span class="comment">&lt;!-- 指定变量值, 不能与default属性一起使用.  --&gt;</span></span><br><span class="line"></span><br><span class="line">doc="description for this arg" (optional) New in Indigo</span><br><span class="line"><span class="comment">&lt;!-- 变量描述.  --&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="例子-5"><a href="#例子-5" class="headerlink" title="例子"></a>例子</h4><ul>
<li>传递一个参数到包含文件中</li>
</ul>
<p><code>my_file.launch</code>:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">include</span> <span class="attr">file</span>=<span class="string">"included.launch"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- all vars that included.launch requires must be set --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">"hoge"</span> <span class="attr">value</span>=<span class="string">"fuga"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>included.launch</code>:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- declare arg to be passed in --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">"hoge"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- read value of arg --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"param"</span> <span class="attr">value</span>=<span class="string">"$(arg hoge)"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>则当运行<code>my_file.launch</code>文件时, <code>hoge</code>参数会从<code>my_file.launch</code>的<code>&lt;include&gt;</code>标签中传递进入<code>included.launch</code>文件中, 产生一个变量名为<code>param</code>, 值为<code>fuga</code>的变量. 但是由于<code>&lt;arg&gt;</code>定义的为一个文件内部的局部变量(类似于类内的私有变量), 无法从更高一级或外部进行访问, 即不能通过命令行进行赋值, 所以, 当运行：</p>
<blockquote>
<p><code>roslaunch %YOUR_ROS_PKG% my_file.launch hoge:=my_value</code></p>
</blockquote>
<p>时, <code>hoge</code>的值还是原来设定的<code>fuga</code>值, 而不管你在局部的<code>&lt;arg&gt;</code>属性中是用<code>value</code>属性还是<code>default</code>属性. 如果想用自己的定义值在命令行中进行覆盖, 则<code>&lt;arg&gt;</code>标签要使用更高一层级的<code>default</code>属性指定<code>my_file.launch</code>如下所示：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 即定义一个更高一层次的&lt;arg&gt;标签来执行值传递, 从更高一层级传递到局部再传递到included.launch文件中.  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">"temp"</span>  <span class="attr">default</span>=<span class="string">"fuga"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">file</span>=<span class="string">"$(find your_pkg)/launch/included.launch"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">"param"</span> <span class="attr">value</span>=<span class="string">"$(arg temp)"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>通过命令行传递变量<br><code>roslaunch</code>使用与<code>ROS</code>映射参数相同的语法来指定<code>arg</code>值</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ roslaunch my_file.launch hoge:=my_value  (.launch file is available at the current dir)</span><br><span class="line"></span><br><span class="line">$ roslaunch %YOUR_ROS_PKG% my_file.launch hoge:=my_value</span><br></pre></td></tr></table></figure>
<h3 id="lt-group-gt"><a href="#lt-group-gt" class="headerlink" title="&lt;group&gt;"></a><code>&lt;group&gt;</code></h3><p>可以对一组节点进行设置, 并且可以通过 ns 属性将一组节点放到一个隔离开的命名空间中.</p>
<h4 id="属性-8"><a href="#属性-8" class="headerlink" title="属性"></a>属性</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">ns="namespace" (optional)</span><br><span class="line"><span class="comment">&lt;!-- 将一组节点指定到一个特定的命名空间中, 命名空间可以是全局的或是局部的, 但并有推荐使用全局的命名空间.  --&gt;</span></span><br><span class="line"></span><br><span class="line">clear_params="true|false" (optional)</span><br><span class="line">在节点启动之前清空<span class="tag">&lt;<span class="name">group</span>&gt;</span>命名空间中的所有参数, 谨慎使用.</span><br><span class="line"><span class="comment">&lt;!-- 内部可使用的标签如下所示： --&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="元素-3"><a href="#元素-3" class="headerlink" title="元素"></a>元素</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">group</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">remap</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">machine</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rosparam</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">env</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">test</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">group</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="launch-文件的例子"><a href="#launch-文件的例子" class="headerlink" title="launch 文件的例子"></a>launch 文件的例子</h2><h3 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">"talker"</span> <span class="attr">pkg</span>=<span class="string">"rospy_tutorials"</span> <span class="attr">type</span>=<span class="string">"talker"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 在本地使用当前ros环境启动rospy_tutorials包中的可执行程序为talker的节点, 节点名称定义为talker.  --&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="一个复杂一点的例子"><a href="#一个复杂一点的例子" class="headerlink" title="一个复杂一点的例子"></a>一个复杂一点的例子</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">machine</span> <span class="attr">name</span>=<span class="string">"local_alt"</span> <span class="attr">address</span>=<span class="string">"localhost"</span> <span class="attr">default</span>=<span class="string">"true"</span> <span class="attr">ros-root</span>=<span class="string">"/u/user/ros/ros/"</span> <span class="attr">ros-package-path</span>=<span class="string">"/u/user/ros/ros-pkg"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 本地的机器已经进行了缺省定义, 这个标签的作用是用指定的ROS_ROOT和ROS_PACKAGE_PATH值对其重新赋值--&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">"listener-1"</span> <span class="attr">pkg</span>=<span class="string">"rospy_tutorials"</span> <span class="attr">type</span>=<span class="string">"listener"</span> /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 启动一个收听节点 --&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">"listener-2"</span> <span class="attr">pkg</span>=<span class="string">"rospy_tutorials"</span> <span class="attr">type</span>=<span class="string">"listener"</span> <span class="attr">args</span>=<span class="string">"-foo arg2"</span> /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 向监听节点中传递参数 --&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">"listener-3"</span> <span class="attr">pkg</span>=<span class="string">"rospy_tutorials"</span> <span class="attr">type</span>=<span class="string">"listener"</span> <span class="attr">respawn</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 一个可以重新启动的节点 --&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">ns</span>=<span class="string">"wg1"</span> <span class="attr">name</span>=<span class="string">"listener-wg1"</span> <span class="attr">pkg</span>=<span class="string">"rospy_tutorials"</span> <span class="attr">type</span>=<span class="string">"listener"</span> <span class="attr">respawn</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 在 'wg1' 命名空间中启动一个节点 --&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">group</span> <span class="attr">ns</span>=<span class="string">"wg2"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 在 'wg2' 命名空间中启动一组节点 --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">remap</span> <span class="attr">from</span>=<span class="string">"chatter"</span> <span class="attr">to</span>=<span class="string">"hello"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- remap在group范围内作用于在其后声明的所有节点 --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">"rospy_tutorials"</span> <span class="attr">type</span>=<span class="string">"listener"</span> <span class="attr">name</span>=<span class="string">"listener"</span> <span class="attr">args</span>=<span class="string">"--test"</span> <span class="attr">respawn</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">"rospy_tutorials"</span> <span class="attr">type</span>=<span class="string">"talker"</span> <span class="attr">name</span>=<span class="string">"talker"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"talker_1_param"</span> <span class="attr">value</span>=<span class="string">"a value"</span> /&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 设置局部变量 --&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">remap</span> <span class="attr">from</span>=<span class="string">"chatter"</span> <span class="attr">to</span>=<span class="string">"hello-1"</span>/&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 节点可以有其自己私有的remap指令 --&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">env</span> <span class="attr">name</span>=<span class="string">"ENV_EXAMPLE"</span> <span class="attr">value</span>=<span class="string">"some value"</span> /&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 为节点设置环境变量 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">node</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">group</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="设置参数"><a href="#设置参数" class="headerlink" title="设置参数"></a>设置参数</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"somestring1"</span> <span class="attr">value</span>=<span class="string">"bar"</span> /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 值类型为string类型 --&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"somestring2"</span> <span class="attr">value</span>=<span class="string">"10"</span> <span class="attr">type</span>=<span class="string">"str"</span> /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 强制使用string类型而不是整型定义参数 --&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"someinteger1"</span> <span class="attr">value</span>=<span class="string">"1"</span> <span class="attr">type</span>=<span class="string">"int"</span> /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 指定为整型 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"someinteger2"</span> <span class="attr">value</span>=<span class="string">"2"</span> /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 自动识别为整型 --&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"somefloat1"</span> <span class="attr">value</span>=<span class="string">"3. 14159"</span> <span class="attr">type</span>=<span class="string">"double"</span> /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 指定为浮点型数据 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"somefloat2"</span> <span class="attr">value</span>=<span class="string">"3. 0"</span> /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 自动识别为浮点型数据 --&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"wg/childparam"</span> <span class="attr">value</span>=<span class="string">"a child namespace parameter"</span> /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 在子命名空间中设置参数 --&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"configfile"</span> <span class="attr">textfile</span>=<span class="string">"$(find roslaunch)/example. xml"</span> /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 向参数服务器中加载文本文件内容 --&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"binaryfile"</span> <span class="attr">binfile</span>=<span class="string">"$(find roslaunch)/example. xml"</span> /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 向参数服务器中加载二进制文件内容 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure>
<hr>
<p>参考链接：</p>
<ul>
<li><a href="http://wiki.ros.org/roslaunch/XML" target="_blank" rel="noopener">http://wiki.ros.org/roslaunch/XML</a></li>
<li><a href="https://blog.csdn.net/u012424737/article/details/78854536" target="_blank" rel="noopener">https://blog.csdn.net/u012424737/article/details/78854536</a></li>
<li><a href="https://blog.csdn.net/weixin_41995979/article/details/81784987" target="_blank" rel="noopener">https://blog.csdn.net/weixin_41995979/article/details/81784987</a></li>
</ul>
]]></content>
      <categories>
        <category>ROS学习</category>
      </categories>
      <tags>
        <tag>ROS</tag>
        <tag>roslaunch</tag>
      </tags>
  </entry>
  <entry>
    <title>ROS学习-controller_manager</title>
    <url>/posts/1366633795/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><code>controller_manager</code>提供硬实时兼容的环来控制的机械手,由一个<code>hardware_interface::RobotHW</code>实例代表(参见<code>hardware_interface</code>包).该<code>controller_manager</code>提供了加载,卸载,启动和停止控制器的基本结构.</p>
<a id="more"></a>
<p>当加载一个控制器时,<code>controller_manager</code>将使用控制器名作为所有控制器特定参数的<code>root</code>,最重要的是,<code>type</code>用于标识要加载哪个插件.</p>
<h2 id="控制器运行的工具-Tools-for-running-controllers"><a href="#控制器运行的工具-Tools-for-running-controllers" class="headerlink" title="控制器运行的工具(Tools for running controllers)"></a>控制器运行的工具(<code>Tools for running controllers</code>)</h2><p>控制器管理器提供的与控制器进行交互的基本结构.根据控制器从启动文件,命令行,或者<code>ROS</code>节点运行,控制管理器提供不同的工具来运行控制器.</p>
<p><a href="http://wiki.ros.org/controller_manager?action=AttachFile&amp;do=get&amp;target=controller+state.png">controller_manager</a></p>
<h2 id="命令行工具-Command-line-tools"><a href="#命令行工具-Command-line-tools" class="headerlink" title="命令行工具(Command-line tools)"></a>命令行工具(<code>Command-line tools</code>)</h2><h3 id="控制管理器-controller-manager"><a href="#控制管理器-controller-manager" class="headerlink" title="控制管理器(controller_manager)"></a>控制管理器(<code>controller_manager</code>)</h3><p>使用<code>controller_manager</code>工具与从命令行运行的控制器交互.要与特定的控制器进行交互,可以使用:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ rosrun controller_manager controller_manager &lt;<span class="built_in">command</span>&gt; &lt;controller_name&gt;</span><br></pre></td></tr></table></figure>
<p>以下命令可用:<br>| | |<br>| :—————— | :—————————————————— |<br>| <strong><code>load</code></strong>: | 加载控制器 (construct and initialize) |<br>| <strong><code>unload</code></strong>: | 卸载控制器 (destruct) |<br>| <strong><code>start</code></strong>: | 启动控制器 |<br>| <strong><code>stop</code></strong>: | 结束控制器 |<br>| <strong><code>spawn</code></strong>: | 加载并启动控制器 |<br>| <strong><code>kill</code></strong>: | 停止并卸载控制器 |</p>
<p>想获得控制器状态, 用:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ rosrun controller_manager controller_manager &lt;<span class="built_in">command</span>&gt;</span><br></pre></td></tr></table></figure>
<p>以下命令可用:<br>| | |<br>| :———————————————— | :—————————————————————————————————————————————————————— |<br>| <strong><code>list</code></strong>: | 根据执行顺序,列出所有控制器,并给出每个控制器的状态 |<br>| <strong><code>list-types</code></strong>: | 列出所有控制器管理知道的控制器类型.如果控制器不在此列表中,将无法加载并启动. |<br>| <strong><code>list-joints</code></strong>: | 列出所有控制器管理使用的的关节和驱动器的名称. |<br>| <strong><code>reload-libraries</code></strong>: | 重新加载所有可作为插件的控制器库.当我们正在开发控制器时,可以方便的测试控制器代码,而 不用每次都重新启动机器人. |<br>| <strong><code>reload-libraries --restore</code></strong>: | 重新加载所有可作为插件的的控制器库,并把所有控制器恢复到初始状态. |<br>| | |</p>
<h3 id="加载并启动控制器-spawner"><a href="#加载并启动控制器-spawner" class="headerlink" title="加载并启动控制器(spawner)"></a>加载并启动控制器(<code>spawner</code>)</h3><p>为了立刻自动加载并启动一系列控制器以及立刻停止并卸载这些控制器,使用<code>spawner</code>工具:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ rosrun controller_manager spawner [--stopped] name1 name2 name3</span><br></pre></td></tr></table></figure>
<p>当运行<code>spawner</code>时,列表中控制器将被载入和启动(除非指定<code>--stopped</code>). 当控制器已开启(<code>controllers are up</code>),<code>spawner</code>将保持运行.当你杀死<code>spawner</code>进程(<code>CTRL-C</code>),会自动停止并卸载所有它最开始启动的控制器.</p>
<h3 id="卸载控制器-unspawner"><a href="#卸载控制器-unspawner" class="headerlink" title="卸载控制器(unspawner)"></a>卸载控制器(<code>unspawner</code>)</h3><p>想要自动停止一组控制器,然后重新启动,可使用<code>unspawner</code>工具:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ rosrun controller_manager unspawner name1 name2 name3</span><br></pre></td></tr></table></figure>
<p>列表中的控制器将被停止,但没有卸载.一旦<code>spawner</code>关闭,该控制器将重新启动.</p>
<h3 id="控制器组-controller-group"><a href="#控制器组-controller-group" class="headerlink" title="控制器组(controller_group)"></a>控制器组(<code>controller_group</code>)</h3><p><code>controller_group</code>允许开发者在运行时切换控制器,但是出于一些特殊意图,当你想从一组控制器切换到另一组时,这就不是很方便.<code>controller_group</code>脚本对于那些在<code>ROS parameter controller_groups</code>已经定义的分组的切换就很容易实现.它知道所有包含的控制器,当它切换控制器组时,控制器需要被停止或者被启动.所以,不同的控制器组可以共享某些控制器.</p>
<p><code>controller_groups</code>的一个例子:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">controller_groups:</span></span><br><span class="line">  <span class="attr">production:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">prod_controller_1</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">prod_controller_2</span></span><br><span class="line">  <span class="attr">development:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">devel_controller_1</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">devel_controller_2</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">shared_controller_3</span></span><br><span class="line">  <span class="attr">diagnostics:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">diag_controller_1</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">diag_controller_2</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">shared_controller_3</span></span><br></pre></td></tr></table></figure>
<p>启动<code>controller_groups</code>的脚本:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ rosrun controller_manager controller_group &lt;<span class="built_in">command</span>&gt; &lt;args&gt;</span><br></pre></td></tr></table></figure>
<p>以下命令可用:<br>| | |<br>| :—————————— | :———————————————————————————————————————————————————————————- |<br>| <strong><code>list</code></strong>: | 列出所有能在<code>controler_groups</code>参数中找到的组定义 |<br>| <strong><code>spawn &lt;group&gt;</code></strong>: | 载入和启动所有包含在名称为<code>&lt;group&gt;</code>组内的所有控制器,通常在<code>ROS launch</code>文件中使用 |<br>| <strong><code>switch &lt;group&gt;</code></strong>: | 切换到<code>&lt;group&gt;</code>组.这意味着将停止其他组内正在运行的控制器,但是定在在本组内的不会被停止,然后启动在本组内的未运行的控制器器 |<br>| | |</p>
<h2 id="创建启动文件-Creating-launch-files"><a href="#创建启动文件-Creating-launch-files" class="headerlink" title="创建启动文件(Creating launch files)"></a>创建启动文件(<code>Creating launch files</code>)</h2><p>我们可以运行<code>controller_manager</code>,从启动文件(<code>launch file</code>)内启动控制器.然而,即使启动文件被撤下,控制器仍会保持.而<code>spawner</code>工具会从启动文件中自动加载,启动,停止和卸载控制器.当启动<code>spawner</code>工具时,它会加载并启动控制器.当你停止<code>spawner</code>(当启动文件被撤下),它将停止并卸载控制器.启动文件可能如下:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">"controller_manager"</span> <span class="attr">type</span>=<span class="string">"spawner"</span> <span class="attr">args</span>=<span class="string">"controller_name1 controller_name2"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>或者,只是想加载控制器,但是还没有启动:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">"controller_manager"</span> <span class="attr">type</span>=<span class="string">"spawner"</span> <span class="attr">args</span>=<span class="string">"--stopped controller_name1 controller_name2"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="图形工具-Graphical-tools"><a href="#图形工具-Graphical-tools" class="headerlink" title="图形工具(Graphical tools)"></a>图形工具(Graphical tools)</h2><p><code>rqt_controller_manager</code>是一个<code>rqt</code>插件,该插件以图形化方式加载,卸载,启动和停止控制器;同时用来显示加载的控制器的信息.</p>
<p>它可以从<code>rqt</code>的<code>Plugin</code>菜单中启动,或者通过命令行单独执行:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rosrun rqt_controller_manager rqt_controller_manager</span><br></pre></td></tr></table></figure>
<h2 id="ROS应用程序接口-ROS-API"><a href="#ROS应用程序接口-ROS-API" class="headerlink" title="ROS应用程序接口(ROS API)"></a><code>ROS</code>应用程序接口(<code>ROS API</code>)</h2><p>为了与另一个<code>ROS</code>节点的控制器交互,控制管理器提供了五种服务调用:</p>
<h2 id="控制管理器-controller-manager-1"><a href="#控制管理器-controller-manager-1" class="headerlink" title="控制管理器 (controller_manager)"></a>控制管理器 (<code>controller_manager</code>)</h2><h3 id="服务-Services"><a href="#服务-Services" class="headerlink" title="服务(Services)"></a>服务(Services)</h3><p><code>controller_manager/load_controller (controller_manager_msgs/LoadController)</code></p>
<blockquote>
<p>服务请求包含了要加载的控制器的名字,响应包含了一个表示成功或失败的布尔值.</p>
</blockquote>
<p><code>controller_manager/unload_controller (controller_manager_msgs/UnloadController)</code></p>
<blockquote>
<p>服务请求中包含要卸载的控制器的名称,响应包含了一个表示成功或失败的布尔值.控制器只能在当其处于停止状态的时候被卸载.</p>
</blockquote>
<p><code>controller_manager/switch_controller (controller_manager_msgs/SwitchController)</code></p>
<blockquote>
<p>服务请求包含了要开始的控制器的名称列表,要停止的控制器名称列表和一个表明规范性 (<code>strictness: BEST_EFFORT or STRICT</code>)的整型值(<code>int</code>).<code>STRICT</code>表示如果出现任何错误(无效的控制器名称,控制器启动失败,<code>etc</code>),控制器的切换(<code>switching</code>)将会失败并导致空操作(<code>no-op</code>).<code>BEST_EFFORT</code>表示,即使控制器出现了一些问题,该服务仍然会尝试启动/停止余下的控制器.服务响应包含了一个表示成功或失败的布尔值.如果只是停止或者只是启动控制器,控制器启动或停止的列表可能为空.</p>
</blockquote>
<p><code>controller_manager/list_controllers (controller_manager_msgs/ListControllers)</code></p>
<blockquote>
<p>该服务返回所有当前加载的控制器.响应包括以下信息:控制器的名称,状态(运行或停止),类型,硬件接口,和占用的资源.</p>
</blockquote>
<p><code>controller_manager/list_controller_types (controller_manager_msgs/ListControllerTypes)</code></p>
<blockquote>
<p>该服务返回<code>controller_manager</code>已知的所有控制器类型.只有已知的控制器类型可以构建.</p>
</blockquote>
<p><code>controller_manager/reload_controller_libraries (controller_manager_msgs/ReloadControllerLibraries)</code></p>
<blockquote>
<p>服务重新加载所有可作为插件的控制器库.当我们正在开发控制器时,无需每次重新启动机器人 就可以方便的测试控制器代码.此服务只在控制器没有加载情况下工作.</p>
</blockquote>
<p>Translated by Ms Wang 2014-8-19</p>
<p>Wiki: controller_manager (last edited 2014-03-10 15:22:46 by AdolfoRodriguez)</p>
<hr>
<p>参考来源:</p>
<ul>
<li><a href="http://wiki.ros.org/cn/controller_manager" target="_blank" rel="noopener">http://wiki.ros.org/cn/controller_manager</a></li>
<li><a href="http://wiki.ros.org/controller_manager?distro=kenetic" target="_blank" rel="noopener">http://wiki.ros.org/controller_manager?distro=kenetic</a></li>
</ul>
]]></content>
      <categories>
        <category>ROS学习</category>
      </categories>
      <tags>
        <tag>ROS</tag>
        <tag>controller_manager</tag>
      </tags>
  </entry>
  <entry>
    <title>ROS学习-ur5机器人的gazebo仿真以及controller的使用</title>
    <url>/posts/1500545740/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>这篇文章主要介绍了如何在<code>gazebo</code>中对<code>ur5</code>进行仿真和<code>controller</code>的使用，包括<code>controller_manager</code>的使用和控制器<code>command</code>的主题数据发布。</p>
<a id="more"></a>
<ul>
<li><p>ur 机器人的下载编译可以参考官方的帮助文档，下载源码，然后<code>catkin_make</code>，然后<code>source devel/setup.bash</code>载入资源文件。</p>
</li>
<li><p>在<code>gazebo</code>中启动 <code>ur5</code> 模型，终端输入：</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">roslaunch ur_gazebo ur5.launch limited:=<span class="literal">true</span></span><br></pre></td></tr></table></figure>
<ul>
<li>ur5 模型的参数服务器中包含两个控制器, <code>position_controllers/JointTrajectoryController</code>和<code>position_controllers/JointGroupPositionController</code>这里先用位置控制模式<code>JointGroupPositionController</code>，就是单独控制关节轴，这样我们可以直观看到关节轴响应了下发的位置指令。</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">arm_controller:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">position_controllers/JointTrajectoryController</span></span><br><span class="line">  <span class="attr">joints:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">shoulder_pan_joint</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">shoulder_lift_joint</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">elbow_joint</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">wrist_1_joint</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">wrist_2_joint</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">wrist_3_joint</span></span><br><span class="line">  <span class="attr">constraints:</span></span><br><span class="line">    <span class="attr">goal_time:</span> <span class="number">0.6</span></span><br><span class="line">    <span class="attr">stopped_velocity_tolerance:</span> <span class="number">0.05</span></span><br><span class="line">    <span class="attr">shoulder_pan_joint:</span> <span class="string">&#123;</span> <span class="attr">trajectory:</span> <span class="number">0.1</span><span class="string">,</span> <span class="attr">goal:</span> <span class="number">0.1</span> <span class="string">&#125;</span></span><br><span class="line">    <span class="attr">shoulder_lift_joint:</span> <span class="string">&#123;</span> <span class="attr">trajectory:</span> <span class="number">0.1</span><span class="string">,</span> <span class="attr">goal:</span> <span class="number">0.1</span> <span class="string">&#125;</span></span><br><span class="line">    <span class="attr">elbow_joint:</span> <span class="string">&#123;</span> <span class="attr">trajectory:</span> <span class="number">0.1</span><span class="string">,</span> <span class="attr">goal:</span> <span class="number">0.1</span> <span class="string">&#125;</span></span><br><span class="line">    <span class="attr">wrist_1_joint:</span> <span class="string">&#123;</span> <span class="attr">trajectory:</span> <span class="number">0.1</span><span class="string">,</span> <span class="attr">goal:</span> <span class="number">0.1</span> <span class="string">&#125;</span></span><br><span class="line">    <span class="attr">wrist_2_joint:</span> <span class="string">&#123;</span> <span class="attr">trajectory:</span> <span class="number">0.1</span><span class="string">,</span> <span class="attr">goal:</span> <span class="number">0.1</span> <span class="string">&#125;</span></span><br><span class="line">    <span class="attr">wrist_3_joint:</span> <span class="string">&#123;</span> <span class="attr">trajectory:</span> <span class="number">0.1</span><span class="string">,</span> <span class="attr">goal:</span> <span class="number">0.1</span> <span class="string">&#125;</span></span><br><span class="line">  <span class="attr">stop_trajectory_duration:</span> <span class="number">0.5</span></span><br><span class="line">  <span class="attr">state_publish_rate:</span> <span class="number">25</span></span><br><span class="line">  <span class="attr">action_monitor_rate:</span> <span class="number">10</span></span><br><span class="line"><span class="attr">joint_group_position_controller:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">position_controllers/JointGroupPositionController</span></span><br><span class="line">  <span class="attr">joints:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">shoulder_pan_joint</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">shoulder_lift_joint</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">elbow_joint</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">wrist_1_joint</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">wrist_2_joint</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">wrist_3_joint</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>ur5 的<code>launch</code>文件中，默认启动的控制器是关节轨迹控制，所以这里涉及到如何切换控制器的操作，详细内容可以参考<code>controller_manager</code>这篇文章。一下给出实际的操作。</p>
</li>
<li><p>首先查看已载入的控制器：可以看到 ur 内部载入了两个控制器，就是在参数文件中显示的两个，<code>arm_controller</code>和<code>joint_group_position_controller</code>。</p>
</li>
</ul>
<blockquote>
<p><code>rosrun controller_manager controller_manager list</code></p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">arm_controller - hardware_interface::PositionJointInterface ( stopped )</span><br><span class="line">joint_state_controller - hardware_interface::JointStateInterface ( running )</span><br><span class="line">joint_group_position_controller - hardware_interface::PositionJointInterface ( running )</span><br></pre></td></tr></table></figure>
<ul>
<li>暂停<code>arm_controller</code>，执行成功后会显示成功执行信息：</li>
</ul>
<blockquote>
<p><code>rosrun controller_manager controller_manager stop arm_controller</code></p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Stopped [<span class="string">'arm_controller'</span>] successfully</span><br></pre></td></tr></table></figure>
<ul>
<li>启动<code>joint_group_position_controller</code>，同样也有执行成功与否的信息输出：</li>
</ul>
<blockquote>
<p><code>rosrun controller_manager controller_manager start joint_group_position_controller</code></p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Started [<span class="string">'joint_group_position_controller'</span>] successfully</span><br></pre></td></tr></table></figure>
<ul>
<li><code>controller_manager</code>的详细指令如下：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ rosrun controller_manager controller_manager &lt;<span class="built_in">command</span>&gt; &lt;controller_name&gt;</span><br></pre></td></tr></table></figure>
<p>以下<code>command</code>可用:<br>| | |<br>| :—————— | :—————————————————— |<br>| <strong><code>load</code></strong>: | 加载控制器 (construct and initialize) |<br>| <strong><code>unload</code></strong>: | 卸载控制器 (destruct) |<br>| <strong><code>start</code></strong>: | 启动控制器 |<br>| <strong><code>stop</code></strong>: | 结束控制器 |<br>| <strong><code>spawn</code></strong>: | 加载并启动控制器 |<br>| <strong><code>kill</code></strong>: | 停止并卸载控制器 |<br>| | |</p>
<ul>
<li><p>开始输入关节位置控制指令</p>
</li>
<li><p>这里可以先查看一下关节位置指令的数据结构</p>
</li>
<li><p>输入:</p>
</li>
</ul>
<blockquote>
<p><code>rostopic list</code></p>
</blockquote>
<ul>
<li>可以看到有控制器的一个主题:</li>
</ul>
<blockquote>
<p><code>/joint_group_position_controller/command</code></p>
</blockquote>
<ul>
<li>查看主题信息：该<code>topic</code>的<code>type</code>是<code>std_msgs/Float64MultiArray</code>。因此我们<code>pub</code>这个<code>topic</code>时就需要发送这个数据结构。</li>
</ul>
<blockquote>
<p><code>rostopic info /joint_group_position_controller/command</code></p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Type: std_msgs/Float64MultiArray</span><br><span class="line"></span><br><span class="line">Publishers: None</span><br><span class="line"></span><br><span class="line">Subscribers:</span><br><span class="line"> * /rostopic_120258_1572071888740 (http://localhost:42655/)</span><br><span class="line"> * /gazebo (http://localhost:35425/)</span><br></pre></td></tr></table></figure>
<ul>
<li>发布主题。因为这里<code>Float64MultiArray</code>是一个数组，如果是单个数据类型，那在数据结构后面直接跟具体的数据即可。如果是数组，那需要以<code>python list</code>的方式发送。这里<code>-r 50</code>表示这个<code>topic</code>的发布速率是<code>50hz</code>。然后就可以在<code>gazebo</code>中看到机器人五轴转了一个角度。</li>
</ul>
<blockquote>
<p><code>rostopic pub -r 50 /joint_group_position_controller/command std_msgs/Float64MultiArray &#39;{data: [0,0,0,0,10,30]}&#39;</code></p>
</blockquote>
<ul>
<li>同时可以打开另一个终端，看到发布的<code>topic</code>的详细信息</li>
</ul>
<blockquote>
<p><code>rostopic echo /joint_group_position_controller/command</code></p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">layout:</span><br><span class="line">  dim: []</span><br><span class="line">  data_offset: 0</span><br><span class="line">data: [0.0, 0.0, 0.0, 0.0, 10.0, 30.0]</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ROS学习</category>
      </categories>
      <tags>
        <tag>ROS</tag>
        <tag>gazebo</tag>
        <tag>controller-manager</tag>
        <tag>ur5</tag>
      </tags>
  </entry>
</search>
